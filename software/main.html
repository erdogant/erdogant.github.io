<!DOCTYPE html>
<html lang="en">

    <!--
        This is the JavaScript widget for SkyWalk.
        @copyright Copyright (c) 2025 Erdogan Taskesen
        @license
        @author Erdogan Taskesen <erdogant@gmail.com>
    -->

<head>
  <meta charset="UTF-8">
    <!--RUN FULL SCREEN-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#2A3F54">
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">

  <title>Skywalk Flightplan</title>

  <!--<link rel="shortcut icon" type="image/x-icon" href="https://erdogant.github.io/datasets/skywalk/figs/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="https://erdogant.github.io/datasets/skywalk/figs/icon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://erdogant.github.io/datasets/skywalk/figs/icon16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://erdogant.github.io/datasets/skywalk/figs/icon180.png">-->

  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://pyscript.net/releases/2025.8.1/core.css">
  <script type="module" src="https://pyscript.net/releases/2025.8.1/core.js"></script>
</head>

<body>
  <div id="app">
    <div id="loading-spinner" class="spinner-overlay" style="display: flex;">
      <div class="spinner-container">
        <div class="spinner"></div>
        <div class="spinner-text">Loading SkyWalk. Please wait..</div>
      </div>
    </div>


    <!-- Tab links -->
    <div class="tab">
        <button class="tablinks active" data-tab="General">‚ñ∂Ô∏è Start</button>
        <button class="tablinks" data-tab="Departure">üõ´ Departure</button>
        <button class="tablinks" data-tab="Arrival">üõ¨ Arrival</button>
        <button class="tablinks" data-tab="Enroute">‚úàÔ∏è Enroute</button>
        <button class="tablinks" data-tab="ATC">üì¢ ATC</button>
        <button class="tablinks" data-tab="Menu">‚ò∞ More</button>
    </div>


	<div id="Menu" class="tabcontent">
        <button class="tablinks" data-tab="MAP">üó∫Ô∏è Map</button>
        <button class="tablinks" data-tab="Config">‚öôÔ∏è Config</button>
	</div>


    <!-- =============== TAB GENERAL =============== -->
	<!--<div id="General" class="tabcontent" style="display:block;">-->
	<div id="General" class="tabcontent">

	<!-- Logo -->
	  <div class="logo-container">
		<a href="https://erdogant.github.io/skywalk-docs/pages/html/index.html" target="_blank">
		  <img id="skywalk_logo" alt="SkyWalk">
		</a>
		<div class="version" style="margin-bottom: 5px; ">version: 0.4.1</div>
	  </div>


	<div class="button-row" style="justify-content: center;">
	    <label_h1 style="margin: 0; text-align: center;">Flightplan</label_h1>
	</div>

	  <div class="button-row">
			<button id="new_plan_btn">New Flightplan</button>
		<select id="plan_spinner" onchange="this.value && window.load_flightplan()">
		  <option value="">Load Flightplan</option>
		</select>
		<button id="delete_btn" style="background-color: transparent; border: none; color: #666; cursor: grab; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 0 8px 4px; flex: 0 0 auto;">üóëÔ∏è</button>
	  </div>

	  <!-- Flightplan Name row -->
	  <div class="button-row">
		<input type="text" id="FLIGHTPLAN" placeholder="Flightplan Name">
		<input type="text" id="DATETIME" placeholder="dd-mm-yyyy hh:mm">
		<!--<button id="set_datetime_btn">Now</button>-->
		<button id="set_datetime_btn" style="background-color: transparent; border: none; color: #666; cursor: grab; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 0 8px 4px; flex: 0 0 auto;">‚è∞</button>
	  </div>


	  <!-- Aircraft Info Label -->
	  <label_h1>Aircraft</label_h1>

	  <!-- CALLSIGN + Aircraft Type row -->
	  <div class="button-row">
        <input type="text" id="CALLSIGN" class="UPPERCASE_input" placeholder="CALLSIGN (PH-SVU)">
        <input type="text" id="AIRCRAFT_TYPE" class="UPPERCASE_input" placeholder="Aircraft Type (Robin400)">
    </div>

	  <!-- Persons on Board + Flight Rules row -->
	  <div class="button-row">
		<input type="text" id="POB" placeholder="Persons on Board">
		<select id="FLIGHT_RULES">
		  <option value="VFR">VFR</option>
		  <option value="IFR">IFR</option>
		</select>
	  </div>


	  <!-- Bottom Buttons Container -->
	  <div id="bottom-container">
    	  <div class="coffee-container">
    		<a href="https://www.buymeacoffee.com/erdogant" target="_blank">
    		  <img id="coffee_image" alt="Coffee Donation">
    		</a>
    	  </div>

    	  <!--<div class="bottom-ad">-->
           	<center>
          		<script async src="https://media.ethicalads.io/media/client/ethicalads.min.js"></script>
          		<div data-ea-publisher="erdogantgithubio" data-ea-type="text"></div>
           	</center>
    	  <!--</div>-->

	  </div>

	</div>


	<!-- ============================================= -->
	<!-- =============== TAB DEPARTURE =============== -->
	<!-- ============================================= -->

	<div id="Departure" class="tabcontent">

	  <!-- Departure Information Label -->
	  <label_h1>Departure Information</label_h1>

	  <!-- Departure Image -->
	  <div class="logo-container" style="margin-top: 20px;">
		<img id="DEPARTURE_image_cache" alt="Departure Aerodrome" style="max-width: 100%; height: auto; border-radius: 10px; cursor: pointer;" onclick="openAerodromeMap('DEPARTURE')">
	  </div>


	  <!-- Line 2: COUNTRY and ICAO_CITY spinners aligned -->
	  <div class="button-row">
		<select id="DEPARTURE_COUNTRY">
			<option value=""></option>
		</select>
		<select id="DEPARTURE_ICAO_CITY">
		  <option value=""></option>
		  <!-- ICAO City options will be populated dynamically -->
		</select>
	  </div>


	  <!-- Line 4: NAME and ICAO inputs -->
	  <div class="button-row">
		<input type="text" id="DEPARTURE_NAME" placeholder="Airport Name">
		<input type="text" id="DEPARTURE_ICAO" class="UPPERCASE_input" placeholder="ICAO">
	  </div>

    <div class="button-row">
        <button id="DEPARTURE_USE_CACHED" onclick="window.load_aerodrome_from_json('DEPARTURE')" style="width: auto;">Load your personalized aerodrome data</button>
    </div>

    <label_h1>Aerodrome</label_h1>

	  <!-- Line 5: POSITION, RUNWAY, ELEVATION inputs -->
	  <div class="button-row">
		<input type="text" id="DEPARTURE_POSITION" placeholder="Position (At the Apron)", class="UPPERCASE_input">
		<select id="DEPARTURE_CTR" onchange="highlightMissingFields()">
		  <option value=""></option>
		  <option value="CTR">CTR</option>
		</select>

	  </div>

	  <div class="button-row">
		<input type="text" id="DEPARTURE_RUNWAY" placeholder="Runway Number" title="Runway number is automatically predicted when retrieving METAR data" aria-label="Runway number is automatically predicted when retrieving METAR data">
		<input type="text" id="DEPARTURE_ELEVATION" placeholder="Field Elevation (ft)" title="Departure aerodrome elevation in feet (ft)." aria-label="Departure field elevation in feet">
	  </div>

	  <!-- Line 6: ROUTE_NAME, ROUTE_ALTITUDE, CIRCUIT_ALTITUDE inputs -->
	  <div class="button-row">
		<input type="text" id="DEPARTURE_ROUTE_NAME" placeholder="Route Name", class="UPPERCASE_input">
		<input type="text" id="DEPARTURE_ROUTE_ALTITUDE" placeholder="Route Altitude">
		<input type="text" id="DEPARTURE_CIRCUIT_ALTITUDE" placeholder="Circuit Altitude">
	  </div>

	  <!-- Line 7: Frequency label -->
	  <label_h1>Frequency</label_h1>

	  <!-- Line 8: ATC_TOWER and ATC_APPROACH inputs -->
	  <div class="button-row">
		<input type="text" id="DEPARTURE_ATC_TOWER" placeholder="Tower Frequency">
		<input type="text" id="DEPARTURE_ATC_APPROACH" placeholder="Approach Frequency">
	  </div>

	  <!-- Line 9: ATC_ATIS_FREQ and ATC_GROUND inputs -->
	  <div class="button-row">
		<input type="text" id="DEPARTURE_ATC_ATIS_FREQ" placeholder="ATIS Frequency">
		<input type="text" id="DEPARTURE_ATC_GROUND" placeholder="Ground Frequency">
	  </div>

	  <!-- Line 10: ATC_TELEPHONE input -->
	  <div class="button-row">
		<input type="text" id="DEPARTURE_ATC_TELEPHONE" placeholder="Telephone">
	  </div>

   <label_h1>METAR</label_h1>

    <div class="button-row">
        <button id="metar-widget-btn-departure" onclick="window.retrieve_metar_and_widget('DEPARTURE')" style="transition: background-color 0.3s; z-index: 1">Load METAR</button>
        <input type="text" id="datetime-metar-taf-departure" placeholder="Date and Time for METAR" style="transition: background-color 0.3s" readonly title="The UTC date/time for the retrieved METAR data.">
    </div>
    <div class="button-row">
        <textarea id="metar-field-departure" placeholder="METAR Information" style="transition: background-color 0.3s; width: 100%; min-height: 80px; max-height: 120px; resize: vertical; padding: 8px; box-sizing: border-box;" title="METAR information for the departure aerodrome is shown here after automatically retrieved." aria-label="METAR Information"></textarea>
    </div>

    <div id="departureWidgetContainer" style="display: flex; justify-content: center; align-items: center;"></div>

    <label_h1>Save Departure Information</label_h1>

    <div class="button-row">
        <button id="save_fields_btn_departure" style="background-color: #4CAF50; color: white;" title="Save fields for this Aerodrome">Save Aerodrome</button>
    </div>

    </div>


    <!-- ============================================= -->
	<!-- =============== TAB ARRIVAL =============== -->
	<!-- ============================================= -->

	<div id="Arrival" class="tabcontent">

        <!-- Arrival Information Label -->
        <label_h1>Arrival Information</label_h1>

        <!-- ARRIVAL Image -->
      	  <div class="logo-container" style="margin-top: 20px;">
      		<img id="ARRIVAL_image_cache" alt="Arrival Aerodrome" style="max-width: 100%; height: auto; border-radius: 10px; cursor: pointer;" onclick="openAerodromeMap('ARRIVAL')">
      	  </div>

        <!-- Line 2: COUNTRY and ICAO_CITY spinners aligned -->
        <div class="button-row">
            <select id="ARRIVAL_COUNTRY">
                <option value=""></option>
            </select>
                <select id="ARRIVAL_ICAO_CITY">
                <option value=""></option>
                <!-- ICAO City options will be populated dynamically -->
                </select>
        </div>


	<!-- Line 4: NAME and ICAO inputs -->
        <div class="button-row">
            <input type="text" id="ARRIVAL_NAME" placeholder="Airport Name">
            <input type="text" id="ARRIVAL_ICAO" class="UPPERCASE_input" placeholder="ICAO">
        </div>

        <div class="button-row">
            <button id="ARRIVAL_USE_CACHED" onclick="window.load_aerodrome_from_json('ARRIVAL')" style="width: auto;">Load your personalized aerodrome information</button>
	    </div>

     <label_h1>Aerodrome</label_h1>

        <!-- Line 5: POSITION, RUNWAY, ELEVATION inputs -->
        <div class="button-row">
            <input type="text" id="ARRIVAL_POSITION" placeholder="Position (At the Apron)", class="UPPERCASE_input">
            <select id="ARRIVAL_CTR" onchange="highlightMissingFields()">
                <option value=""></option>
                <option value="CTR">CTR</option>
            </select>
        </div>

        <div class="button-row">
            <input type="text" id="ARRIVAL_RUNWAY" placeholder="Runway Number">
            <input type="text" id="ARRIVAL_ELEVATION" placeholder="Field Elevation (ft)" title="Arrival aerodrome elevation in feet (ft)." aria-label="Arrival field elevation in feet">
        </div>

        <!-- Line 6: ROUTE_NAME, ROUTE_ALTITUDE, CIRCUIT_ALTITUDE inputs -->
        <div class="button-row">
            <input type="text" id="ARRIVAL_ROUTE_NAME" placeholder="Route Name", class="UPPERCASE_input">
            <input type="text" id="ARRIVAL_ROUTE_ALTITUDE" placeholder="Route Altitude">
            <input type="text" id="ARRIVAL_CIRCUIT_ALTITUDE" placeholder="Circuit Altitude">
        </div>

        <!-- Line 7: Frequency label -->
        <label_h1>Frequency</label_h1>

        <!-- Line 8: ATC_TOWER and ATC_APPROACH inputs -->
        <div class="button-row">
            <input type="text" id="ARRIVAL_ATC_TOWER" placeholder="Tower Frequency">
            <input type="text" id="ARRIVAL_ATC_APPROACH" placeholder="Approach Frequency">
        </div>

        <!-- Line 9: ATC_ATIS_FREQ and ATC_GROUND inputs -->
        <div class="button-row">
            <input type="text" id="ARRIVAL_ATC_ATIS_FREQ" placeholder="ATIS Frequency">
            <input type="text" id="ARRIVAL_ATC_GROUND" placeholder="Ground Frequency">
        </div>

        <!-- Line 10: ATC_TELEPHONE input -->
        <div class="button-row">
            <input type="text" id="ARRIVAL_ATC_TELEPHONE" placeholder="Telephone">
        </div>


        <label_h1>METAR</label_h1>

        <div class="button-row">
            <button id="metar-widget-btn-arrival" onclick="window.retrieve_metar_and_widget('ARRIVAL')" style="transition: background-color 0.3s; z-index: 1">Load METAR</button>
            <input type="text" id="datetime-metar-taf-arrival" placeholder="Date and Time" style="transition: background-color 0.3s" readonly title="The UTC date/time for the retrieved METAR data.">
        </div>
        <div class="button-row">
            <textarea id="metar-field-arrival" placeholder="METAR Information" style="transition: background-color 0.3s; width: 100%; min-height: 80px; max-height: 120px; resize: vertical; padding: 8px; box-sizing: border-box;" title="METAR information for the arrival aerodrome is shown here after automatically retrieved." aria-label="METAR Information"></textarea>
        </div>

        <div id="arrivalWidgetContainer" style="display: flex; justify-content: center; align-items: center;"></div>

        <label_h1>Save Arrival Information</label_h1>

        <div class="button-row">
            <button id="save_fields_btn_arrival" style="background-color: #4CAF50; color: white;" title="Save fields for this Aerodrome">Save Aerodrome</button>
        </div>

    </div>


    <!-- =============== TAB ENROUTE =============== -->
    <div id="Enroute" class="tabcontent">
        <label_h1>Enroute Information</label_h1>


    <!-- Line: FIC Name and FIC Frequency labels -->
        <div class="button-row">
          <div style="display:flex; flex-direction:column; flex:1; margin-right:10px;">
            <label for="FIC_NAME">FIC name</label>
          </div>
          <div style="display:flex; flex-direction:column; flex:1;">
            <label for="FIC_FREQUENCY">FIC frequency</label>
          </div>
        </div>

        <!-- Line: FIC Name and FIC Frequency inputs -->
        <div class="button-row">
          <input type="text" id="FIC_NAME" placeholder="FIC Name", class="REPLACE_INFO">
          <input type="text" id="FIC_FREQUENCY" placeholder="FIC Frequency">
        </div>
        <div class="button-row">
          <input type="text" id="OVERHEAD" placeholder="Overhead Point", class="UPPERCASE_input">
          <input type="text" id="SQUAWK" placeholder="SQUAWK">
        </div>

       	<!--Create selectionbox that is populated with previously cached FICs-->
    	<div class="button-row">
               	<select id="fic_spinner">
             	  <option value="">Select saved FIC</option>
               	</select>
                <button id="fic_save_btn" style="background-color: transparent; border: none; color: #666; cursor: grab; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 0 8px 4px; flex: 0 0 auto;">üíæ</button>
                <button id="fic_delete_btn" style="background-color: transparent; border: none; color: #666; cursor: grab; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 0 8px 4px; flex: 0 0 auto;">üóëÔ∏è</button>
    	</div>

        <!-- Line: SECOND FIC label -->
        <label_h1>SECOND FIC</label_h1>

        <!-- Line: FIC Name2 and FIC Frequency2 inputs -->
        <div class="button-row">
          <input type="text" id="FIC_NAME2" placeholder="FIC Name 2", class="REPLACE_INFO">
          <input type="text" id="FIC_FREQUENCY2" placeholder="FIC Frequency 2">
        </div>
        <div class="button-row">
          <input type="text" id="OVERHEAD2" placeholder="Overhead Point", class="UPPERCASE_input">
          <input type="text" id="SQUAWK2" placeholder="SQUAWK">
        </div>

       	<!--Create selectionbox that is populated with previously cached FICs-->
    	<div class="button-row">
               	<select id="fic_spinner2">
             	  <option value="">Select saved FIC</option>
               	</select>
                <button id="fic_save_btn2" style="background-color: transparent; border: none; color: #666; cursor: grab; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 0 8px 4px; flex: 0 0 auto;">üíæ</button>
                <button id="fic_delete_btn2" style="background-color: transparent; border: none; color: #666; cursor: grab; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 0 8px 4px; flex: 0 0 auto;">üóëÔ∏è</button>
    	</div>

    </div>

    <!-- =============== TAB ATC =============== -->


    <div id="ATC" class="tabcontent">
        <!-- ATC -->
        <label_h1>Display Settings</label_h1>

        <div style="border: 1px solid lightgrey; border-radius: 10px; padding: 10px;">
            <div class="button-row">
                <div style="display:flex; flex-direction:column; flex:1; margin-right:10px;">
                    <label for="user_usage_type">Choose Output</label>
                    <select id="user_usage_type">
                        <option value="print" selected>Print</option>
                        <option value="view">Screen</option>
                    </select>
                </div>

                <div style="display:flex; flex-direction:column; flex:1;">
                    <label for="user_select_cols">Columns</label>
                    <select id="user_select_cols">
                        <option value="1">1</option>
                        <option value="2" selected>2</option>
                        <option value="3">3</option>
                    </select>
                </div>
            </div>
        </div>

        <label_h1>Required Fields</label_h1>
        <div style="border: 1px solid lightgrey; border-radius: 10px; padding: 10px;">
            <div id="bottom-container">
                <div class="warning" id="missing_label">Missing: Flightplan Name, CALLSIGN, Aircraft Type</div>
            </div>
        </div>


       <label_h1>Air Traffic Control (ATC)</label_h1>

       <div style="border: 1px solid lightgrey; border-radius: 10px; padding: 10px;">
           <div class="button-row">
               <button id="BTN_HTML_SUMMARY">Summary ATC</button>
                <button id="BTN_HTML_SUMMARY_REV">Reverse</button>
            </div>
            <div class="button-row">
                <button id="BTN_HTML_DEPARTURE">Departure ATC</button>
                <button id="BTN_HTML_DEPARTURE_REV">Reverse</button>
            </div>
            <div class="button-row">
                <button id="BTN_HTML_ARRIVAL">Arrival ATC</button>
                <button id="BTN_HTML_ARRIVAL_REV">Reverse</button>
            </div>
            <div class="button-row">
                <button id="BTN_HTML_ENROUTE">Enroute ATC</button>
                <button id="BTN_HTML_EN_REV">Reverse</button>
            </div>
       </div>


       <div class="button-row">
           <button id="save_fields_btn" style="background-color: #4CAF50; color: white;" title="Saving fields in flightplan">Save Flightplan</button>
       </div>

    </div>




    <!-- =============== TAB MAP =============== -->
    <div id="MAP" class="tabcontent">
        <!--<label_h1>MAP</label_h1>-->

        <div class="button-row">
            <select id="layer-select">
                <option value="OpenStreetMap">OpenStreetMap</option>
                <option value="OpenTopoMap">OpenTopoMap</option>
                <!--<option value="Carto Voyager">Carto Voyager</option>-->
            </select>
        </div>

        <div class="button-row">
            <label>
                <input type="checkbox" id="aviation-toggle" checked> Show Airports
            </label>
            <label>
                <input type="checkbox" id="airspace-toggle" checked> Show Airspace
            </label>
        </div>

        <div class="button-row">
            <div style="display: flex; align-items: center; margin-top: 5px;">
                <label style="margin-right: 5px;">Airspaces at altitude (ft):</label>
                <input type="number" id="airspace-altitude" value="1500" min="150" max="10000" step="150" style="width: 80px;">
            </div>
        </div>

        <div class="button-row">
            <div style="display: flex; gap: 10px;">
                <label>
                    <input type="checkbox" id="TMZ-toggle">TMZ
                </label>
                <label>
                    <input type="checkbox" id="CTA_TMA-toggle">CTA/TMA
                </label>
                <label>
                    <input type="checkbox" id="danger-toggle">Danger
                </label>
                <label>
                    <input type="checkbox" id="prohibited-toggle">Prohibited
                </label>
            </div>
        </div>

        <div id="map-container" style="height: 500px;">
            <div id="route-map" style="height: 100%;"></div>
            <div class="map-controls" style="position: absolute; top: 10px; right: 10px; background: none; padding: 0; z-index: 1000;">
                <button id="fullscreen-btn" onclick="toggleFullscreen()" style="width: 44px; height: 44px; padding: 0; background: white; border: 2px solid rgba(0,0,0,0.2); border-radius: 4px; cursor: pointer; touch-action: manipulation;">
                    <svg class="fullscreen-enter" viewBox="0 0 24 24" style="width: 24px; height: 24px; margin: 8px;">
                        <path d="M7,14H5v5h5v-2H7V14z M5,10h2V7h3V5H5V10z M17,17h-3v2h5v-5h-2V17z M14,5v2h3v3h2V5H14z"/>
                    </svg>
                    <svg class="fullscreen-exit" viewBox="0 0 24 24" style="width: 24px; height: 24px; margin: 8px; display: none;">
                        <path d="M5,16h3v3h2v-5H5V16z M8,8H5v2h5V5H8V8z M14,19h2v-3h3v-2h-5V19z M16,8V5h-2v5h5V8H16z"/>
                    </svg>
                </button>
            </div>
        </div>


        <!-- Leaflet CSS -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>

        <label_h1>Warning</label_h1>
         <div class="warning" style="margin-bottom: 20px; border: 2px solid orange; border-radius: 10px; padding: 10px;">The airspace projections on the map are based on data that can be outdated or inaccurate. Do not navigate using the map but only use it for educational purposes.</div>



    </div>

    <!-- =============== TAB CONFIGURATIONS =============== -->

    <div id="Config" class="tabcontent">
        <!-- CONFIGURATIONS -->
        <label_h1>Information</label_h1>
        <div class="info" style="margin-bottom: 20px;">SkyWalk is a web-based tool designed to help pilots communicate effectively with Air Traffic Control (ATC). The app is free for use, is for educational purposes and does not require any registration or login. If you enjoy using SkyWalk, please consider supporting by donating a coffee.</div>

        <label_h1>Cleaning</label_h1>
        <div class="button-row" style="margin-top: 20px;">
            <button id="clear_cache_btn" style="background-color: #ff4444; color: white;">Clear Cache</button>
        </div>
        <div class="warning" style="margin-bottom: 20px;">Warning: This will permanently delete all saved flightplans and aerodrome images from your local browser storage. The reason for using this is when you want to start fresh or when you suspect that your flightplans or images are corrupted or the ATC page does not show or update. This action cannot be undone.</div>

        <label_h1>Disclaimer</label_h1>
         <div class="disclaimer" style="margin-bottom: 20px; border: 2px solid red; border-radius: 10px; padding: 10px;">SkyWalk is provided ‚Äúas is,‚Äù without any warranties, express or implied. SkyWalk is intended for educational use. The developers assume no liability for any damages arising from using this application.</div>

    </div>






<script>
    let routeMap = null;
    let routeLine = null;
    let routeMarkers = [];
    // let waypoints = [];
    let waypointMarkers = [];
    let airportLayer = null;
    let airportData = null;
    let airspaceLayer = null;
    let TMZLayer = null;


    // Define base layers
    const baseLayers = {
        'OpenStreetMap': L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' }),
        'OpenTopoMap': L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17, attribution: '&copy; OpenTopoMap' }),
        // 'Carto Voyager': L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { subdomains: 'abcd', attribution: '&copy; CARTO' }),
    };

    // Initialize map
    function initRouteMap() {
        console.log('Initializing route map');
        if (routeMap) {
            routeMap.remove();
            routeMap = null;
        }

        routeMap = L.map('route-map', {
            zoomControl: true,
            dragging: true,
            touchZoom: true,
            scrollWheelZoom: true,
            layers: [baseLayers['OpenStreetMap']] // default layer
        });

        routeMap.setView([52, 5], 6);

        // Handle layer selection
        const layerSelect = document.getElementById('layer-select');
        layerSelect.onchange = function() {
            const selectedLayer = this.value;
            Object.values(baseLayers).forEach(layer => routeMap.removeLayer(layer));
            baseLayers[selectedLayer].addTo(routeMap);
        };

        // Force resize to render correctly
        setTimeout(() => routeMap.invalidateSize(), 100);
    }

    // Update route
    async function updateRoute() {
        console.log('Updating route and checking for airport data');
        // Clear existing route line
        if (routeLine) {
            routeMap.removeLayer(routeLine);
            routeLine = null;
        }
        // Clear existing route markers
        routeMarkers.forEach(marker => routeMap.removeLayer(marker));
        routeMarkers = [];

        const depLatLon = window.flight_plan_data?.DEPARTURE_LATLON || [null, null];
        const arrLatLon = window.flight_plan_data?.ARRIVAL_LATLON || [null, null];
        const df = window.AERODROME_DATA;
        // console.log('Raw coordinates - Departure:', depLatLon, 'Arrival:', arrLatLon);

        // Clear existing airport layer
        if (airportLayer) {
            routeMap.removeLayer(airportLayer);
            airportLayer = null;
        }

        // Reset airport data
        airportData = null;

        // Use departure data as default
        console.log('Departure data available:', df ? 'Yes' : 'No');

        if (df) {
            // Create fresh airport data
            airportData = createAirportGeoJSON(df);

            // Display airports if checkbox is checked
            if (document.getElementById('aviation-toggle').checked) {
                toggleAirportLayer();
            }
        }


        if (!depLatLon?.[0] || !arrLatLon?.[0]) return;

        if (routeLine) routeLine.remove();
        routeMarkers.forEach(m => m.remove());
        routeMarkers = [];

        const depCoords = [depLatLon[0], depLatLon[1]];
        const arrCoords = [arrLatLon[0], arrLatLon[1]];
        const weight_line = 8;

        // Create or update initial waypoints array including departure and arrival while preserving user-added waypoints
        if (!Array.isArray(window.waypoints) || window.waypoints.length < 2) {
            // No existing waypoints (first load) ‚Äî initialize with departure and arrival
            window.waypoints = [depCoords, arrCoords];
        } else {
            // Preserve existing intermediate waypoints added by the user.
            // Ensure the first and last points always match current departure and arrival.
            const eps = 1e-6;
            function coordsEqual(a, b) {
                return Math.abs(a[0] - b[0]) < eps && Math.abs(a[1] - b[1]) < eps;
            }
            // Update departure (first) point if it changed
            if (!coordsEqual(window.waypoints[0], depCoords)) {
                window.waypoints[0] = depCoords;
            }
            // Update arrival (last) point if it changed
            if (!coordsEqual(window.waypoints[window.waypoints.length - 1], arrCoords)) {
                window.waypoints[window.waypoints.length - 1] = arrCoords;
            }
            // If somehow waypoints were reduced to <2, re-initialize
            if (window.waypoints.length < 2) {
                window.waypoints = [depCoords, arrCoords];
            }
        }

        // Create the route line with waypoints
        routeLine = L.polyline(window.waypoints, {
            color: '#8A00C4',
            weight: weight_line,
            opacity: 0.6,
            smoothFactor: 1,
            zIndex: 6000,  // Highest z-index to stay above everything
            pane: 'markerPane',  // Use marker pane to ensure line stays on top
            interactive: true    // Make line clickable for adding waypoints
        }).addTo(routeMap);

        // Add waypoint markers
        updateWaypoints();

        // Add click handler to the line to create new waypoints
        routeLine.on('click', function(e) {
            // Highlight the line when clicked
            routeLine.setStyle({weight: 5, opacity: 1});
            setTimeout(() => routeLine.setStyle({weight: weight_line, opacity: 0.8}), 200);
            const newPoint = [e.latlng.lat, e.latlng.lng];
            // Find the closest segment and insert the new point
            let minDist = Infinity;
            let insertIndex = 1;

            for (let i = 0; i < window.waypoints.length - 1; i++) {
                const dist = pointToSegmentDistance(newPoint, window.waypoints[i], window.waypoints[i + 1]);
                if (dist < minDist) {
                    minDist = dist;
                    insertIndex = i + 1;
                }
            }

            window.waypoints.splice(insertIndex, 0, newPoint);
            updateWaypoints();
        });

        const depICAO = window.flight_plan_data?.DEPARTURE_ICAO_CITY || 'Departure';
        const arrICAO = window.flight_plan_data?.ARRIVAL_ICAO_CITY || 'Arrival';

        routeMarkers.push(
            L.marker(depCoords, {
                draggable: false,
                title: depICAO,
                zIndexOffset: 7000 // Ensure departure marker stays on top
            })
                .addTo(routeMap)
                .bindPopup(depICAO, { closeButton: false })
        );
        routeMarkers.push(
            L.marker(arrCoords, {
                draggable: false,
                title: arrICAO,
                zIndexOffset: 7000 // Ensure arrival marker stays on top
            })
                .addTo(routeMap)
                .bindPopup(arrICAO, { closeButton: false })
        );

        routeMap.fitBounds(routeLine.getBounds(), {
            padding: [50, 50],
            maxZoom: 12
        });

        // Add tooltip to explain right-click functionality
        waypointMarkers.forEach(marker => {
            marker.bindTooltip("Right-click to remove waypoint", {
                direction: 'top',
                offset: [0, -10]
            });
        });
    }

    // Helper function to calculate point to segment distance
    function pointToSegmentDistance(p, v1, v2) {
        const x = p[0], y = p[1];
        const x1 = v1[0], y1 = v1[1];
        const x2 = v2[0], y2 = v2[1];

        const A = x - x1;
        const B = y - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;

        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;

        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = x - xx;
        const dy = y - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Function to update waypoint markers and route line
    function updateWaypoints() {
        // Clear existing waypoint markers
        waypointMarkers.forEach(marker => routeMap.removeLayer(marker));
        waypointMarkers = [];

        // Update route line
        routeLine.setLatLngs(window.waypoints);

        // Create new waypoint markers (skip first and last points which are airports)
        for (let i = 1; i < window.waypoints.length - 1; i++) {
            const marker = L.marker(window.waypoints[i], {
                draggable: true,
                icon: L.divIcon({
                    className: 'waypoint-icon',
                    html: '<div style="background-color: #FFFFFF; width: 13px; height: 13px; border-radius: 50%; border: 1px solid black;"></div>',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                }),
                zIndexOffset: 3000
            }).addTo(routeMap);

            // Add drag and hover handlers
            marker.on('drag', function(e) {
                window.waypoints[i] = [e.latlng.lat, e.latlng.lng];
                routeLine.setLatLngs(window.waypoints);
            });

            marker.on('contextmenu', function() {
                // Remove waypoint on right click
                window.waypoints.splice(i, 1);
                updateWaypoints();
            });

            waypointMarkers.push(marker);
        }
    }


    function toggleFullscreen() {
        const mapContainer = document.getElementById('map-container');
        const fullscreenBtn = document.getElementById('fullscreen-btn');

        if (!mapContainer || !fullscreenBtn) {
            console.error('Required elements not found for fullscreen toggle');
            return;
        }

        const enterIcon = fullscreenBtn.querySelector('.fullscreen-enter');
        const exitIcon = fullscreenBtn.querySelector('.fullscreen-exit');

        if (!enterIcon || !exitIcon) {
            console.error('Fullscreen icons not found');
            return;
        }

        const isFullscreen =
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement ||
            mapContainer.classList.contains('mobile-fullscreen');

        if (!isFullscreen) {
            // Enter fullscreen
            if (mapContainer.requestFullscreen) {
                mapContainer.requestFullscreen().catch(() => {});
            } else if (mapContainer.webkitRequestFullscreen) {
                mapContainer.webkitRequestFullscreen();
            } else if (mapContainer.mozRequestFullScreen) {
                mapContainer.mozRequestFullScreen();
            } else if (mapContainer.msRequestFullscreen) {
                mapContainer.msRequestFullscreen();
            } else {
                // Fallback for iPhone / mobile fullscreen
                mapContainer.classList.add('mobile-fullscreen');
                document.body.classList.add('no-scroll');
            }
            enterIcon.style.display = 'none';
            exitIcon.style.display = 'inline';
            fullscreenBtn.style.position = 'fixed';
            fullscreenBtn.style.zIndex = '2000';
        } else {
            // Exit fullscreen
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            } else {
                mapContainer.classList.remove('mobile-fullscreen');
                document.body.classList.remove('no-scroll');
            }
            enterIcon.style.display = 'inline';
            exitIcon.style.display = 'none';
            fullscreenBtn.style.position = 'absolute';
            fullscreenBtn.style.zIndex = '1000';
        }

        // Ensure map resizes properly
        setTimeout(() => {
            if (window.routeMap) window.routeMap.invalidateSize();
        }, 300);
    }


    // Handle fullscreen changes from any source
    function handleFullscreenChange() {
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        if (!fullscreenBtn) return;

        const enterIcon = fullscreenBtn.querySelector('.fullscreen-enter');
        const exitIcon = fullscreenBtn.querySelector('.fullscreen-exit');
        if (!enterIcon || !exitIcon) return;

        const isFullscreen = document.fullscreenElement ||
                           document.webkitFullscreenElement ||
                           document.mozFullScreenElement ||
                           document.msFullscreenElement;

        if (!isFullscreen) {
            enterIcon.style.display = 'inline';
            exitIcon.style.display = 'none';
            fullscreenBtn.style.position = 'absolute';
            fullscreenBtn.style.zIndex = '1000';
        } else {
            enterIcon.style.display = 'none';
            exitIcon.style.display = 'inline';
            fullscreenBtn.style.position = 'fixed';
            fullscreenBtn.style.zIndex = '2000';
        }
    }

    // Listen for fullscreen changes
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);


    // Initialize map and route on DOM load
    // document.addEventListener('DOMContentLoaded', () => {
    //     initRouteMap();
    //     updateRoute();

    //     // Handle tab clicks if present
    //     document.querySelectorAll('.tablinks').forEach(tab => {
    //         tab.addEventListener('click', () => {
    //             console.log('Tab clicked');
    //             setTimeout(() => {
    //                 routeMap.invalidateSize();
    //                 updateRoute();
    //             }, 100);
    //         });
    //     });
    // });

    // Simple example with a few major airports
    // const airportData = {
    //   "type": "FeatureCollection",
    //   "features": [
    //     { "type": "Feature", "properties": { "name": "Schiphol Airport (EHAM)" }, "geometry": { "type": "Point", "coordinates": [4.763385, 52.310539] } },
    //     { "type": "Feature", "properties": { "name": "Amsterdam Lelystad (EHLE)" }, "geometry": { "type": "Point", "coordinates": [5.525, 52.460] } },
    //     { "type": "Feature", "properties": { "name": "Rotterdam The Hague (EHDR)" }, "geometry": { "type": "Point", "coordinates": [4.435, 51.950] } }
    //   ]
    // };

    // Create GeoJSON from aerodrome data
    function createAirportGeoJSON(df) {
        const features = [];

        // console.log('Creating airport GeoJSON from data:', df);
        if (df) {
            for (const row of df) {
                // console.log('Processing row:', row);
                // Convert Proxy to regular object
                //
                const data = {
                    lat: row.lat?.valueOf(),
                    lon: row.lon?.valueOf(),
                    city_icao: row.city_icao?.valueOf(),
                    icao: row.icao?.valueOf(),
                    use: row.use?.valueOf(),
                    country: row.country?.valueOf(),
                    runways: String(row.runways?.valueOf() || '').toLowerCase(),
                    AERODROME_CTR: row.AERODROME_CTR?.valueOf(),
                    elevation_aerodrome: row.elevation_aerodrome?.valueOf()
                };


                // Determine runway type from runway string
                if (data.lat && data.lon && data.city_icao) {
                    // console.log('Valid coordinates found:', data.lat, data.lon, data.city_icao, data.use);
                        features.push({
                            "type": "Feature",
                            "properties": {
                                "name": data.city_icao,
                                "icao": data.icao,
                                "ctr": data.AERODROME_CTR ? true : false,
                                "elevation": data.elevation_aerodrome || 'N/A',
                                "use": data.use || 'public',
                                "runways": data.runways,
                                "runway_number": data.runway_number,
                                "country": data.country,
                            },
                        "geometry": {
                            "type": "Point",
                            "coordinates": [parseFloat(data.lon), parseFloat(data.lat)]
                        }
                    });
                }
            }
        }

        return {
            "type": "FeatureCollection",
            "features": features
        };
    }



    // function extractRunwayNumbers(runwaysString) {
    //     if (typeof runwaysString !== "string") return [];

    //     // 1. Find the `'number': [...]` part
    //     const match = runwaysString.match(/'number'\s*:\s*\[([^\]]*)\]/);

    //     if (!match) return [];

    //     // 2. Extract the inside of the brackets
    //     const inside = match[1];

    //     // 3. Split values between quotes
    //     const numbers = inside.match(/'([^']+)'/g);

    //     if (!numbers) return [45, 315];

    //     // 4. Strip quotes + convert to integers
    //     return numbers
    //         .map(n => n.replace(/'/g, "").trim())
    //         .map(n => parseInt(n, 10));  // Remove invalid values
    // }

    function extractRunwayNumbers(runwaysString) {
        if (typeof runwaysString !== "string") return [];

        // Extract ALL occurrences of number: [...]
        // Supports 'number' or "number"
        const matches = runwaysString.match(/["']number["']\s*:\s*\[([^\]]*)\]/g);

        if (!matches) return [];

        let allNumbers = [];

        for (const item of matches) {

            // Extract inside brackets of this specific occurrence
            const inside = item.match(/\[([^\]]*)\]/);
            if (!inside) continue;

            // Extract all quoted elements inside the brackets
            const nums = inside[1].match(/["']([^"']+)["']/g);
            if (!nums) continue;

            // Clean + convert to integer
            nums.forEach(n => {
                const clean = n.replace(/['"]/g, "").trim();
                const val = parseInt(clean, 10);
                if (!isNaN(val)) allNumbers.push(val);
            });
        }

        // Fallback only if *no valid runway numbers* found
        if (allNumbers.length === 0) return [45, 315];

        return allNumbers;
    }

    function selectRunwayIndices(runwayNumbers) {
        if (runwayNumbers.length >= 6) return [0, 3, 5];
        if (runwayNumbers.length >= 4) return [0, 3];
        if (runwayNumbers.length >= 2) return [0];
        return []; // not enough info
    }

    function buildRunwayRects(runwayNumbers, runwayColor) {
        const idx = selectRunwayIndices(runwayNumbers);
        if (idx.length === 0) return ""; // nothing to draw

        return idx
            .map(i => {
                const heading = runwayNumbers[i] * 10; // convert to degrees
                return `
                    <rect x="14" y="4" width="4" height="24"
                          fill="${runwayColor}"
                          stroke="#333" stroke-width="1"
                          fill-opacity="0.8" stroke-opacity="0.8"
                          transform="rotate(${heading} 16 16)" />
                `;
            })
            .join("\n");
    }

    function toggleAirportLayer() {
        // console.log('Toggle airport layer called');
        if (document.getElementById('aviation-toggle').checked) {
            if (airportLayer) return; // Layer already exists
            if (!airportData) return; // No data to display

            console.log('Adding airport layer to map');
            // Create a feature group to hold markers and circles with high z-index
            airportLayer = L.featureGroup({
                zIndex: 1000  // Ensure airport layer stays on top of everything
            }).addTo(routeMap);

            // Add GeoJSON features
            L.geoJSON(airportData, {
                pointToLayer: function(feature, latlng) {
                    const props = feature.properties;
                    const isMilitary = props.use.toLowerCase() === 'military';
                    let runwayColor = '#2196F3'; // Blue for others;
                    let circleColor = '#FFFFFF'; // White for others;
                    let runwayType = props.runways.includes('asphalt') ? 'Hard' : props.runways.includes('grass') ? 'Soft' : 'Unknown';
                    let runwayNumbers = extractRunwayNumbers(props.runways)
                    let fillOpacity = 0.3


                    const popupContent = `
                        <b>${props.name}</b>
                        <div style='width: 200px; padding: 10px; border: 1px solid lightgrey; border-radius: 5px; background-color: #f9f9f9;'>
                            <b>Country:</b> ${props.country}<br>
                            <b>Type:</b> ${props.use}<br>
                            <b>CTR:</b> ${props.ctr || isMilitary ? 'Yes' : 'No'}<br>
                            <b>Runway Elevation:</b> ${props.elevation} ft<br>
                            <b>Runway Surface:</b> ${runwayType}
                        </div>
                    `;

                    if (isMilitary) {
                        circleColor = '#8B0000'; // Red for military
                        fillOpacity = 0.15;
                    } else if (props.ctr || props.runways.includes('asphalt')) {
                        circleColor = '#FF69B4';  // pink for CTR
                        fillOpacity = 0.15;
                    } else {
                        circleColor = '#FFFFFF'; // Blue for other
                    }

                    if (runwayType === 'Hard') {
                        runwayColor = '#666666'; //Gray for hard/asphalt
                    } else if (runwayType === 'Soft') {
                        runwayColor = '#8BC34A'; //Green for soft/grass
                    } else {
                        runwayColor = '#2196F3'; //Blue for other
                    }

                    // const airstripIcon = L.divIcon({
                    //   className: 'airstrip-marker-icon',
                    //   html: `
                    //     <svg width="32" height="32" viewBox="0 0 32 32">
                    //       <circle cx="16" cy="16" r="8" fill="${circleColor}" stroke="#333" stroke-width="1.5" fill-opacity="0.6" stroke-opacity="0.8"/>
                    //       <rect x="14" y="4" width="4" height="24" fill="${runwayColor}" stroke="#333" stroke-width="1" fill-opacity="0.8" stroke-opacity="0.8"
                    //         transform="rotate(${runwayNumbers[0]*10} 16 16)" />
                    //     </svg>
                    //   `,
                    //   iconSize: [32, 32],
                    //   iconAnchor: [16, 16]
                    // });

                    const runwayRects = buildRunwayRects(runwayNumbers, runwayColor);

                    const airstripIcon = L.divIcon({
                        className: 'airstrip-marker-icon',
                        html: `
                            <svg width="32" height="32" viewBox="0 0 32 32">
                                <circle cx="16" cy="16" r="8"
                                        fill="${circleColor}"
                                        stroke="#333"
                                        stroke-width="1.5"
                                        fill-opacity="0.6"
                                        stroke-opacity="0.8"/>
                                ${runwayRects}
                            </svg>
                        `,
                        iconSize: [32, 32],
                        iconAnchor: [16, 16]
                    });


                    // Create marker with custom icon
                    const marker = L.marker(latlng, {
                        title: props.name,
                        icon: airstripIcon, //markerIcon,
                        pane: 'markerPane',  // Use marker pane to ensure markers stay on top
                        zIndexOffset: 4000   // High z-index offset to stay above other markers
                    }).bindPopup(popupContent);

                    // Add to feature group
                    airportLayer.addLayer(marker);

                    // If it's a CTR or isMilitary, add a circle with color based on use
                    if (props.ctr || isMilitary) {
                            const circle = L.circle(latlng, {
                                radius: 14900, // 5NM in meters
                                color: circleColor,
                                weight: 1,
                                // opacity: 0.3,
                                fillOpacity: fillOpacity,
                                pane: 'markerPane'  // Use marker pane to ensure circles stay on top
                            });
                            circle.bindPopup(popupContent);
                            airportLayer.addLayer(circle);
                    }
                    return marker;
                }
            });
        } else {
            if (airportLayer) {
                routeMap.removeLayer(airportLayer);
                airportLayer = null;
                console.log('Removed airport layer');
            }
        }
    }

    function loadAirspaceData() {
        // Return the airspaces data from Python (attached to window)
        if (window.airspaces) {
            return window.airspaces;
        } else {
            console.error("No airspace data available");
            js.window.alert('No airspace data available for this region');
            return null;
        }
    }

    // Global variable to store all airspace layers
    let airspaceLayerGroups = {};

    async function toggleAirspaceLayer() {
        const airspaceCheckbox = document.getElementById('airspace-toggle');
        const TMZCheckbox = document.getElementById('TMZ-toggle');

        if (!airspaceCheckbox) return;

        if (!window.airspaces) {
            console.error('No airspace data available');
            js.window.alert('No airspace data available for this region');
            airspaceCheckbox.checked = false;
            if (TMZCheckbox) TMZCheckbox.checked = false;
            return;
        }

        // Sync TMZ checkbox state with main airspace toggle
        if (TMZCheckbox) {
            TMZCheckbox.checked = airspaceCheckbox.checked;
            toggleTMZLayer(); // Update TMZ layer based on new state
        }

        // Always clear existing layers first
        Object.values(airspaceLayerGroups).forEach(layer => {
            if (routeMap.hasLayer(layer)) {
                routeMap.removeLayer(layer);
            }
        });
        airspaceLayerGroups = {};

        if (airspaceCheckbox.checked) {
            console.log('Adding all airspace layers');
            // Create new layers
            const altitudeValue = parseInt(document.getElementById('airspace-altitude').value) || 1500;
            const layers = createAirspaceLayer(window.airspaces, routeMap, altitudeValue);

            // Store and add each layer by type
            if (layers) {
                Object.entries(layers).forEach(([type, layer]) => {
                    if (layer) {
                        airspaceLayerGroups[type] = layer;
                        layer.addTo(routeMap);
                    }
                });
            }
        } else {
            console.log('Removed all airspace layers');
        }

        // Sync other checkboxes with main airspace toggle
        const CTACheckbox = document.getElementById('CTA_TMA-toggle');
        if (CTACheckbox) {
            CTACheckbox.checked = airspaceCheckbox.checked;
        }

        const dangerCheckbox = document.getElementById('danger-toggle');
        if (dangerCheckbox) {
            dangerCheckbox.checked = airspaceCheckbox.checked;
        }

        const prohibitedCheckbox = document.getElementById('prohibited-toggle');
        if (prohibitedCheckbox) {
            prohibitedCheckbox.checked = airspaceCheckbox.checked;
        }
    }



    async function toggleCTATMALayer() {
        const checkbox = document.getElementById('CTA_TMA-toggle');
        if (!checkbox || !window.airspaces) return;

        const filtered = {};
        Object.entries(window.airspaces).forEach(([key, space]) => {
            const at = (space.area_type || '').toLowerCase();
            if (at.includes('cta') || at.includes('tma')) {
                filtered[key] = space;
            }
        });

        if (airspaceLayerGroups.CTA_TMA && routeMap.hasLayer(airspaceLayerGroups.CTA_TMA)) {
            routeMap.removeLayer(airspaceLayerGroups.CTA_TMA);
            delete airspaceLayerGroups.CTA_TMA;
        }

        if (checkbox.checked) {
            const altitudeValue = parseInt(document.getElementById('airspace-altitude').value) || 1500;
            const layers = createAirspaceLayer(filtered, routeMap, altitudeValue);
            if (layers && layers.CTA_TMA) {
                airspaceLayerGroups.CTA_TMA = layers.CTA_TMA;
                layers.CTA_TMA.addTo(routeMap);
            }
        } else {
            console.log('Removed CTA/TMA layer');
        }
    }

    async function toggleDangerLayer() {
        const checkbox = document.getElementById('danger-toggle');
        if (!checkbox || !window.airspaces) return;

        const filtered = {};
        Object.entries(window.airspaces).forEach(([key, space]) => {
            const at = (space.area_type || '').toLowerCase();
            if (at.includes('danger')) {
                filtered[key] = space;
            }
        });

        if (airspaceLayerGroups.danger && routeMap.hasLayer(airspaceLayerGroups.danger)) {
            routeMap.removeLayer(airspaceLayerGroups.danger);
            delete airspaceLayerGroups.danger;
        }

        if (checkbox.checked) {
            const altitudeValue = parseInt(document.getElementById('airspace-altitude').value) || 1500;
            const layers = createAirspaceLayer(filtered, routeMap, altitudeValue);
            if (layers && layers.danger) {
                airspaceLayerGroups.danger = layers.danger;
                layers.danger.addTo(routeMap);
            }
        } else {
            console.log('Removed danger layer');
        }
    }

    async function toggleProhibitedLayer() {
        const checkbox = document.getElementById('prohibited-toggle');
        if (!checkbox || !window.airspaces) return;

        const filtered = {};
        Object.entries(window.airspaces).forEach(([key, space]) => {
            const at = (space.area_type || '').toLowerCase();
            if (at.includes('prohibited')) {
                filtered[key] = space;
            }
        });

        if (airspaceLayerGroups.prohibited && routeMap.hasLayer(airspaceLayerGroups.prohibited)) {
            routeMap.removeLayer(airspaceLayerGroups.prohibited);
            delete airspaceLayerGroups.prohibited;
        }

        if (checkbox.checked) {
            const altitudeValue = parseInt(document.getElementById('airspace-altitude').value) || 1500;
            const layers = createAirspaceLayer(filtered, routeMap, altitudeValue);
            if (layers && layers.prohibited) {
                airspaceLayerGroups.prohibited = layers.prohibited;
                layers.prohibited.addTo(routeMap);
            }
        } else {
            console.log('Removed prohibited layer');
        }
    }

    async function toggleTMZLayer() {
        const TMZCheckbox = document.getElementById('TMZ-toggle');
        if (!TMZCheckbox || !window.airspaces) return;

        // Filter and process only TMZ areas
        const tmzAirspaces = {};
        Object.entries(window.airspaces).forEach(([key, space]) => {
            if (space.area_type && space.area_type.toLowerCase().includes('tmz')) {
                tmzAirspaces[key] = space;
            }
        });

        // Always remove existing TMZ layer first
        if (airspaceLayerGroups.TMZ && routeMap.hasLayer(airspaceLayerGroups.TMZ)) {
            routeMap.removeLayer(airspaceLayerGroups.TMZ);
            delete airspaceLayerGroups.TMZ;
        }

        if (TMZCheckbox.checked) {
            console.log('Adding TMZ layer');
            const altitudeValue = parseInt(document.getElementById('airspace-altitude').value) || 1500;
            const layers = createAirspaceLayer(tmzAirspaces, routeMap, altitudeValue);

            // Only add TMZ layer if it exists
            if (layers && layers.TMZ) {
                airspaceLayerGroups.TMZ = layers.TMZ;
                layers.TMZ.addTo(routeMap);
            }
        } else {
            console.log('Removed TMZ layer');
        }
    }

    // Initialize all airspace feature groups
    function initAirspaceLayerGroups(routeMap) {
        const layers = {
            CTR_CTZ: L.featureGroup().addTo(routeMap),
            CTA_TMA: L.featureGroup().addTo(routeMap),
            ATZ: L.featureGroup().addTo(routeMap),
            MATZ: L.featureGroup().addTo(routeMap),
            TMZ: L.featureGroup().addTo(routeMap),
            TRA: L.featureGroup().addTo(routeMap),
            prohibited: L.featureGroup().addTo(routeMap),
            danger: L.featureGroup().addTo(routeMap),
            restricted: L.featureGroup().addTo(routeMap),
            parachuting: L.featureGroup().addTo(routeMap),
            gliding: L.featureGroup().addTo(routeMap),
            various: L.featureGroup().addTo(routeMap),
            // NOTAM: L.featureGroup().addTo(routeMap),
            // NOTAM_ENROUTE: L.featureGroup().addTo(routeMap),
            // Optional runway layers
            // hard_runway: L.featureGroup().addTo(routeMap),
            // soft_runway: L.featureGroup().addTo(routeMap),
            // private_runway: L.featureGroup().addTo(routeMap)
        };

        const area_types = {
            CTR_CTZ: { markertype: "polygon", fill: true, fillColor: "#FF69B4", edgeColor: "#FF69B4", opacity: 0.3, weight: 1, layer: layers.CTR_CTZ, zIndex: 300 },
            CTA_TMA: { markertype: "polygon", fill: true, fillColor: '#000000', edgeColor: "#696969", opacity: 0.1, weight: 1.5, layer: layers.CTA_TMA, zindex: 100 },
            ATZ: { markertype: "polygon", fill: true, fillColor: "#FF69B4", edgeColor: "#FF69B4", opacity: 0.15, weight: 1, layer: layers.ATZ, zIndex: 300 },
            MATZ: { markertype: "circle", fill: true, fillColor: "#8B0000", edgeColor: "#8B0000", opacity: 0.15, weight: 1, layer: layers.MATZ, zIndex: 300 },
            TMZ: { markertype: "polygon", fill: true, fillColor: "#DA70D6", edgeColor: "#DA70D6", opacity: 0.1, weight: 1.3, layer: layers.TMZ, zIndex: 10 },
            TRA: { markertype: "polygon", fill: true, fillColor: "#FA8072", edgeColor: "#FA8072", opacity: 0.3, weight: 1, layer: layers.TRA, zIndex: 100 },
            prohibited: { markertype: "polygon", fill: true, fillColor: "#8B0000", edgeColor: "#8B0000", opacity: 0.3, weight: 1, layer: layers.prohibited, zindex: 3000 },
            danger: { markertype: "polygon", fill: true, fillColor: "#8B0000", edgeColor: "#8B0000", opacity: 0.3, weight: 1, layer: layers.danger, zindex: 50 },
            restricted: { markertype: "polygon", fill: true, fillColor: "#FF9248", edgeColor: "#FF9248", opacity: 0.3, weight: 1, layer: layers.restricted, zindex: 3000 },
            gliding: { markertype: "polygon", fill: true, fillColor: "#06402B", edgeColor: "#06402B", opacity: 0.3, weight: 1, layer: layers.gliding, zindex: 1000 },
            parachuting: { markertype: "circle", fill: true, fillColor: "#0096FF", edgeColor: "#0096FF", opacity: 0.2, weight: 1, layer: layers.parachuting, zindex: 2500 },
            various: { markertype: "polygon", fill: true, fillColor: "#696969", edgeColor: "#696969", opacity: 0.3, weight: 1, layer: layers.various, zindex: 300 },
            // NOTAM: { markertype: "marker", fill: false, fillColor: "#EFC238", edgeColor: "#EFC238", opacity: 0, weight: 3, layer: layers.NOTAM },
            // NOTAM_ENROUTE: { markertype: "marker", fill: false, fillColor: "#EFC238", edgeColor: "#EFC238", opacity: 0, weight: 3, layer: layers.NOTAM_ENROUTE },
            // hard_runway: { markertype: "circle", fill: true, fillColor: "#696969", edgeColor: "#696969", opacity: 0.5, weight: 1.1, layer: layers.hard_runway },
            // soft_runway: { markertype: "circle", fill: true, fillColor: "#228B22", edgeColor: "#228B22", opacity: 0.5, weight: 1.1, layer: layers.soft_runway },
            // private_runway: { markertype: "circle", fill: true, fillColor: "#ff8c00", edgeColor: "#228B22", opacity: 0.6, weight: 1.1, layer: layers.private_runway }
        };

        return { layers, area_types };
    }

    function createAirspaceLayer(airspaces, routeMap, maxAltitude = 1500) {
        if (!airspaces) return null;
        // Initialize all layers
        const { layers, area_types } = initAirspaceLayerGroups(routeMap);
        // Keep track of currently highlighted layer
        let highlightedLayer = null;

        // Function to handle highlighting
        function highlightAirspace(layer) {
            // Reset previous highlight if exists
            if (highlightedLayer) {
                highlightedLayer.setStyle({
                    weight: highlightedLayer.originalStyle.weight,
                    opacity: highlightedLayer.originalStyle.opacity,
                    fillOpacity: highlightedLayer.originalStyle.fillOpacity,
                    color: highlightedLayer.originalStyle.color,
                    fillColor: highlightedLayer.originalStyle.fillColor
                });
            }

            // Store original style
            layer.originalStyle = {
                weight: layer.options.weight,
                opacity: layer.options.opacity,
                fillOpacity: layer.options.fillOpacity,
                color: layer.options.color,
                fillColor: layer.options.fillColor
            };

            // Apply highlight style
            layer.setStyle({
                weight: layer.originalStyle.weight * 2,
                opacity: 0.8,
                fillOpacity: 0.5,
                color: '#FFFF00',  // Yellow outline for highlighted airspace
            });

            highlightedLayer = layer;

            // Bring to front
            if (layer.bringToFront) {
                layer.bringToFront();
            }
        }


        Object.values(airspaces).forEach((airspace) => {
            if (!airspace.coordinates || airspace.coordinates.length === 0) return;

            const AL = clean_altitude(airspace.altitude_lower);
            const AH = clean_altitude(airspace.altitude_higher);
            const area_type = (airspace.area_type || "").toLowerCase();

            let key = "various";
            let flagToMap = true;
            let radius = 14900;

            // Determine type and flags
            if (area_type.includes("ctr") || area_type.includes("ctz")) { key = "CTR_CTZ"; radius = 14900; }
            else if (area_type.includes("cta") || area_type.includes("tma")) { key = "CTA_TMA"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); }
            else if (area_type.includes("atz") && !area_type.includes("military")) { key = "ATZ"; }
            else if (area_type.includes("atz") && area_type.includes("military")) { key = "MATZ"; radius = 14900; }
            else if (area_type.includes("tmz")) { key = "TMZ"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); }
            else if (area_type.includes("prohibited")) { key = "prohibited"; radius = 5000 }
            else if (area_type.includes("danger")) { key = "danger"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); radius = 2000}
            else if (area_type.includes("restricted") && !area_type.includes("notam")) { key = "restricted"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); }
            else if (area_type.includes("notam")) { key = "NOTAM"; flagToMap = false; }
            else if (area_type.includes("temporary reserved")) { key = "TRA"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); }
            else if (area_type.includes("parachuting")) { key = "parachuting"; radius = 4000; }
            else if (area_type.includes("gliding")) { key = "gliding"; radius = 6000;}
            else if (area_type.includes("laser")) { key = "laser"; flagToMap = false; radius = 2000; }
            else if (area_type.includes("gas venting")) { key = "laser"; flagToMap = false; radius = 2000; }
            else { key = "various"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); radius = 2000;}

            if (!flagToMap) return;
            // if (key === "various") return;

            const popupContent = `
                <div style="font-size: 0.9em;">
                    <b>${airspace.name}</b>
                    <div style='width:250px; padding:10px; border:1px solid lightgrey; border-radius:5px; background-color:#f9f9f9;'>
                        <b>${airspace.area_type_general}</b><br>
                        <b>Altitude:</b> ${airspace.altitude_lower}${AH ? ` to ${AH} feet` : ""}<br>
                    </div>
                </div>
            `;

            const coords = airspace.coordinates.map(c => [c[0], c[1]]);
            const areaLayer = area_types[key];
            let typeToMap = areaLayer.markertype;
            if (coords.length === 1 && key !== 'ATZ') { typeToMap = "circle"; }
            let layer;

            if (typeToMap === "marker" || typeToMap === "circle") {
                coords.forEach(latlon => {
                    if (typeToMap === "marker") {
                        layer = L.marker(latlon);
                    } else {
                        layer = L.circle(latlon, {
                            radius: radius,
                            color: areaLayer.edgeColor,
                            fillColor: areaLayer.fillColor,
                            fillOpacity: areaLayer.opacity,
                            weight: areaLayer.weight,
                            zIndex: areaLayer.zindex || 400
                        });
                    }
                    // Add click handler
                    layer.on('click', function(e) {
                        highlightAirspace(this);
                    });
                    layer.bindPopup(popupContent).addTo(areaLayer.layer);
                });
            } else if (typeToMap === "polygon") {
                layer = L.polygon(coords, {
                    color: areaLayer.edgeColor,
                    fillColor: areaLayer.fillColor,
                    fillOpacity: areaLayer.opacity,
                    weight: areaLayer.weight,
                    dashArray: areaLayer.dash || null,
                    zIndex: areaLayer.zindex || 300
                });
                // Add click handler
                layer.on('click', function(e) {
                    highlightAirspace(this);
                });
                layer.bindPopup(popupContent).addTo(areaLayer.layer);
            }
        });

        return layers; // return all layer groups separately
    }

    document.addEventListener('DOMContentLoaded', () => {
        const airspaceCheckbox = document.getElementById('airspace-toggle');
        if (airspaceCheckbox) {
            airspaceCheckbox.addEventListener('change', toggleAirspaceLayer);
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        // Airport checkbox
        const airportCheckbox = document.getElementById('aviation-toggle');
        if (airportCheckbox) {
            airportCheckbox.addEventListener('change', toggleAirportLayer);
        } else {
            console.error("Airport checkbox not found in DOM!");
        }


        // Altitude input
        const altitudeInput = document.getElementById('airspace-altitude');
        if (altitudeInput) altitudeInput.addEventListener('change', toggleAirspaceLayer);

        // Airspace checkbox
        const airspaceCheckbox = document.getElementById('airspace-toggle');
        if (airspaceCheckbox) airspaceCheckbox.checked = false;
        if (airspaceCheckbox) airspaceCheckbox.addEventListener('change', toggleAirspaceLayer);

        // TMZ CHECKBOX
        const TMZCheckbox = document.getElementById('TMZ-toggle');
        if (TMZCheckbox) TMZCheckbox.checked = false;

        // CTA CHECKBOX
        const CTACheckbox = document.getElementById('CTA_TMA-toggle');
        if (CTACheckbox) CTACheckbox.checked = false;

        // DANGER CHECKBOX
        const dangerCheckbox = document.getElementById('danger-toggle');
        if (dangerCheckbox) dangerCheckbox.checked = false;

        // PROHIBITED CHECKBOX
        const prohibitedCheckbox = document.getElementById('prohibited-toggle');
        if (prohibitedCheckbox) prohibitedCheckbox.checked = false;


        if (TMZCheckbox) {
            TMZCheckbox.checked = airspaceCheckbox.checked;
            toggleTMZLayer();
        }
        if (TMZCheckbox) {
            TMZCheckbox.addEventListener('change', toggleTMZLayer);
        }
        if (CTACheckbox) {
            CTACheckbox.checked = airspaceCheckbox.checked;
            toggleCTATMALayer();
        }
        if (CTACheckbox) CTACheckbox.addEventListener('change', toggleCTATMALayer);

        if (dangerCheckbox) {
            dangerCheckbox.checked = airspaceCheckbox.checked;
            toggleDangerLayer();
        }
        if (dangerCheckbox) dangerCheckbox.addEventListener('change', toggleDangerLayer);

        if (prohibitedCheckbox) {
            prohibitedCheckbox.checked = airspaceCheckbox.checked;
            toggleProhibitedLayer();
        }
        if (prohibitedCheckbox) prohibitedCheckbox.addEventListener('change', toggleProhibitedLayer);

        // Expose updateRoute globally
        window.updateRoute = updateRoute;
    });



</script>


<script>
    // Set datetime field in the GENERAL TAB
    document.getElementById('set_datetime_btn').addEventListener('click', () => {
      /* Update datetime field to current local time. */
      document.getElementById('DATETIME').value = nowtime(false);
    });


    // Add save button functionality
    document.getElementById('save_fields_btn')?.addEventListener('click', () => {
      if (pyscriptReady && window.save_flightplan) {
        try {
          // Get flightplan name
          const flightplanName = document.getElementById('FLIGHTPLAN')?.value;
          if (!flightplanName) { window.alert("‚ö†Ô∏è Please enter a Flightplan name before saving");
            return;
          }

          // Save flightplan data to JSON files
          window.save_flightplan();

          // Save aerodrome data to JSON files
          // window.save_aerodrome_to_json('DEPARTURE');
          // window.save_aerodrome_to_json('ARRIVAL');
          // window.save_enroute_to_json('ENROUTE1');
          // window.save_enroute_to_json('ENROUTE2');

          window.alert("‚úì Flightplan saved on local device");

        } catch (error) {
          console.error("Error saving flightplan data:", error);
        }
      }
    });

    // Add save button functionality
    document.getElementById('save_fields_btn_departure')?.addEventListener('click', () => {
      if (pyscriptReady && window.save_flightplan) {
        try {
            // Save aerodrome data to JSON files
            window.save_aerodrome_to_json('DEPARTURE');
            window.alert("‚úì Aerodrome for Departure saved on local device");
        } catch (error) {
          console.error("Error saving Aerodrome data:", error);
        }
      }
    });

    // Add save button functionality
    document.getElementById('save_fields_btn_arrival')?.addEventListener('click', () => {
      if (pyscriptReady && window.save_flightplan) {
        try {
            // Save aerodrome data to JSON files
            window.save_aerodrome_to_json('ARRIVAL');
            window.alert("‚úì Aerodrome for Arrival saved on local device");
        } catch (error) {
          console.error("Error saving Aerodrome data:", error);
        }
      }
    });

    function openAerodromeMap(fname) {
        const latlon = window.flight_plan_data[`${fname}_LATLON`];
        const icao = window.flight_plan_data[`${fname}_ICAO`]
        if (latlon && latlon[0] != null && latlon[1] != null) {
            const [lat, lon] = [parseFloat(latlon[0]), parseFloat(latlon[1])];
            const url = `https://www.google.com/maps?q=${lat},${lon}&z=14`;
            // const url = `https://metar-taf.com/airport/${icao}`;
            window.open(url, '_blank');
        } else {
            console.log(`No coordinates available for ${fname} aerodrome`);
        }
    }

</script>

<script>
    /* THIS PART CONTAINS THE METAR FUNCTIONS */

    function checkMetarAge() {
      /* Check datetime of METAR data and update UI colors.
       *
       * This function checks the datetime of displayed METAR data and updates the UI to indicate staleness.
       * If METAR data is older than 10 minutes:
       * - Sets elements' background to light red
       * Used to visually alert user that METAR data should be refreshed.
       */
        function updateColors(prefix) {
            const dateField = document.getElementById(`datetime-metar-taf-${prefix}`);
            const button = document.getElementById(`metar-widget-btn-${prefix}`);
            const metarField = document.getElementById(`metar-field-${prefix}`);
            if (!dateField?.value) return;

            // Parse the date parts
            const [datePart, timePart] = dateField.value.split(' ');
            const [day, month, year] = datePart.split('-');
            const [hours, minutes] = timePart.split(':');

            // Create date objects with the same timezone
            const metarTime = new Date();
            metarTime.setFullYear(parseInt(year), parseInt(month) - 1, parseInt(day));
            metarTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);

            const now = nowtime(utc=true);
            const diff = now - metarTime;
            const isOld = diff > 10 * 60 * 1000; // 10 minutes in milliseconds

            dateField.style.backgroundColor = isOld ? '#ffebee' : '';
            button.style.backgroundColor = isOld ? '#ffebee' : '';
            metarField.style.backgroundColor = isOld ? '#ffebee' : '';
        }

        updateColors('departure');
        updateColors('arrival');
    }

    function createMetarWidget(containerId, icao, name, uniqueSuffix) {
        /*Create and embed a METAR widget for an aerodrome.
        This function creates and embeds a METAR widget for an aerodrome.
        It displays METAR data, from METAR-TAF website by embedding it from metar-taf.com.
        It does so by creating container element and injecting widget into specified container.

        Args:
            containerId (str): ID of container element to create widget in
            icao (str): ICAO code of aerodrome
            name (str): Display name of aerodrome
            uniqueSuffix (str): Unique suffix for widget IDs
        */

        console.log(`üõ´ Creating METAR widget for ${icao}`);
        if (icao === 'unknown') {
            window.alert("Please fill in ICAO field first before loading METAR data");
            return false;
        }

        // Clear previous widget (if any)
        const container = document.getElementById(containerId);
        container.innerHTML = '';

        // Create unique ID for this widget instance
        const widgetId = `metartaf-${uniqueSuffix}`;


        // Create <a> element
        const link = document.createElement('a');
        link.href = `https://metar-taf.com/metar/${icao}`;
        link.id = widgetId;
        link.innerHTML = `METAR ${name}`;
        link.style = "font-size:16px; font-weight:400; color:#000; width:310px; height:435px; display:block";

        // Append link to container
        container.appendChild(link);

        // Create <script> element
        const script = document.createElement('script');
        script.async = true;
        script.defer = true;
        script.crossOrigin = "anonymous";
        script.src = `https://metar-taf.com/embed-js/${icao}?u=39426&qnh=hPa&rh=dp&target=${uniqueSuffix}`;

        // Append script to container
        container.appendChild(script);

        return true;
    }


    function nowtime(utc = false) {
        // Return current date/time as "DD-MM-YYYY HH:MM"
        // Coerce utc to boolean to be robust against truthy/falsy inputs
        const now = new Date();
        const pad = (n) => String(n).padStart(2, '0');

        if (utc) {
            const day = pad(now.getUTCDate());
            const month = pad(now.getUTCMonth() + 1);
            const year = now.getUTCFullYear();
            const hours = pad(now.getUTCHours());
            const minutes = pad(now.getUTCMinutes());
            return `${day}-${month}-${year} ${hours}:${minutes}`;
        } else {
            const day = pad(now.getDate());
            const month = pad(now.getMonth() + 1);
            const year = now.getFullYear();
            const hours = pad(now.getHours());
            const minutes = pad(now.getMinutes());
            return `${day}-${month}-${year} ${hours}:${minutes}`;
        }
    }


    function formatDateDMY(datetimeString) {
        // Expecting: "16/11/2025 11:18"

        // Not in expected DD/MM/YYYY format ‚Äî bail out early
        if (typeof datetimeString !== 'string' || datetimeString.indexOf('/') === -1) {
            return datetimeString;
        }
        const [datePart, timePart] = datetimeString.split(" ");
        const [day, month, year] = datePart.split("/");

        // console.log("datePart:", datePart);
        // console.log("timePart:", timePart);
        // console.log("day:", day);
        // console.log("month:", month);
        // console.log("year:", year);

        // Pad day/month if needed and validate
        const dd = day.padStart(2, "0");
        const mm = month.padStart(2, "0");
        const yyyy = year;

        return `${dd}-${mm}-${yyyy} ${timePart}`;
    }

    async function fetch_metar(icao, splitlines = true, decoded = false) {
        console.log(`Func: fetch_metar(${icao})`);

        const url = decoded
            ? `https://tgftp.nws.noaa.gov/data/observations/metar/decoded/${icao}.TXT`
            : `https://tgftp.nws.noaa.gov/data/observations/metar/stations/${icao}.TXT`;

        const proxy = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;

        try {
            const response = await fetch(proxy);
            const json = await response.json();

            if (!json.contents) return null, null;

            // Split the contents into date / metar info
            metar_data = splitlines ? json.contents.split("\n") : json.contents;

            // console.log(metar_data);
            if (metar_data) {
                metar_info = metar_data[1];
                metar_date = metar_data[0];
            }
            if (metar_date !== '') {
                metar_date = formatDateDMY(metar_date);
            }

            // console.log(metar_info);
            // console.log(metar_date);
            return [metar_info, metar_date];

        } catch (err) {
            return null, null;
        }
    }

    // async function analyzeWind(metar) {
    //   console.log(`Func: analyzeWind(${metar})`);

    //     // Regex lists for KT and MPS
    //     const regexListKT = [
    //         /\d{5}KT/,         // 33005KT
    //         /\d{5}G\d{2}KT/,   // 33010G25KT
    //         /VRB\d{2}KT/       // VRB03KT
    //     ];

    //     const regexListMPS = [
    //         /\d{5}MPS/,
    //         /\d{5}G\d{2}MPS/,
    //         /VRB\d{2}MPS/
    //     ];

    //     let search = null;

    //     // Try to find KT matches
    //     for (let i = 0; i < regexListKT.length && !search; i++) {
    //         search = metar.match(regexListKT[i]);
    //     }

    //     // If no KT match, try MPS
    //     if (!search) {
    //         for (let i = 0; i < regexListMPS.length && !search; i++) {
    //             search = metar.match(regexListMPS[i]);
    //         }
    //         if (!search) {
    //             return null; // Could not decode wind
    //         }
    //     }

    //     const windTot = search[0];

    //     // Extract direction
    //     let direction = windTot.substring(0, 3);
    //     if (direction !== "VRB") {
    //         direction = parseInt(direction, 10);
    //     }

    //     // Extract speed
    //     let speed = parseInt(windTot.substring(3, 5), 10);

    //     // Extract gust if exists
    //     let gust = null;
    //     const gustIndex = windTot.indexOf("G");
    //     if (gustIndex !== -1) {
    //         gust = parseInt(windTot.substring(gustIndex + 1, gustIndex + 3), 10);
    //     }

    //     // Extract wind variation (e.g. 180V240)
    //     let variation = null;
    //     const variationMatch = metar.match(/\d{3}V\d{3}/);

    //     if (variationMatch) {
    //         const [from, to] = variationMatch[0].split("V").map(v => parseInt(v, 10));
    //         variation = [from, to];
    //     }

    //     return {
    //         direction: direction,
    //         speed: speed,
    //         gust: gust,
    //         variation: variation
    //     };
    // }


    // Event listener for button
    // document.addEventListener('DOMContentLoaded', () => {
    //     document.getElementById('metar-widget-btn-departure')?.addEventListener('click', async () => {
    //         const name = document.getElementById('DEPARTURE_NAME').value || '';
    //         const icao = document.getElementById('DEPARTURE_ICAO').value.toUpperCase() || '';
    //         let metar_info = '';
    //         let metar_date = nowtime(utc=true)

    //         try {
    //             // Fetch METAR data from url
    //             metar_data = await fetch_metar(icao, true, false);
    //             console.log(metar_data);

    //             if (metar_data) {
    //               metar_info = metar_data[1]
    //               metar_date = metar_data[0]
    //             }
    //             // Set the original METAR datetime
    //             if (metar_date !== '') {
    //                 metar_date = formatDateDMY(metar_date)
    //                 // console.log("METAR datetime:", metar_date);
    //             }

    //         } catch (error) {
    //             console.log("Error retrieving METAR data: " + error);
    //         }

    //         // Create the widget
    //         var metarWidgetResult = createMetarWidget('departureWidgetContainer', icao, name, 'DEPARTURE');
    //         // If createMetarWidget indicates no result or an issue, return early
    //         if (!metarWidgetResult) {
    //             console.log("METAR widget not created, returning early.");
    //             return;
    //         }

    //         // Reset colors for the DEPARTURE GUI
    //         const button = document.getElementById('metar-widget-btn-departure');
    //         const dateField = document.getElementById('datetime-metar-taf-departure');
    //         button.style.backgroundColor = '';
    //         dateField.style.backgroundColor = '';
    //         // Update datetime field with current time
    //         dateField.value = metar_date;

    //     });

    //     document.getElementById('metar-widget-btn-arrival')?.addEventListener('click', async () => {
    //         const name = document.getElementById('ARRIVAL_NAME').value || '';
    //         const icao = document.getElementById('ARRIVAL_ICAO').value.toUpperCase() || '';

    //         let metar_info = '';
    //         let metar_date = nowtime(utc=true)

    //         try {
    //             // Fetch METAR data from url
    //             metar_data = await fetch_metar(icao, true, false);

    //             if (metar_data) {
    //               metar_info = metar_data[1]
    //               metar_date = metar_data[0]
    //             }
    //             // Set the original METAR datetime
    //             if (metar_date !== '') {
    //                 metar_date = formatDateDMY(metar_date)
    //                 // console.log("METAR datetime:", metar_date);
    //             }

    //         } catch (error) {
    //             console.log("Error retrieving METAR data: " + error);
    //         }

    //         // Create the widget
    //         var metarWidgetResult = createMetarWidget('arrivalWidgetContainer', icao, name, 'ARRIVAL');
    //         // If createMetarWidget indicates no result or an issue, return early
    //         if (!metarWidgetResult) {
    //             console.log("METAR widget not created, returning early.");
    //             return;
    //         }

    //         // Reset colors for the ARRIVAL GUI
    //         const button = document.getElementById('metar-widget-btn-arrival');
    //         const dateField = document.getElementById('datetime-metar-taf-arrival');
    //         button.style.backgroundColor = '';
    //         dateField.style.backgroundColor = '';
    //         // Update datetime field with current time
    //         dateField.value = metar_date;

    //     });
    // });

    /**
     * Reset METAR button UI state to enabled/active.
     * Accepts either an element reference or an element ID string.
     */

    async function setMetarButton(prefix, enable=true) {
          const button = document.getElementById('metar-widget-btn-' + prefix.toLowerCase());
          if (enable) {
            button.disabled = false;
            button.style.cursor = 'pointer';
            button.setAttribute('aria-disabled', 'false');
            button.style.opacity = '1';
            button.style.backgroundColor = '';
          } else {
            button.disabled = true;
            button.setAttribute('aria-disabled', 'true');
            button.style.opacity = '0.6';
            button.style.cursor = 'Be patient, fetching METAR data...';
            button.style.backgroundColor = '#ffebee'; // Change background color to light red
          }
    }

    async function retrieve_metar_and_widget(prefix) {
        console.log('Retrieving METAR and widget for prefix:', prefix);

        // Get the values from the input fields
        const name = document.getElementById(prefix.toUpperCase() + '_NAME').value || '';
        const icao = document.getElementById(prefix.toUpperCase() + '_ICAO').value || '';

        // Get the button element that we can fill with METAR data
        const button = document.getElementById('metar-widget-btn-' + prefix.toLowerCase());
        const dateField = document.getElementById('datetime-metar-taf-' + prefix.toLowerCase());
        const metarField = document.getElementById('metar-field-' + prefix.toLowerCase());
        const runwayField = document.getElementById(prefix + '_RUNWAY');

        // Set default values
        let metar_icao = '';
        let metar_message = '';
        let datetimeStr = nowtime(true); // UTC
        let runway_predicted = '';

        // If ICAO is empty or not provided, notify the user and return early
        if (!icao) {
            alert("Please fill in ICAO field first before loading METAR data");
            return;
        }

        // Update button: Disable
        setMetarButton(prefix, enable=false);
        metarField.value = 'Be patient, fetching METAR data...';

        // Create the widget
        const metarWidgetResult = createMetarWidget(prefix.toLowerCase() + 'WidgetContainer', icao, name, prefix.toUpperCase());

        // Fetch METAR data from URL
        try {
            closest_icao_metar_station = get_top_metar_stations(prefix, n=5)
            console.log('Closest METAR station:')
            console.log(closest_icao_metar_station[0]);

            // Fetch the METAR data for the closest station
            metar = await fetch_metar(closest_icao_metar_station[0], true, false);
            // console.log('Fetched METAR:', metar);

            // Store data
            metar_icao = metar[0];
            datetimeStr = metar[1];
        } catch (error) {
            console.log(`Error retrieving METAR data. ${prefix} has likely no weather station. Error:`, error);
            metar_message = 'No METAR weather station available for ' + icao;
            // Update button: Enable
            setMetarButton(prefix, enable=true);
        }

        if (!metarWidgetResult) {
            console.log(`METAR widget for ${prefix} not created, returning early.`);
            metarField.value = 'No METAR data available for ' + icao;
            // Update button: Enable
            setMetarButton(prefix, enable=true);
            return;
        }

        // Update GUI elements
        dateField.style.backgroundColor = '';
        metarField.style.backgroundColor = '';
        dateField.value = datetimeStr; // Update datetime field
        metarField.value = metar_icao || metar_message;
        setMetarButton(prefix, enable=true); // Update button: Enable

        // Store METAR in flight plan data
        window.flight_plan_data[`${prefix}_METAR_ICAO`] = metar_icao;

        // Update the expected runway based on wind direction and runway orientation
        if (metar_icao != '') {
            console.log(`All data is READY to compute the RUNWAY with the METAR data`);
            // Compute expected runway number based on wind direction and runway orientation
            runway_predicted = expected_runway_number(prefix, metar_icao, extra_runways=runwayField.value);
            // Change value of RUNWAY field in the the predicted runway
            runwayField.value = runway_predicted;
            // Change RUNWAY field color to yellow
            runwayField.style.backgroundColor = '#ffeb3b';
            // Store RUNWAY number in flight plan data
            window.flight_plan_data[`${prefix}_RUNWAY`] = runway_predicted;
        }

        console.log(`METAR data for [${prefix}]: [${metar_icao}] with predicted runway [${runway_predicted}]`);

    }

    // Initial check and start interval and Check every minute
    checkMetarAge();
    setInterval(checkMetarAge, 60000);

  </script>

<script>


    document.getElementById('user_usage_type').addEventListener('change', (e) => {
        if (window.settings) {
            window.settings.user_usage_type = e.target.value;
            console.log('Updated usage type:', window.settings.user_usage_type);
            window.settings.fontsizes = window.set_fontsizes({
                user_usage_type: window.settings.user_usage_type,
                user_select_cols: window.settings.user_select_cols
            });
            // Save to localStorage
            localStorage.setItem('user_usage_type', e.target.value);
        }
    });

    document.getElementById('user_select_cols').addEventListener('change', (e) => {
        if (window.settings) {
            window.settings.user_select_cols = e.target.value;
            console.log('Updated nr. columns:', window.settings.user_select_cols);
            window.settings.fontsizes = window.set_fontsizes({
                user_usage_type: window.settings.user_usage_type,
                user_select_cols: window.settings.user_select_cols
            });
            // Save to localStorage
            localStorage.setItem('user_select_cols', e.target.value);
        }
    });


</script>


<!-- Javascript functionality -->
<script>
  // List of images to cache
  const IMAGES_TO_CACHE = {
    skywalk_logo: "https://erdogant.github.io/datasets/skywalk/figs/Slide2.PNG",
    coffee_image: "https://erdogant.github.io/datasets/skywalk/figs/buy_me_a_coffee.png"
  };
  // Default ICAO image URL (not cached with others since it's used differently)
  const DEFAULT_ICAO_IMAGE = "https://erdogant.github.io/datasets/skywalk/figs/oskar-kadaksoo-f_rLDn5m2XQ-unsplash.jpg";
  window.DEFAULT_ICAO_IMAGE = DEFAULT_ICAO_IMAGE

  const CACHE_NAME = "skywalk-cache-v1";

  // Function to cache and set image source
  async function cacheAndSetImage(url, imgElementId) {
    const cache = await caches.open(CACHE_NAME);

    // Try loading from cache
    let response = await cache.match(url);
    if (!response) {
      console.log(`Image not cached yet. Downloading: ${url}`);
      response = await fetch(url);
      await cache.put(url, response.clone());
    } else {
      console.log(`Loaded from cache: ${url}`);
    }

    const blob = await response.blob();
    const objectURL = URL.createObjectURL(blob);
    const imgElement = document.getElementById(imgElementId);
    if (imgElement) {
      imgElement.src = objectURL;
    } else {
      console.warn(`Image element not found: ${imgElementId}`);
    }
  }

  // Initialize caching on page load
  document.addEventListener("DOMContentLoaded", () => {
    for (const [elementId, url] of Object.entries(IMAGES_TO_CACHE)) {
      cacheAndSetImage(url, elementId);
    }

    // Load default departure image on page load
    cacheAndSetImage(DEFAULT_ICAO_IMAGE, 'DEPARTURE_image_cache');
    cacheAndSetImage(DEFAULT_ICAO_IMAGE, 'ARRIVAL_image_cache');
  });
</script>


<!--============================================-->
<!-- PyScript configuration -->
<!--============================================-->

<py-config>
  packages = ["pandas", "numpy", "jinja2", "requests"]
</py-config>

<script>
// Add event listeners for FIC spinners
document.getElementById('fic_spinner')?.addEventListener('change', function() {
    if (this.value && window.load_enroute_fic) {
        window.load_enroute_fic('fic_spinner');
    }
});

document.getElementById('fic_spinner2')?.addEventListener('change', function() {
    if (this.value && window.load_enroute_fic) {
        window.load_enroute_fic('fic_spinner2');
    }
});
</script>


<!-- PyScript for flightplan functionality -->
  <script type="py">
    # Standard library imports
    import json
    import os
    import sys
    import re
    import pathlib
    import tempfile
    import base64
    from datetime import datetime
    from io import BytesIO
    from urllib.parse import urlparse
    import urllib.parse
    import webbrowser
    import math

    # Third party imports
    import pandas as pd
    import numpy as np
    import zipfile
    import requests
    import ast
    import asyncio
    from jinja2 import Environment, DictLoader
    # from math import radians, cos

    # JavaScript/browser imports
    import js
    from js import Blob, URL, window
    from pyodide.http import pyfetch
    from pyodide.ffi import create_proxy

    import logging
    logger = logging.getLogger('SKYWALK')

    async def load_cached_zip(cache_key, url=None):
        """Load data from cache or download and cache it
        Args:
            cache_key: Key to use for caching
            url: URL to fetch data from if not in cache
        Returns:
            bytes: The loaded data
        """
        if is_cached(cache_key):
            print(f"üì¶ Using cached data for: {cache_key}")
            cached_data = load_from_cache(cache_key)
            return cached_data

        if url:
            print(f"‚¨áÔ∏è Downloading from: {url}")
            data = await fetch_zip(url)
            if data:
                save_to_cache(cache_key, data, encode_base64=True)
                return data
        return None


    def get_default_settings():
        """Get default settings"""
        print('----> get_default_settings()')
        data = {
            'DEPARTURE_COUNTRY': '',
            'DEPARTURE_ICAO': '',
            'DEPARTURE_ICAO_CITY': '',
            'ARRIVAL_COUNTRY': '',
            'ARRIVAL_ICAO': '',
            'ARRIVAL_ICAO_CITY': '',
            'MAX_HEADWIND_LIMIT': 25,
            'MAX_CROSSWIND_LIMIT': 15,
            'user_usage_type': 'print',
            'user_select_cols': '2',
            'fontsizes': set_fontsizes(type('Params', (), {'user_usage_type': 'view', 'user_select_cols': '1'})),

            'METAR_stations': r'https://erdogant.github.io/datasets/skywalk/nsd_cccc.zip',

            'link_coffee': "https://www.buymeacoffee.com/erdogant",
            'link_skywalk': 'http://erdogant.github.io/skywalk-docs/',

            'FIG_DIR': r'https://erdogant.github.io/datasets/skywalk/figs/',
            'logo_coffee': r'https://erdogant.github.io/datasets/skywalk/figs/buy_me_a_coffee.png',
            'logo_skywalk': r'https://erdogant.github.io/datasets/skywalk/figs/Slide3.PNG',

            'img_default_icao': r'https://erdogant.github.io/datasets/skywalk/figs/oskar-kadaksoo-f_rLDn5m2XQ-unsplash.jpg',
            'img_default_wind_envelope': r'https://erdogant.github.io/datasets/skywalk/figs/windsock_mark-konig-OsYYPaPgIjw-unsplash.jpg',
            'url_default_wind_envelope': 'https://erdogant.github.io/skywalk-docs/pages/html/Departure_Arrival.html#cloud-plot',
            'img_default_cloud_plot': r'https://erdogant.github.io/datasets/skywalk/figs/dylan-mcleod-vY7GkgvTj-k-unsplash.jpg',
            'url_default_cloud_plot': 'https://erdogant.github.io/skywalk-docs/pages/html/Departure_Arrival.html#cloud-plot',

            'key_aerodromes': "GpZzcnXiLleytOr5Y7WC@",
            'url_aerodromes': 'https://erdogant.github.io/datasets/skywalk/aerodromes/',
            'url_aerodromes_images': 'https://erdogant.github.io/datasets/skywalk/aerodromes_images/',
            'url_airspaces': 'https://erdogant.github.io/datasets/skywalk/airspaces/',

            'html_templates': 'https://erdogant.github.io/datasets/skywalk/html_templates/',
        }
        return data

    def get_default_data():
        """Get default flightplan data structure - copied from utils_skywalk.py"""
        print('----> get_default_data()')
        data = {
            # General/Flightplan
            'FLIGHTPLAN': '',           # Name of the flightplan
            'DATETIME': datetime.now().strftime('%d-%m-%Y %H:%M'),
            'CALLSIGN': '',             # Aircraft callsign
            'CALLSIGN_SHORT': '',       # Short callsign (auto-generated)
            'AIRCRAFT_TYPE': '',        # Aircraft type/model
            'FLIGHT_RULES': 'VFR',      # VFR/IFR
            'POB': '',                  # Persons on board

            # Departure
            'DEPARTURE_ICAO': '',               # ICAO code
            'DEPARTURE_ICAO_CITY': '',          # ICAO code with City
            'DEPARTURE_NAME': '',               # Aerodrome name
            'DEPARTURE_POSITION': '',           # Position at apron
            'DEPARTURE_RUNWAY': '',             # The user selected Runway
            'DEPARTURE_RUNWAYS': '',            # All available Runways
            'DEPARTURE_RUNWAY_LENGTH': '',      # The length of the Runway
            'DEPARTURE_RUNWAY_SURFACE': '',     # The surface of the Runway
            'DEPARTURE_ELEVATION': '',          # The Runway ELEVATION
            'DEPARTURE_ROUTE_NAME': '',         # Departure route name
            'DEPARTURE_ROUTE_ALTITUDE': '',     # Departure route altitude
            'DEPARTURE_CIRCUIT_ALTITUDE': '',   # Departure circuit altitude
            'DEPARTURE_CTR': False,             # CTR checkbox state
            'DEPARTURE_COUNTRY': '',            # Country selection
            'DEPARTURE_IMAGE': None,            # Image of the departure
            'DEPARTURE_URL_WEBSITE': None,      # Website of the Aerodrome
            'DEPARTURE_URL_WIKIPEDIA': None,    # Website of the Aerodrome
            'DEPARTURE_LATLON': [None, None],   # Latlon
            'DEPARTURE_METAR_ICAO': '',         # METAR for the specific ICAO
            'DEPARTURE_METAR': '',              # METAR
            'DEPARTURE_WIND_ENVELOPE': '',      # WIND ENVELOPE
            'DEPARTURE_CLOUD': '',              # CLOUD DATA
            'DEPARTURE_TIMEZONE': '',           # Timezone

            # Departure ATC
            'DEPARTURE_ATC_TOWER': '',            # Tower/Radio frequency
            'DEPARTURE_ATC_ATIS_FREQ': '',        # ATIS frequency
            'DEPARTURE_ATC_GROUND': '',           # Delivery/Ground frequency
            'DEPARTURE_ATC_APPROACH': '',         # Approach
            'DEPARTURE_ATC_TELEPHONE': '',        # Telephone Tower

            # Arrival
            'ARRIVAL_ICAO': '',                   # ICAO code
            'ARRIVAL_ICAO_CITY': '',              # ICAO code with City
            'ARRIVAL_NAME': '',                   # Aerodrome name
            'ARRIVAL_POSITION': '',               # Position at apron
            'ARRIVAL_RUNWAY': '',                 # The user selected Runway
            'ARRIVAL_RUNWAYS': '',                # All available Runways
            'ARRIVAL_RUNWAY_LENGTH': '',          # The length of the Runway
            'ARRIVAL_RUNWAY_SURFACE': '',         # The surface of the Runway
            'ARRIVAL_ELEVATION': '',              # The Runway ELEVATION
            'ARRIVAL_ROUTE_NAME': '',             # Arrival route name
            'ARRIVAL_ROUTE_ALTITUDE': '',         # Arrival route altitude
            'ARRIVAL_CIRCUIT_ALTITUDE': '',       # Arrival circuit altitude
            'ARRIVAL_CTR': False,                 # CTR checkbox state
            'ARRIVAL_COUNTRY': '',                # Country selection
            'ARRIVAL_IMAGE': None,                # Image of the departure
            'ARRIVAL_URL_WEBSITE': None,          # Website of the Aerodrome
            'ARRIVAL_URL_WIKIPEDIA': None,        # Website of the Aerodrome
            'ARRIVAL_LATLON': [None, None],       # Latlon
            'ARRIVAL_METAR_ICAO': '',             # METAR
            'ARRIVAL_METAR': '',                  # METAR
            'ARRIVAL_WIND_ENVELOPE': '',          # WIND ENVELOPE
            'ARRIVAL_CLOUD': '',                  # CLOUD DATA
            'ARRIVAL_TIMEZONE': '',               # Timezone

            # Arrival ATC
            'ARRIVAL_ATC_TOWER': '',        # Tower/Radio frequency
            'ARRIVAL_ATC_ATIS_FREQ': '',    # ATIS frequency
            'ARRIVAL_ATC_GROUND': '',       # Delivery/Ground frequency
            'ARRIVAL_ATC_APPROACH': '',     # Approach
            'ARRIVAL_ATC_TELEPHONE': '',    # Telephone Tower

            # Enroute
            'FIC_NAME': '',             # FIC name
            'FIC_FREQUENCY': '',        # FIC frequency
            'OVERHEAD': '',             # Overhead point
            'SQUAWK': '',               # Squawk code
            # Enroute (second FIC/overhead/squawk)
            'FIC_NAME2': '',            # Second FIC name
            'FIC_FREQUENCY2': '',       # Second FIC frequency
            'OVERHEAD2': '',            # Second overhead point
            'SQUAWK2': '',             # Second squawk code

            # NOTAM data
            'NOTAM': {'data': {}},      # NOTAM data
        }
        return data

    # Cache Helpers
    def clear_cache():
        """Clear all cached data from localStorage"""
        try:
            # Clears everything stored in localStorage
            js.localStorage.clear()

            # If you also use sessionStorage:
            js.sessionStorage.clear()
            print("üßπ Cache cleared successfully")
            return True
        except Exception as e:
            print(f"‚ùå Error clearing cache: {e}")
            return False

    def is_cached(cache_key):
        try:
            cached = js.localStorage.getItem(cache_key)
            # Check if value exists and is truthy (not null/undefined)
            return bool(cached)
        except:
            return False

    def save_to_cache(cache_key, data, encode_base64=False):
        """Save data to localStorage with optional base64 encoding"""
        try:
            if encode_base64:
                data = base64.b64encode(data).decode('utf-8')
            js.localStorage.setItem(cache_key, data)
            print(f"üíæ Cached {cache_key}: {len(data)} bytes")
            return True
        except Exception as e:
            print(f"‚ùå Error saving to cache: {e}")
            return False


    def load_from_cache(cache_key):
        try:
            cached_data = js.localStorage.getItem(cache_key)
            if cached_data:
                # Decode base64 string to bytes
                data = base64.b64decode(cached_data)
                print(f"üì¶ Loaded {len(data)} bytes from cache")
                return data
            print("‚ö†Ô∏è Cache returned null, downloading...")
            return None
        except Exception as e:
            print(f"‚ö†Ô∏è Error decoding cached data: {e}")
            return None

    # Fetch ZIP from remote and save to cache
    async def fetch_zip(url):
        filepath = urlparse(url).path
        zipname = os.path.splitext(os.path.basename(filepath))[0]
        print(f"üì• Fetching: {url}")
        print(f"üì• Fetching: {zipname}")

        response = await pyfetch(url)
        if response.ok:
            # Get bytes directly as Python bytes object
            zip_bytes = await response.bytes()
            save_to_cache(zipname, zip_bytes, encode_base64=True)
            return zip_bytes
        else:
            print(f"‚ùå Failed to download {url} - Status: {response.status}")
            js.document.getElementById('loading-spinner').style.display = 'none'
            return None

    # Extract CSV inside the ZIP
    def extract_csv_from_zip(zip_bytes, password=None):
        print('----> extract_csv_from_zip()')
        try:
            print(f"üîì Extracting ZIP file ({len(zip_bytes)} bytes)...")
            with zipfile.ZipFile(BytesIO(zip_bytes)) as z:
                files = z.namelist()
                print(f"üìÇ Files in ZIP: {files}")
                name = files[0]  # First file in ZIP
                print(f"üìÑ Reading: {name}")
                if password is None:
                    with z.open(name) as f:
                        df = pd.read_csv(f, sep=';')
                else:
                    with z.open(name, pwd=password.encode()) as f:
                        df = pd.read_csv(f, sep=';')
                print(f"‚úÖ CSV parsed: {len(df)} rows, {len(df.columns)} columns")
            return df
        except zipfile.BadZipFile as e:
            print(f"‚ùå BadZipFile error: {e}")
            print(f"First 100 bytes: {zip_bytes[:100]}")
            raise
        except Exception as e:
            print(f"‚ùå Error extracting CSV: {type(e).__name__}: {e}")
            js.document.getElementById('loading-spinner').style.display = 'none'
            raise



    # Main loader: called from JS
    async def import_country_selected(fname, country):
        print('----> import_country_selected()')
        print(f"üåç Loading {fname} aerodrome data for: {country}")
        zip_bytes = None

        try:
            url = js.window.settings['url_aerodromes'] + country + ".zip"
            zip_bytes = await load_cached_zip(f"aerodrome_{country}", url)

            if zip_bytes:
                PASSWORD = js.window.settings['key_aerodromes']
                df = extract_csv_from_zip(zip_bytes, PASSWORD)
                js.console.log(f"‚úÖ Aerodromes loaded for {country}: {len(df)} rows.")
                print(f"‚úÖ Successfully loaded {len(df)} aerodromes for {country}")

                # For now, just show the first few entries
                # print(df.head().to_string())
                # print(f"Available columns: {df.columns.tolist()}")

                try:
                    # Store data in global variable
                    if fname == 'DEPARTURE':
                        js.window.AERODROME_DEPARTURE_DATA = df.to_dict('records')
                    elif fname == 'ARRIVAL':
                        js.window.AERODROME_ARRIVAL_DATA = df.to_dict('records')

                    # Combine departure and arrival data when possible and store in global variable
                    concat_country_aerodromes()

                except AttributeError as e:
                    error_msg = f"Error processing aerodrome data: {str(e)}"
                    print(f"‚ùå {error_msg}")
                    js.window.alert(error_msg)
                    return

                # Populate the dropdown with aerodrome data
                if 'city_icao' in df.columns:
                    icao_codes = df['city_icao'].dropna().unique().tolist()
                    print(f"üìç Found {len(icao_codes)} unique ICAO cities")

                    # Clear and populate the dropdown
                    select = js.document.getElementById(f'{fname}_ICAO_CITY')
                    if select:
                        # Clear existing options except the first placeholder
                        select.innerHTML = '<option value="">ICAO City</option>'

                        # Add each ICAO city as an option
                        for icao in sorted(icao_codes):
                            option = js.document.createElement('option')
                            option.value = icao
                            option.textContent = icao
                            select.appendChild(option)

                        print(f"‚úÖ Populated {fname}_ICAO_CITY dropdown with {len(icao_codes)} cities")
                    else:
                        print(f"‚ö†Ô∏è {fname}_ICAO_CITY dropdown not found")
                else:
                    print(f"‚ö†Ô∏è '{fname}_city_icao' column not found in dataframe")
                    print(f"Available columns: {df.columns.tolist()}")
        except Exception as e:
            error_msg = f"No airspace data available for {country}: {str(e)}"
            print(f"‚ùå {error_msg}")
            js.window.alert(error_msg)
            js.document.getElementById('loading-spinner').style.display = 'none'
            return

        # Concat airspaces
        concat_airspaces(country)

        # Hide loading spinner when done
        js.document.getElementById('loading-spinner').style.display = 'none'


    def get_top_metar_stations(fname, n=5, return_df=False):
        # Retrieve all metar stations for the country
        print(f'>func: get_top_metar_stations({fname}, {n})')

        icao = js.window.flight_plan_data[f'{fname}_ICAO']
        lat = js.window.flight_plan_data[f'{fname}_LATLON'][0]
        lon = js.window.flight_plan_data[f'{fname}_LATLON'][1]

        print(f'icao: {icao}, lat: {lat}, lon: {lon}')

        # Import METAR data
        df_stations = get_metar_stations(todf=True)
        # Default is all metar stations
        closest_metar_stations = df_stations['icao'].values

        # If icao is in df_stations, then return
        if icao in df_stations['icao'].values:
            print(f'Found {icao} in METAR stations')
            return [icao]

        # Return all or selection
        if (lat is not None) and (lon is not None):
            # Compute haversine distance
            df_stations['distance_to_target'] = haversine_distances(lat, lon, df_stations['lat'].values, df_stations['lon'].values)
            # df_stations['distance_to_target'] = df_stations.apply(lambda row: compute.haversine(row['lat'], row['lon'], lat, lon), axis=1)
            # Sort on closest METAR stations
            df_stations.sort_values(by='distance_to_target', inplace=True)
            # Make a combined name
            closest_metar_stations = df_stations['icao'].values
            # print(df_stations)
        else:
            df_stations['distance_to_target'] = None

        # Filter on top distance metar stations
        if n is not None and n > 0:
            closest_metar_stations = closest_metar_stations[0:int(n)]

        print(df_stations)
        print(closest_metar_stations)

        # Return
        if return_df:
            return df_stations
        else:
            return closest_metar_stations


    def get_metar_stations(fname=None, todf=True):
        if fname == 'DEPARTURE':
            AERODROME_DATA = window.AERODROME_DEPARTURE_DATA.copy()
        elif fname == 'ARRIVAL':
            AERODROME_DATA = window.AERODROME_ARRIVAL_DATA.copy()
        else:
            AERODROME_DATA = window.AERODROME_DATA.copy()

        if todf:
            icao_with_metar = [
                {"icao": item["icao"], "lat": item["lat"], "lon": item["lon"], "country": item["country"]}
                for item in AERODROME_DATA
                if item.get("metar_station") is True
            ]
            icao_with_metar = pd.DataFrame(icao_with_metar)
        else:
            icao_with_metar = {
                item["icao"]: {"lat": item["lat"], "lon": item["lon"], "country": item["country"]}
                for item in AERODROME_DATA
                if item.get("metar_station") is True
            }

        # Return
        return icao_with_metar


    def haversine_distances(lat1, lon1, lats, lons):
        distances = np.array(list(map(lambda x, y: haversine(lat1, lon1, x, y), lats, lons)))
        return distances


    def haversine(lat1, lon1, lat2, lon2):
        """
        Calculate the Haversine distance between two sets of latitude and longitude coordinates.

        Parameters
        ----------
        lat1 : float
            Latitude of the first point in degrees.
        lon1 : float
            Longitude of the first point in degrees.
        lat2 : float
            Latitude of the second point in degrees.
        lon2 : float
            Longitude of the second point in degrees.

        Returns
        -------
        float
            The Haversine distance between the two points in kilometers.

        Example
        -------
        >>> haversine(37.7749, -122.4194, 34.0522, -118.2437)
        >>> 616.7752155325443

        """
        # if (lat1 is None) or (lon1 is None) or (lat2 is None) or (lon2 is None):
        #     print(lat1)
        #     return None

        R = 6371  # Radius of the Earth in kilometers

        # Convert latitude and longitude from degrees to radians
        lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])

        # Haversine formula
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        a = math.sin(dlat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

        # Distance in kilometers
        distance = R * c
        return distance


    def concat_airspaces(country):
        # Import airspace polygon data
        new_airspaces = import_airspaces(country)

        if new_airspaces:
            # Create country-specific prefixed keys
            prefixed_airspaces = {}
            for key, value in new_airspaces.items():
                new_key = f"{country}_{key}"
                value['country_id'] = country  # Add country identifier to the airspace data
                prefixed_airspaces[new_key] = value

            if hasattr(js.window, 'airspaces') and js.window.airspaces:
                # Append new country data to existing airspaces
                js.window.airspaces.update(prefixed_airspaces)
            else:
                # Initialize with first country
                js.window.airspaces = prefixed_airspaces
        # print(js.window.airspaces.keys())


    def concat_country_aerodromes():
        # Combine departure and arrival data when possible and store in global variable

        # Check whether data is available
        has_departure = hasattr(window, "AERODROME_DEPARTURE_DATA")
        has_arrival   = hasattr(window, "AERODROME_ARRIVAL_DATA")

        # Store only what is available
        if has_departure and not has_arrival:
            js.window.AERODROME_DATA = js.window.AERODROME_DEPARTURE_DATA
        elif not has_departure and has_arrival:
            js.window.AERODROME_DATA = js.window.AERODROME_ARRIVAL_DATA
        elif has_departure and has_arrival:
            dep = window.AERODROME_DEPARTURE_DATA
            arr = window.AERODROME_ARRIVAL_DATA

            # handle both lists and dicts automatically
            if isinstance(dep, list) and isinstance(arr, list):
                window.AERODROME_DATA = dep + arr
                print("OPTION 1")
            elif isinstance(dep, dict) and isinstance(arr, dict):
                window.AERODROME_DATA = {**dep, **arr}
                print("OPTION 2")
            else:
                # fallback: convert to list if mixed
                window.AERODROME_DATA = list(dep) + list(arr)
                print("OPTION 3")
        else:
            window.AERODROME_DATA = {}


    async def populate_aerodrome_fields_from_icao(fname, city_icao):
        """Populate aerodrome fields when ICAO city is selected."""
        print('----> populate_aerodrome_fields_from_icao()')
        print(f"üîç Searching for data: {city_icao}")

        # Get the stored dataframe
        if not hasattr(js.window, f'AERODROME_{fname}_DATA'):
            print(f"‚ö†Ô∏è No aerodrome data available:'AERODROME_{fname}_DATA'")
            return

        # Get data
        if fname == 'DEPARTURE':
            df = js.window.AERODROME_DEPARTURE_DATA
        elif fname == 'ARRIVAL':
            df = js.window.AERODROME_ARRIVAL_DATA

        # Get data for specific ICAO
        row_dict = get_icao_data(df, city_icao)

        if not row_dict:
            print(f"‚ö†Ô∏è No data found for {city_icao}")
            return

        # Get runway data
        rwy_ids, rwy_list = retrieve_runways(row_dict)
        # print(rwy_ids)

        # Store data
        CTR_BOOL = row_dict['AERODROME_CTR']
        FREQ_TOWER_RADIO = row_dict['freqs.TOWER'] if CTR_BOOL else row_dict['freqs.RADIO']
        js.window.flight_plan_data[f"{fname}_ICAO"] = row_dict['icao']
        js.window.flight_plan_data[f"{fname}_ICAO_CITY"] = city_icao
        js.window.flight_plan_data[f"{fname}_RUNWAYS"] = rwy_list
        js.window.flight_plan_data[f"{fname}_RUNWAY"] = clean_string(rwy_ids)
        js.window.flight_plan_data[f"{fname}_NAME"] = row_dict['name']
        js.window.flight_plan_data[f"{fname}_ELEVATION"] = str(row_dict['elevation_aerodrome'])
        js.window.flight_plan_data[f"{fname}_METAR"] = ''
        js.window.flight_plan_data[f"{fname}_METAR_ICAO"] = ''
        js.window.flight_plan_data[f"{fname}_WIND_ENVELOPE"] = ''

        ctr_value = 'CTR' if CTR_BOOL else ''
        js.window.flight_plan_data[f"{fname}_CTR"] = ctr_value
        js.document.getElementById(f'{fname}_CTR').value = ctr_value
        js.document.getElementById(f'{fname}_CTR').dispatchEvent(js.Event.new('change'))

        js.window.flight_plan_data[f"{fname}_COUNTRY"] = row_dict['country']
        js.window.flight_plan_data[f"{fname}_IMAGE"] = row_dict.get('url.wikipedia.aerodrome.image', None)
        js.window.flight_plan_data[f"{fname}_URL_WEBSITE"] = row_dict.get('url.website', '')
        js.window.flight_plan_data[f"{fname}_URL_WIKIPEDIA"] = row_dict.get('url.wikipedia', '')
        js.window.flight_plan_data[f"{fname}_LATLON"] = [row_dict.get('lat', None), row_dict.get('lon', None)]

        # Update route map if both departure and arrival coordinates are available
        # if hasattr(js.window, 'updateRouteLine'): js.window.updateRouteLine()
        js.window.flight_plan_data[f"{fname}_TIMEZONE"] = row_dict.get('tz', None)

        if fname == 'DEPARTURE':
            # Handle FREQ_TOWER_RADIO
            js.window.flight_plan_data["DEPARTURE_ATC_TOWER"] = clean_string(FREQ_TOWER_RADIO)

            # MAPPING OF THE FREQUENCIES
            field_mapping = {
              f"{fname}_ATC_ATIS_FREQ": 'freqs.ATIS',
              f"{fname}_ATC_GROUND": 'freqs.DELIVERY/GROUND',
              f"{fname}_ATC_APPROACH": 'freqs.APPROACH',
              f"{fname}_ATC_TELEPHONE": 'freqs.TELEPHONE',
              'FIC_NAME': 'freqs.FIC_NAME',
              'FIC_FREQUENCY': 'freqs.FIC_FREQUENCY',
              'FIC_NAME2': 'freqs.FIC_NAME_2',
              'FIC_FREQUENCY2': 'freqs.FIC_FREQUENCY_2',
            }

            # FILL THE FREQUENCIES
            for key, colname in field_mapping.items():
              freq_raw = row_dict[colname]
              freq_clean = clean_string(freq_raw)
              js.window.flight_plan_data[key] = freq_clean
              print(f"  {key}: {js.window.flight_plan_data[key]}")

        # Update GUI fields for aerodrome
        update_aerodrome_gui_fields(fname)
        # Update images for aerodrome
        await update_aerodrome_image(fname)
        # Remove METAR widget
        remove_metar_widget(fname)

    def clean_string(value):
        # Convert to string and strip brackets/quotes
        freq_str = str(value).strip().strip('[]').replace("'", "").replace('"', '')
        # Split, clean, and filter empty items
        parts = [f.strip() for f in freq_str.split(',') if f.strip()]
        # Return
        return ', '.join(parts)

    def create_callsign_short(CALLSIGN):
        # Create short callsign automatically
        CALLSIGN_SHORT = ''
        if CALLSIGN is not None and CALLSIGN != '':
            CALLSIGN_SHORT = CALLSIGN[0] + CALLSIGN[-2:]
        return CALLSIGN_SHORT

    def TEXT_INFORMATION_RECEIVED():
        """Return text confirming information received"""
        return '<br><br>INFORMATION <strong class="pilot_text"> [ .   .   .   .   .   . ]</strong> RECEIVED,'

    async def clear_general_fields():
        """Clear all GENERAL GUI fields and flight_plan_data"""
        print("üßπ Clearing all GENERAL fields...")

        # List of all departure fields to clear
        field_ids = [
          'FLIGHTPLAN',
          'DATETIME',
          'CALLSIGN',
          'AIRCRAFT_TYPE',
          'FLIGHT_RULES',
          'POB',
        ]

        # Clear GUI fields
        for field_id in field_ids:
            element = js.document.getElementById(field_id)
            if element:
                if field_id == 'FLIGHT_RULES':
                    element.value = 'VFR'
                else:
                    element.value = ''

        # Clear flight_plan_data
        keys = field_ids + ['CALLSIGN_SHORT']
        for key in keys:
            if key == 'FLIGHT_RULES':
                js.window.flight_plan_data[key] = 'VFR'
            else:
                js.window.flight_plan_data[key] = ''


    def update_general_gui_fields(flight_plan_dict):
        """Update GENERAL GUI fields from js.window.flight_plan_data"""
        print('----> update_general_gui_fields()')
        print("üîÑ Updating GENERAL GUI fields...")

        fields = ['FLIGHTPLAN', 'CALLSIGN', 'AIRCRAFT_TYPE', 'POB', 'FLIGHT_RULES', 'DATETIME']
        for field in fields:
            if flight_plan_dict.get(field):
                js.document.getElementById(field).value = flight_plan_dict[field]


    def update_enroute_gui_fields(enroute_dict):
        """Update ENROUTE GUI fields from js.window.flight_plan_data"""
        print('----> update_enroute_gui_fields()')
        print("üîÑ Updating ENROUTE GUI fields...")

        # Get all fields that need updating
        fields = ['FIC_NAME', 'FIC_FREQUENCY', 'OVERHEAD', 'SQUAWK', 'FIC_NAME2', 'FIC_FREQUENCY2', 'OVERHEAD2', 'SQUAWK2']

        # Update each GUI field from flight_plan_data
        for field in fields:
            element = js.document.getElementById(field)
            if element:
                value = js.window.flight_plan_data.get(field, '')
                element.value = value if value not in ('', None, 'None', 'nan') else ''

        for field in fields:
            if enroute_dict.get(field):
                js.document.getElementById(field).value = enroute_dict[field]



    def update_aerodrome_gui_fields(fname):
        """Update GENERAL GUI fields from js.window.flight_plan_data"""
        print('----> update_aerodrome_gui_fields()')
        print(f"üîÑ Updating {fname} GUI fields...")

        # List of field IDs to update
        field_ids = [
            f'{fname}_COUNTRY',
            f'{fname}_ICAO_CITY',
            f'{fname}_NAME',
            f'{fname}_ICAO',
            f'{fname}_POSITION',
            f'{fname}_RUNWAY',
            f'{fname}_ELEVATION',
            f'{fname}_ROUTE_NAME',
            f'{fname}_ROUTE_ALTITUDE',
            f'{fname}_CIRCUIT_ALTITUDE',
            f'{fname}_CTR',
            f'{fname}_ATC_TOWER',
            f'{fname}_ATC_APPROACH',
            f'{fname}_ATC_ATIS_FREQ',
            f'{fname}_ATC_GROUND',
            f'{fname}_ATC_TELEPHONE',
        ]

        # Only update these fields based on DEPARTURE
        if fname == 'DEPARTURE':
            field_ids = field_ids + [
                'FIC_NAME',
                'FIC_FREQUENCY',
                'SQUAWK',
                'OVERHEAD',
                'FIC_NAME2',
                'FIC_FREQUENCY2',
                'SQUAWK2',
                'OVERHEAD2',
            ]

        updated_count = 0
        for field_id in field_ids:
            # Get the value from flight_plan_data
            value = js.window.flight_plan_data.get(field_id)

            # Get the HTML element
            element = js.document.getElementById(field_id)

            if element:
                # Convert value to string and handle special cases
                if value is not None and value != '' and str(value) != 'nan' and str(value) != 'None':
                    # Handle boolean for CTR
                    if field_id == f'{fname}_CTR':
                        if value or str(value).lower() == 'true':
                            element.value = 'CTR'
                        else:
                            element.value = ''
                    else:
                        element.value = str(value)

                    updated_count += 1
                    print(f"  ‚úì Updated {field_id}: {element.value}")
                else:
                    # Clear the field if no value
                    element.value = ''
            else:
                print(f"  ‚ö†Ô∏è Element not found: {field_id}")

        print(f"‚úÖ Updated {updated_count} GUI fields")


    async def clear_enroute_fields():
        """Clear all ENROUTE GUI fields and flight_plan_data"""
        print('----> clear_enroute_fields()')
        print("üßπ Clearing all ENROUTE fields...")

        # Clear GUI fields
        js.document.getElementById('FIC_NAME').value = ''
        js.document.getElementById('FIC_FREQUENCY').value = ''
        js.document.getElementById('OVERHEAD').value = ''
        js.document.getElementById('SQUAWK').value = ''
        js.document.getElementById('FIC_NAME2').value = ''
        js.document.getElementById('FIC_FREQUENCY2').value = ''
        js.document.getElementById('OVERHEAD2').value = ''
        js.document.getElementById('SQUAWK2').value = ''

        # Clear enroute fields
        enroute_keys = [
            'FIC_NAME', 'FIC_FREQUENCY', 'FIC_NAME2', 'FIC_FREQUENCY2',
            'OVERHEAD', 'OVERHEAD2', 'SQUAWK', 'SQUAWK2',
        ]

        for key in enroute_keys:
            js.window.flight_plan_data[key] = ''


    def remove_metar_widget(fname):
        """Remove METAR widget for the specified aerodrome if it exists"""
        print(f"---> remove_metar_widget({fname})")

        # Clear the METAR container
        widget_id = f"{fname.lower()}WidgetContainer"
        widget = js.document.getElementById(widget_id)

        # Clear the container instead of removing it
        if widget:
            widget.innerHTML = ''
            print(f"üßπ Cleared METAR widget for {fname}")

        # Clear the datetime field
        datetime_field = js.document.getElementById(f'datetime-metar-taf-{fname.lower()}')
        datetime_field.value = ''
        datetime_field.style.backgroundColor = '';
        # Clear button to normal
        button = js.document.getElementById(f'metar-widget-btn-{fname.lower()}')
        button.style.backgroundColor = '';
        # Clear the METAR field
        metarField = js.document.getElementById(f'metar-field-{fname.lower()}')
        metarField.value = ''
        metarField.style.backgroundColor = '';

        # Clear datetime
        js.window.flight_plan_data[f'{fname.upper()}_METAR'] = ''
        js.window.flight_plan_data[f'{fname.upper()}_METAR_ICAO'] = ''
        print(f"üßπ Cleared METAR datetime for {fname}")



    async def clear_aerodrome_fields(fname):
        """Clear all aerodrome GUI fields and flight_plan_data"""
        print(f"üßπ Clearing all {fname} fields...")

        # List of all departure/arrival fields to clear - ensure critical fields are included
        field_ids = [
            f'{fname}_COUNTRY',
            f'{fname}_ICAO_CITY',
            f'{fname}_CTR',
            f'{fname}_NAME',
            f'{fname}_ICAO',
            f'{fname}_POSITION',
            f'{fname}_RUNWAY',
            f'{fname}_ELEVATION',
            f'{fname}_ROUTE_NAME',
            f'{fname}_ROUTE_ALTITUDE',
            f'{fname}_CIRCUIT_ALTITUDE',
            f'{fname}_ATC_TOWER',
            f'{fname}_ATC_APPROACH',
            f'{fname}_ATC_ATIS_FREQ',
            f'{fname}_ATC_GROUND',
            f'{fname}_ATC_TELEPHONE',
            f'datetime-metar-taf-{fname}',
            f'metar-field-{fname}',
        ]

        print(f"Clearing fields for {fname}:")

        # Clear GUI fields
        for field_id in field_ids:
            element = js.document.getElementById(field_id)
            if element:
                print(f"  Clearing {field_id}")
                element.value = ''
                # Trigger change event to update any dependent fields
                if field_id.endswith('_CTR'):
                    js.document.getElementById(field_id).dispatchEvent(js.Event.new('change'))

        # Clear flight_plan_data for departure fields
        keys = [
            f'{fname}_COUNTRY', f'{fname}_ICAO_CITY',
            f'{fname}_ICAO', f'{fname}_ICAO_CITY', f'{fname}_NAME',
            f'{fname}_POSITION', f'{fname}_RUNWAY', f'{fname}_ELEVATION',
            f'{fname}_RUNWAYS', f'{fname}_ROUTE_NAME', f'{fname}_ROUTE_ALTITUDE',
            f'{fname}_CIRCUIT_ALTITUDE', f'{fname}_CTR', f'{fname}_IMAGE',
            f'{fname}_URL_WEBSITE', f'{fname}_URL_WIKIPEDIA', f'{fname}_LATLON',
            f'{fname}_METAR_ICAO', f'{fname}_METAR', f'{fname}_WIND_ENVELOPE',
            f'{fname}_CLOUD', f'{fname}_TIMEZONE', f'{fname}_ATC_TOWER',
            f'{fname}_ATC_ATIS_FREQ', f'{fname}_ATC_GROUND', f'{fname}_ATC_APPROACH',
            f'{fname}_ATC_TELEPHONE', f'{fname}_RUNWAY_LENGTH', f'{fname}_RUNWAY_SURFACE',
        ]

        for key in keys:
            if key == f'{fname}_CTR':
                js.window.flight_plan_data[key] = False
            elif '_LATLON' in key:
                js.window.flight_plan_data[key] = [None, None]
            elif key in [f'{fname}_METAR', f'{fname}_METAR_ICAO', f'{fname}_WIND_ENVELOPE']:
                js.window.flight_plan_data[key] = ''
            elif key in [f'{fname}_CLOUD', f'{fname}_RUNWAYS']:
                js.window.flight_plan_data[key] = ''
            else:
                js.window.flight_plan_data[key] = ''

        # Reset to default image
        await clear_aerodrome_image(fname)


    async def update_aerodrome_image(fname):
        """Update image from DEPARTURE_IMAGE or ARRIVAL_IMAGE or use default"""
        print(f"üñºÔ∏è Updating {fname} image...")

        # Get the image URL from flight_plan_data
        # 1. from GitHub
        # 2. from wikipedia
        # 3. from default
        image_url1 = os.path.join(js.window.settings['url_aerodromes_images'], js.window.flight_plan_data[f'{fname}_ICAO']) + '.png' if js.window.flight_plan_data[f'{fname}_ICAO'] != '' else None
        image_url2 = js.window.flight_plan_data.get(f'{fname}_IMAGE')
        image_url3 = js.DEFAULT_ICAO_IMAGE

        for image_url in [image_url1, image_url2, image_url3]:
            if await cache_and_display_image(image_url, f'{fname}_image_cache'):
                print(f"  üìã {fname}_IMAGE from flight_plan_data: {image_url}")
                break


    async def clear_aerodrome_image(fname):
        """Reset aerodrome image to default"""
        print("üîÑ Resetting to default image...")
        await cache_and_display_image(js.DEFAULT_ICAO_IMAGE, f'{fname}_image_cache')


    async def cache_and_display_image(url, img_element_id):
        """Cache and display an image using browser cache API"""
        # If the URL is invalid or missing, return without displaying an image
        if not url or str(url) == 'None' or str(url) == '' or str(url) == 'nan' or not str(url).startswith('http'):
            return False

        try:
            cache = await js.caches.open("skywalk-cache-v1")

            # Try loading from cache
            response = await cache.match(url)

            if not response:
                print(f"  üì• Image not cached, downloading: {url}")
                response = await js.fetch(url)
                if response.ok:
                    await cache.put(url, response.clone())
                else:
                    print(f"  ‚ùå Failed to fetch image: {response.status}")
                    return False
            else:
                print(f"  üì¶ Loaded from cache: {url}")

            # Convert response to blob and display
            blob = await response.blob()
            object_url = js.URL.createObjectURL(blob)
            js.document.getElementById(img_element_id).src = object_url
            print(f"  ‚úÖ Image displayed: {img_element_id}")
            return True

        except Exception as e:
            print(f"  ‚ùå Error caching/displaying image: {e}")
            raise
            return False


    def get_icao_data(df, city_icao, colname='city_icao'):
        """Load custom icao from disk and update"""
        row_dict = {}
        for df_row in df:
            if df_row.get('city_icao') == city_icao:
                row_dict = df_row
                break
        # Return
        return row_dict


    def retrieve_runways(row_dict):
        """Retrieve the runways from ICAO"""
        # row_dict = get_icao_data(df, city_icao)
        rwy_ids, rwy_list = [], []

        # Get all INFORMATION for the selected ICAO
        if row_dict:
            runways = row_dict.get("runways", [])
            if isinstance(runways, str): runways = ast.literal_eval(runways)
            rwy_ids = [r["id"] for r in runways if isinstance(r, dict) and "id" in r]
            rwy_list = options_runway_number(runways)

        # Return
        return rwy_ids, rwy_list


    def options_runway_number(data):
        """Retrieve all available runways based on aerodrome ICAO."""
        runways = []
        if data is not None:
            runways = [num for rwy in data for num in rwy.get("number", [])]
            runways = list(filter(lambda x: x != '', runways))

        # Return
        return runways


    def expected_runway_number(fname, metar_icao, extra_runways=None):
        """Compute the expected runway based on wind information for a given aerodrome."""
        print(f'--> func: expected_runway_number({fname})')
        # Defaults
        expect_runway = ''

        # Get all runways for the aerodrome. We need to copy the list to avoid modifying the original data
        runways = js.window.flight_plan_data[f"{fname}_RUNWAYS"].copy()

        # Add more runways if provided
        if extra_runways is not None and extra_runways.strip() != '':
            rwys_clean = re.findall(r'\d+', extra_runways)
            runways.extend(rwys_clean)
            runways = list(set(runways))
            print(f'Extended runway list: {runways}')

        # Extract wind information from METAR data
        wind_dict = analyzeWind(metar_icao)

        wind_direction = wind_dict.get('direction', '')
        wind_strength = wind_dict.get('speed', '')
        # Get all listed runways for this ICAO

        # Compute the expected runway number
        if (len(runways) > 0) and (wind_direction is not None) and is_numeric(wind_direction):
            results = list(map(lambda x: runway_headwind(wind_direction, wind_strength, x), runways))
            if np.any(results):
                expect_runway = runways[np.where(results)[0][0]]
        else:
            print(f'func: expected_runway_number() > No wind direction {wind_direction} or or wind_strength {wind_strength} or runways {runways} found')

        # Return
        return expect_runway


    def runway_headwind(wind_direction, wind_strength, runway_direction):
        """Compute whether the input runway number has headwind.

        The runway number is determined on the headwind component.
        If there is any headwind given wind direction, wind strength and runway direction, then
        it is the predicted runway number. However, the aerodrome always decides which runway is
        in use. On borderline results, it can be different than what is computed.

        Parameters
        ----------
        wind_direction : int[0-360]
            The wind direction in degrees.
        wind_strength : float
            The strenght of the wind.
        runway_direction : String or integer
            The runway direction in degrees but in 2 decimals '24' or '06' etc.

        Returns
        -------
        bool
            True: if runway direction matches to the wind.
            False: if runway direction does not match to the wind.

        Examples
        --------
        >>> # Example usage:
        >>> wind_direction = 179
        >>> wind_strength = 15
        >>> runway_direction = "27A"
        >>> runway_direction = "09"
        >>> OK = runway_headwind(wind_direction, wind_strength, runway_direction)
        >>> print(OK)
        """
        if (wind_direction is None) or not is_numeric(wind_direction) or (wind_strength is None) or (runway_direction is None):
            return None

        runway_direction = correct_runway_number(runway_direction)
        if not isinstance(runway_direction, (int, float)):
            return None

        cos_result = headwind(wind_direction, wind_strength, runway_direction)

        if cos_result > 0:
            return True
        else:
            return False


    def headwind(wind_direction, wind_strength, runway_direction):
        """Compute headwind strength.

        Headwind component = cos(runway-wind direction)*strength

        Parameters
        ----------
        wind_direction : int[0-360]
            The wind direction in degrees.
        wind_strength : float
            The strenght of the wind.
        runway_direction : String or integer
            The runway direction in degrees but in 2 decimals '24' or '06' etc.

        Returns
        -------
        result : float
            crosswind strength.

        Examples
        --------
        # Example usage:
        >>> wind_direction = 250
        >>> runway_direction = "27"
        >>> wind_strength = 4
        >>> hw = headwind(wind_direction, wind_strength, runway_direction)
        >>> print(f"Result: {hw}")

        """
        if (wind_direction is None) or not is_numeric(wind_direction) or (wind_strength is None) or (runway_direction is None):
            return None
        # Check runway
        runway_direction = correct_runway_number(runway_direction)
        if not isinstance(runway_direction, (int, float)):
            return None

        # print(wind_direction)
        # print(wind_strength)
        # print(runway_direction)

        radians_difference = math.radians(wind_direction - (runway_direction * 10))
        result = math.cos(radians_difference) * wind_strength
        if result == 0: result = int(result)
        return result


    def correct_runway_number(runway_direction):
        """Correct the runway number by extracting the first two characters from the provided runway direction."""
        if isinstance(runway_direction, str) and len(runway_direction) > 1:
            runway_direction = runway_direction[0:2]
            runway_direction = int(runway_direction)
        return runway_direction


    def analyzeWind(metar):
        """Method parse and analyze wind datas from METAR message and
        returns a dictionnary with wind informations.
        Support Knots (KT) and Meter Per Second (MPS) units.
        Units are not informations returned by method.
        If `analyzeWind()` can't decode wind information (in case of unavaibility
        indicated by ///////KT), method return None.

        Returns
        --------
            wind_tot (dict): Dictionnary with wind informations.
            Keys:
                - direction (integer), direction of wind
                - direction (string), "VRB" for variable
                - speed (integer), speed of wind
                - gust_speed (integer or None), speed of gust, None if no gust
                - variation(tuple), variation of wind (tuple of integer), None if no variation

            - None (NoneType): None if method can't decode wind informations.
        """
        search = None

        regex_list_kt = [r'\d{5}KT', r'\d{5}G\d{2}KT', r'VRB\d{2}KT']
        # [0] Normal (33005KT) [1] Gust (33010G25KT) [2] Variable direction (VRB03KT)
        regex_list_mps = [r'\d{5}MPS', r'\d{5}G\d{2}MPS', r'VRB\d{2}MPS']
        # Meters per second

        i = 0
        end = len(regex_list_kt)

        while search is None and i < end:
            search = re.search(regex_list_kt[i], metar)
            i += 1

        if search is None:  # Knot verification failed, MPS verification
            i = 0
            end = len(regex_list_mps)

            while search is None and i < end:
                search = re.search(
                    regex_list_mps[i], metar)
                i += 1

            if search is None:
                return None

        wind_tot = search.group()
        direction = wind_tot[:3]

        if direction != 'VRB':
            direction = int(direction)

        speed = wind_tot[3:5]
        speed = int(speed)

        if 'G' in wind_tot:  # Gust
            gust_speed = int(wind_tot[6:8])
        else:
            gust_speed = None

        ##Variations##
        regex = r'\d{3}V\d{3}'
        search = re.search(regex, metar)

        if search is not None:
            variation = search.group()
            variation = variation.split('V')
            variation = [int(value) for value in variation]
            variation = tuple(variation)
        else:
            variation = None

        wind_infos = {
            'direction': direction,
            'speed': speed,
            'gust': gust_speed,
            'variation': variation
        }

        return wind_infos

    def is_numeric(value):
        """
        Check whether the input string is a numerical value.

        Parameters
        ----------
        value : str
            The input string to be checked.

        Returns
        -------
        bool
            True if the input string is a numerical value, False otherwise.

        Example
        -------
        >>> is_numeric("-2.9")
        >>> True
        >>> is_numeric("2.33")
        >>> True
        >>> is_numeric("22272")
        >>> True
        >>> is_numeric("0.003")
        >>> True
        >>> is_numeric("-0.003")
        >>> True
        >>> is_numeric("abc")
        >>> False
        >>> is_numeric("1.2.3")
        >>> False
        >>> is_numeric("1B")
        >>> False

        """
        # Check if the string is empty
        if (isinstance(value, str) and value == ''):
            return False
        if isinstance(value, (float, int)):
            return True
        if value is None:
            return False
        if isinstance(value, str):
            value = value.strip()

        # Allow negative numbers (starting with '-' at the beginning)
        if value[0] == '-':
            value = value[1:]

        # Allow decimal points in the string
        parts = value.split('.')
        if len(parts) <= 2 and all(part.isnumeric() for part in parts):
            return True

        return False


    async def create_new_flightplan():
        """Initialize new flightplan - returns current datetime for UI"""
        # Get current datetime for UI
        current_time = datetime.now().strftime("%d-%m-%Y %H:%M")
        print("üÜï Creating new flightplan...")

        # Store default flight plan data
        # js.window.flight_plan_data = await get_default_data()

        # Reset flight plan data
        js.window.flight_plan_data = {
            'DEPARTURE_LATLON': [None, None],
            'ARRIVAL_LATLON': [None, None],
            'DEPARTURE_COUNTRY': '',
            'ARRIVAL_COUNTRY': ''
        }

        # Clear fields
        await clear_general_fields()
        await clear_aerodrome_fields('DEPARTURE')
        await clear_aerodrome_fields('ARRIVAL')
        await clear_enroute_fields()

        # Remove METAR widget
        remove_metar_widget('DEPARTURE')
        remove_metar_widget('ARRIVAL')

        js.window.AERODROME_DEPARTURE_DATA = {}
        js.window.AERODROME_ARRIVAL_DATA = {}
        js.window.AERODROME_DATA = {}
        js.window.airspaces = {}
        js.window.waypoints = []

        print("‚úÖ New flightplan initialized - all fields cleared")
        return current_time


    async def delete_flightplan():
        """Delete selected flightplan from localStorage"""
        plan_name = js.document.getElementById('plan_spinner').value

        if not plan_name or plan_name == "":
            print("‚ö†Ô∏è No flightplan selected")
            return

        # Confirm deletion
        if not js.window.confirm(f"Are you sure you want to delete '{plan_name}'?"):
            print("‚ùå Deletion cancelled")
            return

        # Delete from localStorage
        storage_key = f"flightplan_{plan_name}"
        js.localStorage.removeItem(storage_key)
        print(f"‚úÖ Flightplan '{plan_name}' deleted")

        # Clear the dropdown selection
        js.document.getElementById('plan_spinner').value = ""

        # Update the flightplan list
        update_dropdown_flightplans()

        """Create new flightplan with current timestamp"""
        await clear_general_fields()
        await clear_aerodrome_fields('DEPARTURE')
        await clear_aerodrome_fields('ARRIVAL')
        await clear_enroute_fields()


    async def delete_enroute_fic(spinner_name):
        """Delete selected enroute FIC from localStorage"""
        user_selection = js.document.getElementById(spinner_name).value

        if not user_selection or user_selection == "":
            print("‚ö†Ô∏è No Enroute FIC selected")
            return

        # Confirm deletion
        if not js.window.confirm(f"Are you sure you want to delete '{user_selection}'?"):
            print("‚ùå Deletion cancelled")
            return

        # Delete from localStorage
        storage_key = f"ENROUTE_{user_selection}"
        js.localStorage.removeItem(storage_key)
        print(f"‚úÖ ENROUTE FIC '{user_selection}' deleted")

        # Clear the GUI dropdown selection
        js.document.getElementById(spinner_name).value = ""

        # Clear the GUI fields
        if spinner_name == 'fic_spinner':
            js.document.getElementById('FIC_NAME').value = ''
            js.document.getElementById('FIC_FREQUENCY').value = ''
            js.document.getElementById('OVERHEAD').value = ''
            js.document.getElementById('SQUAWK').value = ''
        elif spinner_name == 'fic_spinner2':
            js.document.getElementById('FIC_NAME2').value = ''
            js.document.getElementById('FIC_FREQUENCY2').value = ''
            js.document.getElementById('OVERHEAD2').value = ''
            js.document.getElementById('SQUAWK2').value = ''

        # Update the enroute list
        update_dropdown_enroute_FIC()


    async def load_enroute_fic(spinner_name):
        """Load selected FIC from localStorage"""

        # Get the user selection from the spinner element
        user_selection = js.document.getElementById(spinner_name).value

        if not user_selection or user_selection == "":
            print("‚ö†Ô∏è No Enroute FIC selected")
            return

        print(f"üìÇ Loading Enroute: {user_selection}")

        # Clear relevant fields based on spinner
        if spinner_name == 'fic_spinner':
            js.document.getElementById('FIC_NAME').value = ''
            js.document.getElementById('FIC_FREQUENCY').value = ''
            js.document.getElementById('OVERHEAD').value = ''
            js.document.getElementById('SQUAWK').value = ''
        elif spinner_name == 'fic_spinner2':
            js.document.getElementById('FIC_NAME2').value = ''
            js.document.getElementById('FIC_FREQUENCY2').value = ''
            js.document.getElementById('OVERHEAD2').value = ''
            js.document.getElementById('SQUAWK2').value = ''

        print(f"üìÇ Loading Enroute: {user_selection}")

        # Load from localStorage
        storage_key = f"ENROUTE_{user_selection}"
        json_data = js.localStorage.getItem(storage_key)

        if not json_data:
            print(f"‚ö†Ô∏è ENROUTE not found: {user_selection}")
            js.window.alert(f"‚ö†Ô∏è ENROUTE '{user_selection}' not found")
            return

        # Parse JSON
        try:
            enroute_dict = json.loads(json_data)
            print(f"‚úÖ Loaded ENROUTE: {len(enroute_dict)} fields for {spinner_name}")

            # Update the keys in enroute_dict in case of fic_spinner2
            if spinner_name == 'fic_spinner2':
                enroute_dict['FIC_NAME2'] = enroute_dict.pop('FIC_NAME', None)
                enroute_dict['FIC_FREQUENCY2'] = enroute_dict.pop('FIC_FREQUENCY', None)
                enroute_dict['OVERHEAD2'] = enroute_dict.pop('OVERHEAD', None)
                enroute_dict['SQUAWK2'] = enroute_dict.pop('SQUAWK', None)

            # Fill the flight_plan_data dictionary
            for key, value in enroute_dict.items():
                print(f"ENROUTE Key: {key}, Value: {value}")
                js.window.flight_plan_data[key] = value if value not in ('', None, 'None', 'nan') else ''

            # Update GUI FIELDS
            update_enroute_gui_fields(enroute_dict)
            # Update missing fields colors
            js.window.highlightMissingFields()


            print(f"‚úÖ Flightplan '{user_selection}' loaded successfully")
        except Exception as e:
            print(f"‚ùå Error loading flightplan: {e}")
            js.window.alert(f"‚ùå Error loading flightplan: {e}")


    async def load_flightplan():
        """Load flightplan from localStorage"""
        plan_name = js.document.getElementById('plan_spinner').value

        # First clear all fields
        # await clear_general_fields()
        # await clear_aerodrome_fields('DEPARTURE')
        # await clear_aerodrome_fields('ARRIVAL')
        # await clear_enroute_fields()

        if not plan_name or plan_name == "":
            print("‚ö†Ô∏è No flightplan selected")
            return

        print(f"üìÇ Loading flightplan: {plan_name}")

        # Load from localStorage
        storage_key = f"flightplan_{plan_name}"
        json_data = js.localStorage.getItem(storage_key)

        if not json_data:
            print(f"‚ö†Ô∏è Flightplan not found: {plan_name}")
            js.window.alert(f"‚ö†Ô∏è Flightplan '{plan_name}' not found")
            return

        # Parse JSON
        try:
            # Load json data file
            flight_plan_dict = json.loads(json_data)
            print(f"‚úÖ Loaded {len(flight_plan_dict)} fields")

            # Initialize empty waypoints array
            js.window.waypoints = []

            # Fill the flight_plan_data dictionary from the loaded JSON data
            for key, value in flight_plan_dict.items():
                js.window.flight_plan_data[key] = value

            # js.window.waypoints = window.flight_plan_data['WAYPOINTS']

            # Update GUI FIELDS
            update_general_gui_fields(flight_plan_dict)
            update_aerodrome_gui_fields('DEPARTURE')
            update_aerodrome_gui_fields('ARRIVAL')

            # Update IMAGES
            await update_aerodrome_image('DEPARTURE')
            await update_aerodrome_image('ARRIVAL')

            # Add data to javascript global cache. This is needed for the aerodrome selection and plotting on the map
            if flight_plan_dict['DEPARTURE_COUNTRY'] != '':
                await import_country_selected('DEPARTURE', flight_plan_dict['DEPARTURE_COUNTRY'])
            if flight_plan_dict['ARRIVAL_COUNTRY'] != '':
                await import_country_selected('ARRIVAL', flight_plan_dict['ARRIVAL_COUNTRY'])

            print(f"‚úÖ Flightplan '{plan_name}' loaded successfully")
        except Exception as e:
            print(f"‚ùå Error loading flightplan: {e}")
            js.window.alert(f"‚ùå Error loading flightplan: {e}")



    def save_flightplan(to_cache=True):
        """Save current flightplan data to localStorage"""

        # STORE FIELDS FROM GENERAL IN FLIGHTPLAN
        js.window.flight_plan_data["FLIGHTPLAN"] = js.document.getElementById('FLIGHTPLAN').value;
        js.window.flight_plan_data["POB"] = js.document.getElementById('POB').value;
        js.window.flight_plan_data["FLIGHT_RULES"] = js.document.getElementById('FLIGHT_RULES').value;
        js.window.flight_plan_data["DATETIME"] = js.document.getElementById('DATETIME').value;
        js.window.flight_plan_data["AIRCRAFT_TYPE"] = js.document.getElementById('AIRCRAFT_TYPE').value;
        js.window.flight_plan_data["CALLSIGN"] = js.document.getElementById('CALLSIGN').value;
        js.window.flight_plan_data["CALLSIGN_SHORT"] = js.window.create_callsign_short(js.document.getElementById('CALLSIGN').value);
        # STORE FIELDS FROM ENROUTE IN FLIGHTPLAN
        js.window.flight_plan_data["FIC_NAME"] = js.document.getElementById('FIC_NAME').value;
        js.window.flight_plan_data["FIC_FREQUENCY"] = js.document.getElementById('FIC_FREQUENCY').value;
        js.window.flight_plan_data["OVERHEAD"] = js.document.getElementById('OVERHEAD').value;
        js.window.flight_plan_data["SQUAWK"] = js.document.getElementById('SQUAWK').value;
        js.window.flight_plan_data["FIC_NAME2"] = js.document.getElementById('FIC_NAME2').value;
        js.window.flight_plan_data["FIC_FREQUENCY2"] = js.document.getElementById('FIC_FREQUENCY2').value;
        js.window.flight_plan_data["OVERHEAD2"] = js.document.getElementById('OVERHEAD2').value;
        js.window.flight_plan_data["SQUAWK2"] = js.document.getElementById('SQUAWK2').value;
        # STORE ROUTE AND POSITION FIELDS IN FLIGHTPLAN
        js.window.flight_plan_data["DEPARTURE_ROUTE_NAME"] = js.document.getElementById('DEPARTURE_ROUTE_NAME').value;
        js.window.flight_plan_data["DEPARTURE_POSITION"] = js.document.getElementById('DEPARTURE_POSITION').value;
        js.window.flight_plan_data["ARRIVAL_ROUTE_NAME"] = js.document.getElementById('ARRIVAL_ROUTE_NAME').value;
        js.window.flight_plan_data["ARRIVAL_POSITION"] = js.document.getElementById('ARRIVAL_POSITION').value;
        # STORE WAYPOINTS
        # js.window.flight_plan_data['WAYPOINTS'] = js.window.waypoints
        # ALL OTHER FIELDS SHOULD BE STORE ALREADY IN THE FLIGHTPLAN DATA

        # GET FLIGHTPLAN NAME
        flightplan_name = js.window.flight_plan_data.get("FLIGHTPLAN", "")

        # Print the saved variables array
        print("-------------SAVE FLIGHTPLAN DATA TO DICT-------------")
        print(f"  Flightplan Name: {flightplan_name}")

        # Convert flight_plan_data to JSON string
        flight_plan_dict = {}
        keys = get_default_data()
        for key in keys:
            try:
                value = js.window.flight_plan_data.get(key)
                # Convert JavaScript objects to Python objects
                if hasattr(value, 'to_py'):
                    value = value.to_py()
                flight_plan_dict[key] = value
            except Exception as e:
                print(f"‚ö†Ô∏è Failed to save {key}: {e}")

        # Print Data
        for key, value in flight_plan_dict.items():
            if value != '' and value != None and value != {} and value != []:
                print(f"  {key}: '{value}'")

        # Save to cache
        if to_cache and flightplan_name and flightplan_name != "":
            print("-------------SAVE FLIGHTPLAN DATA TO CACHE-------------")

            # Convert to JSON string
            json_data = json.dumps(flight_plan_dict)

            # Save to localStorage with key "flightplan_[name]"
            storage_key = f"flightplan_{flightplan_name}"
            js.localStorage.setItem(storage_key, json_data)

            # Get localStorage info
            # print_local_storage()

            # Update the list of saved flightplans
            update_dropdown_flightplans()
            update_dropdown_enroute_FIC()

            print("---------------DATA SAVED-------------------")
            return True


    async def load_aerodrome_from_json(fname):
        """Load aerodrome data for departure or arrival from localStorage.

        This function loads cached aerodrome data for either departure or arrival from browser localStorage.
        It will clear existing fields, load the saved data into flight_plan_data, update GUI fields and images.

        Example:
            load_aerodrome_from_json('DEPARTURE')
            load_aerodrome_from_json('ARRIVAL')
        """
        # Make cache key
        selected_icao = js.document.getElementById(f'{fname}_ICAO').value.upper() or ''
        cache_key = fname + '_' + selected_icao

        # Load cached data
        json_data = js.localStorage.getItem(cache_key)

        if not json_data:
            print(f"‚ö†Ô∏è Aeordrome data not found: {cache_key}")
            js.window.alert(f"No custom aerodrome data found for {selected_icao} in {fname}");
            return

        # Parse JSON
        try:
            fname_dict = json.loads(json_data)
            fname_dict[f'{fname}_RUNWAY'] = ''

            print(f"‚úÖ Loaded {len(fname_dict)} fields")

            # Clear aerodrome fields
            await clear_aerodrome_fields(fname)

            # Overwrite the keys in the flight_plan_data dictionary from the loaded JSON data
            for key, value in fname_dict.items():
                js.window.flight_plan_data[key] = value

            # Update GUI fields
            update_aerodrome_gui_fields(fname)

            # Update images
            await update_aerodrome_image(fname)

            # Update missing fields colors
            js.window.highlightMissingFields()

            # Remove METAR widget
            remove_metar_widget(fname)

            print(f"‚úÖ Aerodrome data loaded successfully for {fname}")
        except Exception as e:
            print(f"‚ùå Error loading aerodrome data: {str(e)}")
            js.window.alert(f"‚ùå Error loading aerodrome data: {str(e)}")


    def save_aerodrome_to_json(fname):
        """Save custom aerodrome data (ICAO) to localStorage

        Saves data for either departure/arrival aerodrome data to browser's localStorage.
        For departure/arrival, saves relevant fields starting with that prefix.
        For enroute, saves specific enroute-related fields.
        All fields are saved but not all are loaded in load_aerodrome_from_json such as RUNWAY since they depend on weather conditions.

        Args:
            fname (str): Either 'DEPARTURE', 'ARRIVAL' to indicate what data to save

        The data is saved with a key format of:
        - For departure/arrival: [DEPARTURE|ARRIVAL]_[ICAO]

        Example:
            save_aerodrome_to_json('DEPARTURE')
            save_aerodrome_to_json('ARRIVAL')
        """
        print(f'----> save_aerodrome_to_json({fname})')
        dict_fname = {}

        # Get flightplan data from dictionary
        flight_data = js.window.flight_plan_data

        if fname == 'DEPARTURE' or fname == 'ARRIVAL':
            # Create Cache key
            cache_key = fname + '_' + flight_data[f"{fname}_ICAO"]
            # Retrieve keys for dictionary
            dict_fname = {k: v for k, v in flight_data.items() if k.startswith(fname)}

            # Update the dictionary with data from GUI
            for key in dict_fname.keys():
                # Do not store RUNWAY keys because runways are determined by the weather conditions
                element = js.document.getElementById(key)
                # Check whether field GUI exists using truthiness check which handles JsNull
                if element and hasattr(element, 'value'):
                    field_value = element.value
                    if field_value and str(field_value) not in ('nan', 'None', ''):
                        print(f'Saving to {cache_key} dictionary: {key}: {field_value}')
                        dict_fname[key] = field_value
        else:
            print(f'{fname} not valid to save to JSON')
            return

        # Save to cache
        print(f'----> AERODROME SAVED: {cache_key}')
        # Convert to JSON string
        json_data = json.dumps(dict_fname)
        # Save to cache
        js.localStorage.setItem(cache_key, json_data)
        # save_to_cache(cache_key, dict_fname)


    def save_enroute_to_json(prefix):
        """Save custom enroute data to localStorage.

        Args:
            prefix (str): 'ENROUTE1', 'ENROUTE2'
        """
        print(f'----> save_enroute_to_json({prefix})')

        # Create empty dict
        dict_enroute = {}

        # Store the FIC to localStorage
        if prefix == 'ENROUTE1':
            # Create cache key
            listname = js.document.getElementById('FIC_NAME').value
            cache_key = 'ENROUTE_' + listname.upper().strip()

            enroute_fields = {
                'FIC_NAME': js.document.getElementById('FIC_NAME').value,
                'FIC_FREQUENCY': js.document.getElementById('FIC_FREQUENCY').value,
                'OVERHEAD': js.document.getElementById('OVERHEAD').value,
                'SQUAWK': js.document.getElementById('SQUAWK').value,
            }
        elif prefix == 'ENROUTE2':
            # Create cache key
            listname = js.document.getElementById('FIC_NAME2').value
            cache_key = 'ENROUTE_' + listname.upper().strip()

            enroute_fields = {
                'FIC_NAME': js.document.getElementById('FIC_NAME2').value,
                'FIC_FREQUENCY': js.document.getElementById('FIC_FREQUENCY2').value,
                'OVERHEAD': js.document.getElementById('OVERHEAD2').value,
                'SQUAWK': js.document.getElementById('SQUAWK2').value
            }
        else:
            print(f'Invalid prefix: {prefix}')
            return

        if not listname or listname == '':
            return

        # Only store non-empty values
        for key, value in enroute_fields.items():
            if value and str(value) not in ('nan', 'None', ''):
                dict_enroute[key] = value
            else:
                dict_enroute[key] = ''

        # Save to cache
        print(f'----> {prefix} SAVED: {cache_key}')
        # Convert to JSON string
        json_data = json.dumps(dict_enroute)
        # Save to cache
        js.localStorage.setItem(cache_key, json_data)
        # Update FIC dropdown after saving
        update_dropdown_enroute_FIC()
        print(f"‚úÖ FIC data saved and dropdown updated")


    def print_local_storage():
        # Get localStorage info

        print(f"üíæ Saved to localStorage: {storage_key}")
        print(f"   Storage Type: Browser localStorage")
        print(f"   Storage Location: Browser's IndexedDB/localStorage database")
        print(f"   Key: {storage_key}")
        print(f"   Size: {len(json_data)} bytes")

        # Print browser-specific path hints
        print(f"   Browser localStorage is typically stored at:")
        if sys.platform == 'win32':
            print(f"   - Chrome: %LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Local Storage")
            print(f"   - Firefox: %APPDATA%\\Mozilla\\Firefox\\Profiles\\<profile>\\storage\\default")
            print(f"   - Edge: %LOCALAPPDATA%\\Microsoft\\Edge\\User Data\\Default\\Local Storage")
        elif sys.platform == 'darwin':
            print(f"   - Chrome: ~/Library/Application Support/Google/Chrome/Default/Local Storage")
            print(f"   - Firefox: ~/Library/Application Support/Firefox/Profiles/<profile>/storage/default")
            print(f"   - Safari: ~/Library/Safari/LocalStorage")
        else:
            print(f"   - Chrome: ~/.config/google-chrome/Default/Local Storage")
            print(f"   - Firefox: ~/.mozilla/firefox/<profile>/storage/default")


    def update_dropdown_flightplans():
        """Update the flightplan dropdown with saved plans from localStorage"""
        print("üîÑ Updating flightplan list...")

        # Get all keys from localStorage
        storage_length = js.localStorage.length
        flightplan_names = []

        for i in range(storage_length):
            key = js.localStorage.key(i)
            if key and str(key).startswith('flightplan_'):
                # Extract flightplan name from key
                plan_name = str(key).replace('flightplan_', '')
                flightplan_names.append(plan_name)

        # Sort alphabetically
        flightplan_names.sort()

        # Update dropdown
        select = js.document.getElementById('plan_spinner')
        if select:
            # Clear existing options except the first placeholder
            select.innerHTML = '<option value="">Select flightplan</option>'

            # Add each flightplan as an option
            for plan_name in flightplan_names:
                option = js.document.createElement('option')
                option.value = plan_name
                option.textContent = plan_name
                select.appendChild(option)

            print(f"‚úÖ Found {len(flightplan_names)} saved flightplans")
        else:
            print("‚ö†Ô∏è Flightplan dropdown not found")


    def update_dropdown_enroute_FIC():
        """Update the FICS dropdowns with cached FICs"""
        print("üîÑ Updating FICS in ENROUTE...")

        # Get all keys from localStorage
        storage_length = js.localStorage.length
        FIC_names = []

        for i in range(storage_length):
            key = js.localStorage.key(i)
            if key and str(key).startswith('ENROUTE_'):
                fic_name = str(key).replace('ENROUTE_', '')
                FIC_names.append(fic_name)

        # Sort alphabetically
        FIC_names.sort()

        # Update both dropdowns
        for spinner_id in ['fic_spinner', 'fic_spinner2']:
            select = js.document.getElementById(spinner_id)
            if select:
                # Clear existing options except the first placeholder
                select.innerHTML = '<option value="">Select FIC</option>'

                # Add each FIC as an option
                for name in FIC_names:
                    option = js.document.createElement('option')
                    option.value = name
                    option.textContent = name
                    select.appendChild(option)

                print(f"‚úÖ Updated {spinner_id} with {len(FIC_names)} FICs")
            else:
                print(f"‚ö†Ô∏è FICs dropdown not found: {spinner_id}")


    async def create_summary_atc(reverse_path=False):
        """Create ATC summary (placeholder function)"""
        print("Creating ATC summary...")
        # Generate HTML content
        html_content = await generate_summary_html(reverse_path=reverse_path)
        # Open in browser
        # open_html(html_content, 'ATC_Summary_reverse' if reverse_path else 'ATC_Summary')
        open_html(html_content)

    async def create_departure_atc(reverse_path=False):
        """Create ATC Departure (placeholder function)"""
        print("Creating Departure summary...")
        # Generate HTML content
        html_content = await generate_departure_html(reverse_path=reverse_path)
        # Open in browser
        # open_html(html_content, 'ATC_Departure_reverse' if reverse_path else 'ATC_Departure')
        open_html(html_content)

    async def create_arrival_atc(reverse_path=False):
        """Create ATC Arrival (placeholder function)"""
        print("Creating Arrival summary...")
        # Generate HTML content
        html_content = await generate_arrival_html(reverse_path=reverse_path)
        # Open in browser
        # open_html(html_content, 'ATC_Arrival_reverse' if reverse_path else 'ATC_Arrival')
        open_html(html_content)

    async def create_enroute_atc(reverse_path=False):
        """Create ATC Enroute (placeholder function)"""
        print("Creating Enroute summary...")
        # Generate HTML content
        html_content = await generate_enroute_html(reverse_path=reverse_path)
        # Open in browser
        # open_html(html_content, 'ATC_Enroute_reverse' if reverse_path else 'ATC_Enroute')
        open_html(html_content)


    async def generate_summary_html(reverse_path=False):
        """Generate HTML content for summary screen similar to ATC_SUMMARY."""

        flight_data = js.window.flight_plan_data
        settings = js.window.settings

        try:
            # Set departure and arrival
            if reverse_path:
                DEPARTURE, ARRIVAL = 'ARRIVAL', 'DEPARTURE'
            else:
                DEPARTURE, ARRIVAL = 'DEPARTURE', 'ARRIVAL'

            # Prepare frequency and tower info
            ATC_FREQUENCIES = create_freq_list_combined([DEPARTURE, ARRIVAL])
            ATC_TOWER_FREQ_DEP, ATC_TOWER_NAME_DEP = get_ATC_TOWER(DEPARTURE)
            ATC_TOWER_FREQ_ARR, ATC_TOWER_NAME_ARR = get_ATC_TOWER(ARRIVAL)

            empty_field = '[ . . . . . . . . . ]'
            html_content = {
                'CALLSIGN': flight_data.get('CALLSIGN', '') or empty_field,
                'CALLSIGN_SHORT': flight_data.get('CALLSIGN_SHORT', '') or empty_field,
                'AIRCRAFT_TYPE': flight_data.get('AIRCRAFT_TYPE', '') or empty_field,
                'FLIGHT_RULES': flight_data.get('FLIGHT_RULES', '') or empty_field,
                'POB': flight_data.get('POB', '') or empty_field,

                'REQUEST_INFORMATION': '' if flight_data.get(f'{ARRIVAL}_CTR', False) else 'REQUEST AERODROME INFORMATION',
                'TEXT_INFORMATION_RECEIVED': TEXT_INFORMATION_RECEIVED() if flight_data.get(f'{ARRIVAL}_CTR', False) else '',
                'CTR_REGION_BOOL_DEPARTURE': 'true' if flight_data.get(f'{DEPARTURE}_CTR', False) else 'false',
                'CTR_REGION_BOOL_ARRIVAL': 'true' if flight_data.get(f'{ARRIVAL}_CTR', False) else 'false',

                'DEPARTURE_POSITION': flight_data.get(f'{DEPARTURE}_POSITION', '') or 'at the Apron',
                'DEPARTURE_RUNWAY': flight_data.get(f'{DEPARTURE}_RUNWAY', '') or empty_field,
                'DEPARTURE_NAME': flight_data.get(f'{DEPARTURE}_NAME', '') or empty_field,
                'DEPARTURE_ROUTE_NAME': flight_data.get(f'{DEPARTURE}_ROUTE_NAME', '') or empty_field,
                'DEPARTURE_ROUTE_ALTITUDE': flight_data.get(f'{DEPARTURE}_ROUTE_ALTITUDE', '') or empty_field,
                'DEPARTURE_ICAO': flight_data.get(f'{DEPARTURE}_ICAO', '') or empty_field,

                'FIC_NAME': flight_data.get('FIC_NAME', '') or empty_field,
                'FIC_FREQUENCY': flight_data.get('FIC_FREQUENCY', ''),
                'FIC_SQUAWK': flight_data.get('SQUAWK', ''),
                'OVERHEAD': flight_data.get('OVERHEAD', flight_data.get(f'{DEPARTURE}_ROUTE_NAME', '') or empty_field),
                'ATC_FREQUENCIES': ATC_FREQUENCIES,
                'ATC_ATIS_FREQ_DEP': flight_data.get(f'{DEPARTURE}_ATC_ATIS_FREQ', ''),
                'OVERHEAD2': flight_data.get('OVERHEAD2', ''),
                'FIC_SQUAWK2': flight_data.get('SQUAWK2', ''),

                'ATC_TOWER': ATC_TOWER_FREQ_DEP,
                'DELIVERY_OR_RADIO': ATC_TOWER_NAME_DEP if ATC_TOWER_NAME_DEP == 'RADIO' else 'DELIVERY',
                'ATC_GROUND': ATC_TOWER_FREQ_DEP if ATC_TOWER_NAME_DEP == 'RADIO' else flight_data.get(f'{DEPARTURE}_ATC_GROUND', ''),

                'ARRIVAL_ICAO': flight_data.get(f'{ARRIVAL}_ICAO', '') or empty_field,
                'ARRIVAL_ROUTE_ALTITUDE': flight_data.get(f'{ARRIVAL}_ROUTE_ALTITUDE', '') or empty_field,
                'ARRIVAL_NAME': flight_data.get(f'{ARRIVAL}_NAME', '') or empty_field,
                'ARRIVAL_ROUTE_NAME': flight_data.get(f'{ARRIVAL}_ROUTE_NAME', ''),
                'ATC_TOWER_ARR': ATC_TOWER_FREQ_ARR,
                'ATC_TOWER_NAME': ATC_TOWER_NAME_ARR,
                'ARRIVAL_RUNWAY': flight_data.get(f'{ARRIVAL}_RUNWAY', '') or empty_field,

                'GRID_COLUMNS': settings.get('user_select_cols', 1),
            }
            if reverse_path:
                html_content['FIC_NAME'] = flight_data.get('FIC_NAME2', '') or empty_field
                html_content['FIC_FREQUENCY'] = flight_data.get('FIC_FREQUENCY2', '')
                html_content['OVERHEAD'] = flight_data.get('OVERHEAD2', '')
                html_content['FIC_SQUAWK'] = flight_data.get('SQUAWK2', '')

            fontsizes = settings.get('fontsizes')

            css_content = {
                'FONT_SIZE_TOWER': fontsizes.get('TOWER'),
                'FONT_SIZE_PILOT': fontsizes.get('PILOT'),
                'FONT_SIZE_TITLE': fontsizes.get('TITLE'),
                'FONT_SIZE_SUBTITLE': fontsizes.get('TITLE') - 2,
                'BACKGROUND_COLOR_TITLE': '#6b21a8',
            }
            html_string = await personalize_content(html_content, 'ATC_summary_template.html.j2')
            css_string = await personalize_content(css_content, 'style_template.css.j2')

            html_with_css = f"""
            <style>
            {css_string}
            </style>
            {html_string}
            """
            return html_with_css
        except Exception as e:
            return f"<p>Error generating Summary HTML: {str(e)}</p>"


    async def generate_departure_html(reverse_path=False):
        """Generate HTML content for departure screen similar to ATC_DEPARTURE. """

        flight_data = js.window.flight_plan_data
        settings = js.window.settings

        try:
            # Set departure and arrival
            if reverse_path:
                DEPARTURE, ARRIVAL = 'ARRIVAL', 'DEPARTURE'
            else:
                DEPARTURE, ARRIVAL = 'DEPARTURE', 'ARRIVAL'

            # Create string of all Frequencies
            ATC_FREQUENCIES = create_freq_list_combined(DEPARTURE)
            ATC_TOWER_FREQ, ATC_TOWER_NAME = get_ATC_TOWER(DEPARTURE)

            # Prepare HTML content data
            empty_field = '[ . . . . . . . . . ]'
            html_content = {
                'CALLSIGN': flight_data.get('CALLSIGN', '') or empty_field,
                'CALLSIGN_SHORT': flight_data.get('CALLSIGN_SHORT', '') or empty_field,
                'AIRCRAFT_TYPE': flight_data.get('AIRCRAFT_TYPE', '') or empty_field,
                'FLIGHT_RULES': flight_data.get('FLIGHT_RULES', ''),
                'POB': flight_data.get('POB', '') or empty_field,

                'ARRIVAL_NAME': flight_data.get(f'{ARRIVAL}_NAME', '') or empty_field,
                'ARRIVAL_RUNWAY': flight_data.get(f'{ARRIVAL}_RUNWAY', '') or empty_field,
                'ARRIVAL_ROUTE_ALTITUDE': str(flight_data.get(f'{ARRIVAL}_ROUTE_ALTITUDE', '')) or empty_field,
                'ARRIVAL_ICAO': flight_data.get(f'{ARRIVAL}_ICAO', '') or empty_field,

                'CTR_REGION_BOOL': 'true' if flight_data.get(f'{DEPARTURE}_CTR', False) else 'false',
                'DEPARTURE_POSITION': flight_data.get(f'{DEPARTURE}_POSITION', '') or 'at the Apron',
                'DEPARTURE_RUNWAY': flight_data.get(f'{DEPARTURE}_RUNWAY', '') or empty_field,
                'DEPARTURE_NAME': flight_data.get(f'{DEPARTURE}_NAME', '') or empty_field,
                'DEPARTURE_ROUTE_NAME': flight_data.get(f'{DEPARTURE}_ROUTE_NAME', '') or empty_field,
                'DEPARTURE_ROUTE_ALTITUDE': flight_data.get(f'{DEPARTURE}_ROUTE_ALTITUDE', '') or empty_field,
                'DEPARTURE_CITY_ICAO': flight_data.get(f'{DEPARTURE}_NAME', '') or empty_field,
                'DEPARTURE_ICAO': flight_data.get(f'{DEPARTURE}_ICAO', '') or empty_field,

                'ATC_TOWER': ATC_TOWER_FREQ,
                'ATC_ATIS_FREQ_DEP': flight_data.get(f'{DEPARTURE}_ATC_ATIS_FREQ', ''),
                'DELIVERY_OR_RADIO': ATC_TOWER_NAME if ATC_TOWER_NAME == 'RADIO' else 'DELIVERY',
                'ATC_GROUND': ATC_TOWER_FREQ if ATC_TOWER_NAME == 'RADIO' else flight_data.get(f'{DEPARTURE}_ATC_GROUND', ''),
                'ATC_FREQUENCIES': ATC_FREQUENCIES,

                'GRID_COLUMNS': settings.get('user_select_cols', 1),
            }

            # Prepare CSS content
            fontsizes = settings.get('fontsizes')
            css_content = {
                'FONT_SIZE_TOWER': fontsizes.get('TOWER'),
                'FONT_SIZE_PILOT': fontsizes.get('PILOT'),
                'FONT_SIZE_TITLE': fontsizes.get('TITLE'),
                'FONT_SIZE_SUBTITLE': fontsizes.get('TITLE') - 2,
                'BACKGROUND_COLOR_TITLE': '#4769b1',
            }

            html_string = await personalize_content(html_content, 'ATC_departure_template.html.j2')
            css_string = await personalize_content(css_content, 'style_template.css.j2')

            # Embed CSS in the HTML content
            html_with_css = f"""
            <style>
            {css_string}
            </style>
            {html_string}
            """

            return html_with_css

        except Exception as e:
            return f"<p>Error generating Deparature HTML: {str(e)}</p>"


    async def generate_arrival_html(reverse_path=False):
        """Generate HTML content for arrivak screen similar to ATC_ARRIVAL."""

        flight_data = js.window.flight_plan_data
        settings = js.window.settings

        try:
            # Set departure and arrival
            if reverse_path:
                DEPARTURE, ARRIVAL = 'ARRIVAL', 'DEPARTURE'
            else:
                DEPARTURE, ARRIVAL = 'DEPARTURE', 'ARRIVAL'

            # Create string of all Frequencies
            ATC_FREQUENCIES = create_freq_list_combined(ARRIVAL)
            ATC_TOWER_FREQ, ATC_TOWER_NAME = get_ATC_TOWER(ARRIVAL)

            # Set the content to customize the html
            empty_field = '[ . . . . . . . . . ]'
            html_content = {
                'AIRCRAFT_TYPE': flight_data.get('AIRCRAFT_TYPE', '') or empty_field,
                'CALLSIGN': flight_data.get('CALLSIGN', '') or empty_field,
                'CALLSIGN_SHORT': flight_data.get('CALLSIGN_SHORT', '') or empty_field,
                'FLIGHT_RULES': flight_data.get('FLIGHT_RULES', '') or empty_field,
                'CIRCUIT_ALTITUDE': flight_data.get('CIRCUIT_ALTITUDE', '') or empty_field,
                'ARRIVAL_CITY_ICAO': flight_data.get(f'{ARRIVAL}_ICAO', '') or empty_field,
                'POB': flight_data.get('POB', '') or empty_field,

                'ARRIVAL_NAME': flight_data.get(f'{ARRIVAL}_NAME', '') or empty_field,
                'ARRIVAL_RUNWAY': flight_data.get(f'{ARRIVAL}_RUNWAY', '') or empty_field,
                'ARRIVAL_ROUTE_NAME': flight_data.get(f'{ARRIVAL}_ROUTE_NAME', '') or empty_field,
                'ARRIVAL_ROUTE_ALTITUDE': flight_data.get(f'{ARRIVAL}_ROUTE_ALTITUDE', '') or empty_field,

                'DEPARTURE_ICAO': flight_data.get(f'{DEPARTURE}_ICAO', '') or empty_field,
                'ARRIVAL_ICAO': flight_data.get(f'{ARRIVAL}_ICAO', '') or empty_field,

                'REQUEST_INFORMATION': '' if flight_data.get(f'{ARRIVAL}_CTR', False) else 'REQUEST AERODROME INFORMATION',
                'TEXT_INFORMATION_RECEIVED': TEXT_INFORMATION_RECEIVED() if flight_data.get(f'{ARRIVAL}_CTR', False) else '',

                'ATC_TOWER_NAME': ATC_TOWER_NAME,
                'ATC_TOWER': ATC_TOWER_FREQ,
                'ATC_FREQUENCIES': ATC_FREQUENCIES,
                'GRID_COLUMNS': settings.get('user_select_cols', 1),
            }

            # Prepare CSS content
            fontsizes = settings.get('fontsizes')
            css_content = {
                'FONT_SIZE_TOWER': fontsizes.get('TOWER'),
                'FONT_SIZE_PILOT': fontsizes.get('PILOT'),
                'FONT_SIZE_TITLE': fontsizes.get('TITLE'),
                'FONT_SIZE_SUBTITLE': fontsizes.get('TITLE') - 2,
                'BACKGROUND_COLOR_TITLE': '#258f45',
            }

            # Personalize the html based on the departure and aircraft
            html_string = await personalize_content(html_content, 'ATC_arrival_template.html.j2')
            css_string = await personalize_content(css_content, 'style_template.css.j2')

            # Embed CSS in the HTML content
            html_with_css = f"""
            <style>
            {css_string}
            </style>
            {html_string}
            """

            return html_with_css

        except Exception as e:
            return f"<p>Error generating HTML: {str(e)}</p>"


    async def generate_enroute_html(reverse_path=False):
        """Generate HTML content for enroute screen similar to ATC_ENROUTE."""

        flight_data = js.window.flight_plan_data
        settings = js.window.settings

        try:
            # Set departure and arrival
            if reverse_path:
                DEPARTURE, ARRIVAL = 'ARRIVAL', 'DEPARTURE'
            else:
                DEPARTURE, ARRIVAL = 'DEPARTURE', 'ARRIVAL'

            # Prepare HTML content data (adjust keys as needed)
            empty_field = '[ . . . . . . . . . ]'
            html_content = {
                'AIRCRAFT_TYPE': flight_data.get('AIRCRAFT_TYPE', '') or empty_field,
                'CALLSIGN': flight_data.get('CALLSIGN', '') or empty_field,
                'CALLSIGN_SHORT': flight_data.get('CALLSIGN_SHORT', '') or empty_field,

                'FIC_NAME': flight_data.get('FIC_NAME', '') or empty_field,
                'FIC_FREQUENCY': flight_data.get('FIC_FREQUENCY', ''),
                'FIC_SQUAWK': flight_data.get('SQUAWK', ''),
                'FIC_SQUAWK2': flight_data.get('SQUAWK2', ''),

                'OVERHEAD': flight_data.get('OVERHEAD', flight_data.get(f'{DEPARTURE}_ROUTE_NAME', '') or empty_field),
                'OVERHEAD2': flight_data.get('OVERHEAD2', '') or empty_field,
                'FLIGHT_RULES': flight_data.get('FLIGHT_RULES', ''),
                'POB': flight_data.get('POB', '') or empty_field,

                'DEPARTURE_ICAO': flight_data.get(f'{DEPARTURE}_ICAO', '') or empty_field,
                'DEPARTURE_NAME': flight_data.get(f'{DEPARTURE}_NAME', '') or empty_field,
                'DEPARTURE_ROUTE_ALTITUDE': flight_data.get(f'{DEPARTURE}_ROUTE_ALTITUDE', '') or empty_field,

                'ARRIVAL_ICAO': flight_data.get(f'{ARRIVAL}_ICAO', '') or empty_field,
                'ARRIVAL_NAME': flight_data.get(f'{ARRIVAL}_NAME', '') or empty_field,
                'ATC_FREQUENCIES': create_freq_list_combined([DEPARTURE, ARRIVAL]),
                'GRID_COLUMNS': settings.get('user_select_cols', 1),
            }

            if reverse_path:
                html_content['FIC_NAME'] = flight_data.get('FIC_NAME2', '') or empty_field
                html_content['FIC_FREQUENCY'] = flight_data.get('FIC_FREQUENCY2', '')
                html_content['OVERHEAD'] = flight_data.get('OVERHEAD2', '')
                html_content['FIC_SQUAWK'] = flight_data.get('SQUAWK2', '')

            fontsizes = settings.get('fontsizes')
            css_content = {
                'FONT_SIZE_TOWER': fontsizes.get('TOWER'),
                'FONT_SIZE_PILOT': fontsizes.get('PILOT'),
                'FONT_SIZE_TITLE': fontsizes.get('TITLE'),
                'FONT_SIZE_SUBTITLE': fontsizes.get('TITLE') - 2,
                'BACKGROUND_COLOR_TITLE': '#ec7d15',
            }
            html_string = await personalize_content(html_content, 'ATC_enroute_template.html.j2')
            css_string = await personalize_content(css_content, 'style_template.css.j2')
            html_with_css = f"""
            <style>
            {css_string}
            </style>
            {html_string}
            """
            return html_with_css
        except Exception as e:
            return f"<p>Error generating HTML: {str(e)}</p>"


    def get_ATC_TOWER(fname):
        """Get ATC tower frequency and name for DEPARTURE or ARRIVAL from flight_plan_data."""
        data = js.window.flight_plan_data

        if fname=='DEPARTURE':
            ATC_TOWER_FREQ = data.get('DEPARTURE_ATC_TOWER', '')
            ATC_TOWER_FREQ = ATC_TOWER_FREQ if ATC_TOWER_FREQ not in (None, '') else '???.???'
            ATC_TOWER_NAME = 'TOWER' if data.get('DEPARTURE_CTR') else 'RADIO'
        elif fname=='ARRIVAL':
            ATC_TOWER_FREQ = data.get('ARRIVAL_ATC_TOWER', '')
            ATC_TOWER_FREQ = ATC_TOWER_FREQ if ATC_TOWER_FREQ not in (None, '') else '???.???'
            ATC_TOWER_NAME = 'TOWER' if data.get('ARRIVAL_CTR') else 'RADIO'

        return ATC_TOWER_FREQ, ATC_TOWER_NAME


    def set_fontsizes(params):
        user_usage_type = str(params.user_usage_type if hasattr(params, 'user_usage_type') else 'view')
        user_select_cols = str(params.user_select_cols if hasattr(params, 'user_select_cols') else '1')
        # Change fontsize based on settings
        if 'view' in user_usage_type.lower() and user_select_cols == '1':
            fontsizes = {'TOWER': 14, 'PILOT': 16, 'TITLE': 20}
        elif 'view' in user_usage_type.lower() and (user_select_cols == '2' or user_select_cols == '3'):
            fontsizes = {'TOWER': 12, 'PILOT': 14, 'TITLE': 14}
        elif 'print' in user_usage_type.lower() and (user_select_cols == '2' or user_select_cols == '3'):
            fontsizes = {'TOWER': 16, 'PILOT': 18, 'TITLE': 20}
        else:
            fontsizes = {'TOWER': 20, 'PILOT': 22, 'TITLE': 24}
        return fontsizes


    async def load_template(template_name):
        """Fetch from URL, store in localStorage, and return text content."""
        template_key = f"template_{template_name}"
        base_url = js.window.settings['html_templates']
        url = os.path.join(base_url, template_name)

        #response =  await fetch_and_cache_template(url, template_key)
        # 1. Try cache
        cached = js.localStorage.getItem(template_key)
        if cached:
            print("‚úÖ Loaded from cache")
            return cached

        # 2. Fetch template using JS fetch
        print(f"üåê Fetching from URL: {url}")

        try:
            response = await js.fetch(url)
            if response.ok:
                content = await response.text()  # get the text content
                js.localStorage.setItem(template_key, content)  # store content
                print(f"‚úÖ Template cached under key '{template_key}'")
                return content
            else:
                print(f"‚ùå Fetch failed: {response.status}")
                return None
        except Exception as e:
            print(f"‚ùå Error fetching template: {e}")
            return None


    async def personalize_content(content, template_name):
        # Load template
        template_content = await load_template(template_name)

        # Use DictLoader to store template
        jinja_env = Environment(loader=DictLoader({template_name: template_content}))

        try:
            template = jinja_env.get_template(template_name)
            html_content = template.render(content)
            return html_content
        except Exception as e:
            return f"<p>Error generating HTML: {e}</p>"


    def open_html(html_content, pagename="_blank"):
        logger.info('open_in_browser(html_content)')

        # Inject viewport for mobile if not present
        if "<head>" in html_content and 'name="viewport"' not in html_content:
            html_content = html_content.replace(
                "<head>",
                '<head><meta name="viewport" content="width=device-width, initial-scale=1.0">'
            )
        elif "<head>" not in html_content:
            html_content = (
                '<meta name="viewport" content="width=device-width, initial-scale=1.0">'
                + html_content
            )

        # new_win = window.open("", "_blank")
        new_win = window.open("", pagename)
        if not new_win:
            # blocked
            window.alert("Popup blocked. Try allowing popups for this site.")
            return
        new_win.document.write(html_content)
        new_win.document.close()

    # %%
    def create_freq_list_combined(fname):
        """Create ATC frequency list for both DEPARTURE and ARRIVAL using flight_plan_data."""
        if isinstance(fname, str): fname = [fname]

        data = js.window.flight_plan_data
        settings = js.window.settings
        html_string = ''

        def freq_block(freq, label, city):
            if freq:
                return f'''
                <div style="display: grid; grid-template-columns: 1.5fr 3.5fr;">
                    <p class="pilot_general"><strong>{freq}: </strong></p>
                    <p class="pilot_general">{city} {label}</p>
                </div>
                '''
            return ''

        # DEPARTURE frequencies
        if 'DEPARTURE' in fname:
            dep_city = data.get('DEPARTURE_NAME', '')
            html_string += freq_block(data.get('DEPARTURE_ATC_ATIS_FREQ', ''), 'ATIS', dep_city)
            html_string += freq_block(data.get('DEPARTURE_ATC_GROUND', ''), 'DELIVERY/GROUND', dep_city)
            html_string += freq_block(data.get('DEPARTURE_ATC_TOWER', ''), 'TOWER', dep_city)
            html_string += freq_block(data.get('DEPARTURE_ATC_APPROACH', ''), 'APPROACH', dep_city)
            html_string += freq_block(data.get('DEPARTURE_ATC_TELEPHONE', ''), 'TELEPHONE', dep_city)
            #html_string += freq_block(data.get('DELIVERY_OR_RADIO', ''), 'RADIO', dep_city)

        # Add a horizontal rule between departure and arrival
        if len(fname)>=2:
            html_string += '<hr>'

        # ARRIVAL frequencies
        if 'ARRIVAL' in fname:
            arr_city = data.get('ARRIVAL_NAME', '')
            html_string += freq_block(data.get('ARRIVAL_ATC_ATIS_FREQ', ''), 'ATIS', arr_city)
            html_string += freq_block(data.get('ARRIVAL_ATC_GROUND', ''), 'DELIVERY/GROUND', arr_city)
            html_string += freq_block(data.get('ARRIVAL_ATC_TOWER', ''), 'TOWER', arr_city)
            html_string += freq_block(data.get('ARRIVAL_ATC_APPROACH', ''), 'APPROACH', arr_city)
            html_string += freq_block(data.get('ARRIVAL_ATC_TELEPHONE', ''), 'TELEPHONE', arr_city)
            #html_string += freq_block(data.get('DELIVERY_OR_RADIO_ARR', ''), 'RADIO', arr_city)

        html_string += '<hr>'
        SQUAWK = f": {data.get('SQUAWK', '')}" if data.get('SQUAWK', '') else ''
        SQUAWK2 = f": {data.get('SQUAWK2', '')}" if data.get('SQUAWK2', '') else ''
        html_string += freq_block(data.get('FIC_FREQUENCY', '') , data.get('FIC_NAME', '') + SQUAWK, '')
        html_string += freq_block(data.get('FIC_FREQUENCY2', '') , data.get('FIC_NAME2', '') + SQUAWK2, '')

        return html_string

    # =================================================================
    # FUNCTIONS FOR AIRSPACE PROCESSING
    # =================================================================

    def read_file_from_url(url, verbose=3):
        """Read a text file from a given URL and load it into memory.

        Parameters:
        url (str): URL to the zip file containing the text file.
        url = f'https://erdogant.github.io/datasets/skywalk/areas/Netherlands.zip'

        Returns:
        str: Content of the text file as a string.
        """
        if verbose>=3: print('>Function: read_file_from_url()')
        lines_in_file = []

        if url == '': return None

        try:
            # Get url
            response = requests.get(url)
            if response.status_code == 200 or response.status_code == 502:
                # Open content in memory
                zfs = zipfile.ZipFile(BytesIO(response.content))
                # Assuming there's only one text file in the zip archive
                with zfs.open(zfs.infolist()[0], mode='r') as file:
                    for line in file:
                        # Decode each line from bytes to string, strip whitespace
                        processed_line = line.decode('utf-8').strip()
                        # Process the line as needed (e.g., further parsing or validation)
                        lines_in_file.append(processed_line)

                    # Show succes message
                    logger.info(f'   > File read and processed successfully from URL.')
            else:
                lines_in_file = None
        except Exception as e:
            if verbose>=1: print(f'[Error]> Failed to read file from URL: {str(e)}')
            lines_in_file = None

        # Return
        return lines_in_file


    def import_airspaces(country):
        # URL
        url = f'https://erdogant.github.io/datasets/skywalk/airspaces/{country}.zip'
        #url = f'{js.window.settings['url_airspaces']}{country}.zip'

        # Read airspace file from URL
        lines_in_file = read_file_from_url(url, verbose=3)

        # Return if nothing is available
        if lines_in_file is None:
            return {}

        airspaces = {}
        current_airspace = None
        counter = 0

        for line in lines_in_file:
            line = line.strip()

            if ('Start of airspace' in line) or len(line) < 3:
                # Skip each line until start of airsprace is found
                if counter == 0: counter = counter + 1
                # print(line)

            elif line.startswith('*'):
                # This is a new area so create new key
                # line ='* Danger Area/DANGER//O/C'
                counter += 1
                airspaces[counter] = {'area_type': '', 'area_type_general': '', 'AC': '', 'AN': '', 'AL': '', 'AH': '', 'DP': '', 'coordinates': None}
                airspaces[counter]['area_type'] = line.split(maxsplit=1)[1]
                line = line[1:].split('/', maxsplit=1)
                airspaces[counter]['area_type_general'] = line[0].strip()
            elif line.startswith('AC'):
                airspaces[counter]['type'] = line.split()[1]
            elif line.startswith('AN'):
                airspaces[counter]['name'] = line.split(maxsplit=1)[1]
            elif line.startswith('AL'):
                airspaces[counter]['altitude_lower'] = line.split()[1]
            elif line.startswith('AH'):
                airspaces[counter]['altitude_higher'] = line.split()[1]
            elif line.startswith('DP'):
                # Get the coordinates
                if airspaces[counter].get('coordinates') is None:
                    airspaces[counter]['coordinates'] = []
                lat_lon = line.split(maxsplit=1)[1:]
                lat_lon = extract_lat_lon(lat_lon)
                # Remove None values from latlon
                if lat_lon['latlon'] is not None:
                    lat_lon = [item for item in lat_lon['latlon'] if item is not None]
                    # Store
                    if len(lat_lon) > 0:
                        airspaces[counter]['coordinates'].append(lat_lon)

            elif line.startswith('V'):
                if not airspaces[counter].get('coordinates'):
                    airspaces[counter]['coordinates'] = []

                lat_lon = line.split('X=')[1:]
                lat_lon = extract_lat_lon(lat_lon)

                # Remove None values from latlon
                if lat_lon['latlon'] is not None:
                    lat_lon = [item for item in lat_lon['latlon'] if item is not None]
                    # Store
                    if len(lat_lon) > 0:
                        airspaces[counter]['coordinates'].append(lat_lon)

        # Only keep airspaces with coordinates
        airspaces = {key: value for key, value in airspaces.items() if value['coordinates'] is not None}

        # Sort airspaces by number of latlon coordinates
        # airspaces = dict(sorted(airspaces.items(), key=lambda x: len(x[1]['coordinates']), reverse=True))

        # Combine multiple airspace entries that contain the given keyword in their name
        # if country == 'Netherlands':
        #    airspaces = combine_airspace_by_keyword(airspaces, 'schiphol ctr')

        # Convert the dictionary to a JSON string
        # airspaces_json = json.dumps(airspaces, indent=4)
        return airspaces


    def combine_airspace_by_keyword(airspaces, keyword):
        """Combine multiple airspace entries that contain the given keyword in their name.

        Args:
            airspaces (dict): Dictionary of airspace data
            keyword (str): Keyword to search for in airspace names (case insensitive)

        Returns:
            dict: Updated airspaces dictionary with combined entries
        """
        matching_keys = []
        combined_coords = []

        # Find all keys containing the keyword
        for key, value in airspaces.items():
            if 'name' in value and keyword.lower() in value['name'].lower():
                matching_keys.append(key)
                if value.get('coordinates'):
                    combined_coords.extend(value['coordinates'])

        # If we found multiple matching entries, combine them
        if len(matching_keys) > 1:
            # Keep the first key and update its coordinates
            main_key = matching_keys[0]
            airspaces[main_key]['coordinates'] = combined_coords

            # Remove other matching entries
            for key in matching_keys[1:]:
                airspaces.pop(key, None)

            print(f"‚úÖ Combined {len(matching_keys)} entries containing '{keyword}' into single entry")

        return airspaces


    # Function to extract latitude and longitude from the string
    def extract_lat_lon(string, method=None):
        # string = "52¬∞ 28' 12.00\" N"
        # string = '52:11:08 N 005:12:30 E'
        # string = 'n52 18.84 / e4 48.18'
        # latlon = extract_lat_lon('52:11:08 N 005:12:30 E')
        # latlon = extract_lat_lon('n52 18.84 / e4 48.18')

        if method == 4:
            if len(string.split('/')) > 1:
                s = string.split('/')
                if 'n' in s[0].strip().lower() or 's' in s[0].strip().lower():
                    lat = s[0].strip().replace(' ', ':').replace('.', ':')
                    lat = lat[1:] + ' ' + lat[0].upper()
                if 'e' in s[1].strip().lower() or 'w' in s[1].strip().lower():
                    lon = s[1].strip().replace(' ', ':').replace('.', ':')
                    lon = lon[1:] + ' ' + lon[0].upper()
                string = lat + ' ' + lon


        coord = {'name': None, 'latlon': None}

        if string is None or string == '' or string == []:
            return coord

        if isinstance(string, list): string = string[0]

        # Pattern 1: Extract the desired part of the string
        pattern1 = r"\d+¬∞\d+'\d+\.\d+\"[NS]\s+\d+¬∞\d+'\d+\.\d+\"[EW]"
        matches1 = re.findall(pattern1, string)

        if matches1:
            # Extract name
            start_index = string.index(matches1[0])
            # end_index = string.rindex(matches1[-1]) + len(matches1[-1])
            coord['name'] = string[0:start_index].replace('\xa0', ' ').strip()
            latlon = matches1

            lat_decimal, lon_decimal = [], []
            for lat_lon in latlon:
                # Extract degrees, minutes, and seconds for latitude
                lat_parts = re.findall(r'\d+', lat_lon.split()[0])
                lat_deg = float(lat_parts[0])
                lat_min = float(lat_parts[1])
                lat_sec = float(lat_parts[2] + '.' + lat_parts[3])

                # Extract degrees, minutes, and seconds for longitude
                lon_parts = re.findall(r'\d+', lat_lon.split()[1])
                lon_deg = float(lon_parts[0])
                lon_min = float(lon_parts[1])
                lon_sec = float(lon_parts[2] + '.' + lon_parts[3])

                # Convert DMS to decimal degrees
                lat_dec = dms_to_decimal(lat_deg, lat_min, lat_sec)
                lon_dec = dms_to_decimal(lon_deg, lon_min, lon_sec)

                lat_decimal.append(lat_dec)
                lon_decimal.append(lon_dec)

            coord['latlon'] = np.c_[lat_decimal, lon_decimal]
            if coord['latlon'].shape[0] > 1 and coord['name']=='':
                coord['name']='unknown'

            # Return
            return coord

        # latlon Pattern 2
        pattern2 = r'(\d{6}[NS])\s+(\d{7}[EW])'
        matches2 = re.findall(pattern2, string)

        if matches2:
            lat_decimal, lon_decimal = [], []
            for lat, lon in matches2:
                lat_deg, lat_min, lat_sec = lat[:2], lat[2:4], lat[4:-1]
                lon_deg, lon_min, lon_sec = lon[:3], lon[3:5], lon[5:-1]
                lat_dec = dms_to_decimal(lat_deg, lat_min, lat_sec)
                lon_dec = dms_to_decimal(lon_deg, lon_min, lon_sec)

                if lat[-1] == 'S':
                    lat_dec *= -1
                if lon[-1] == 'W':
                    lon_dec *= -1

                lat_decimal.append(lat_dec)
                lon_decimal.append(lon_dec)

            start_index = string.index(matches2[0][0])
            coord['name'] = string[0:start_index].replace('\xa0', ' ').strip()
            coord['latlon'] = np.c_[lat_decimal, lon_decimal]
            if coord['latlon'].shape[0] > 1 and coord['name']=='':
                coord['name']='unknown'

            # Return
            return coord

        # latlon Pattern 3
        # string = "52¬∞ 28' 12.00\" N"
        pattern3 = r'(\d+)¬∞ (\d+)\' (\d+\.\d+)" ([NSEW])'
        matches3 = re.search(pattern3, string)

        if matches3:
            ldeg = float(matches3.group(1))
            lmin = float(matches3.group(2))
            lsec = float(matches3.group(3))

            # Convert DMS to decimal degrees
            ldec = dms_to_decimal(ldeg, lmin, lsec)

            if matches3.group(4) == 'S':
                ldec *= -1
            if matches3.group(4) == 'W':
                ldec *= -1

            coord = {'name': string, 'latlon': ldec}
            # Return
            return coord

        # latlon Pattern 4
        # '52:11:08 N 005:12:30 E'
        pattern = r'(\d+:\d+:\d+) ([NS]) (\d+:\d+:\d+) ([EW])'
        matches = re.search(pattern, string)
        if matches:
            # Conert latitude to decimals
            degrees, minutes, seconds = matches.group(1).split(':')
            lat_decimal = dms_to_decimal(degrees, minutes, seconds, matches.group(2))
            # Conert longitude to decimals
            degrees, minutes, seconds = matches.group(3).split(':')
            lon_decimal = dms_to_decimal(degrees, minutes, seconds, matches.group(4))
            # Create coordinates
            coord = {'name': matches.group(1) + ' ' + matches.group(2) + ' ' + matches.group(3) + ' ' + matches.group(4) , 'latlon':  [lat_decimal, lon_decimal]}
            # Return
            return coord


        # latlon Pattern 5
        # string = "5342N00629E002"
        # string = '5255N00454E001'
        pattern = r'(\d{2})(\d{2})([NS])(\d{3})(\d{2})([EW])\d{3}'
        # 51.44161977603219, 3.5849333938063817
        match = re.search(pattern, string)
        if match:
            # Extract degrees, minutes, and seconds for latitude and longitude
            lat_degrees = int(match.group(1))
            lat_minutes = int(match.group(2))
            lat_direction = match.group(3)
            # lat_decimal = lat_degrees + (lat_minutes/100)
            # if lat_direction == 'S': lat_decimal *= -1

            lon_degrees = int(match.group(4))
            lon_minutes = int(match.group(5))
            lon_direction = match.group(6)
            # lon_decimal = lon_degrees + (lon_minutes/100)
            # if lon_direction == 'W': lon_decimal *= -1

            # Convert degrees and minutes to decimal
            lat_decimal = dms_to_decimal(lat_degrees, lat_minutes, 0, direction=lat_direction)
            lon_decimal = dms_to_decimal(lon_degrees, lon_minutes, 0, direction=lon_direction)

            # Create dict.
            coord = {'name': match.group(1) + ' ' + match.group(2) + ' ' + match.group(4) + ' ' + match.group(5) , 'latlon': [lat_decimal, lon_decimal]}

            # Return
            return coord


    def dms_to_decimal(degrees, minutes, seconds, direction=None):
        dec = float(degrees) + (float(minutes) / 60) + (float(seconds) / 3600)
        if direction == 'S':
            dec *= -1
        if direction == 'W':
            dec *= -1
        return dec


    def clean_altitude(altitude):
        # print(altitude)
        altitude = str(altitude).upper().replace("`",'').strip()
        altitude = altitude.split('/')[-1]

        if altitude is None or altitude=='' or altitude == 'NONE':
            pass
        elif 'AFL' in altitude:
            # likely stands for "500 feet Above Field Level.
            altitude = altitude.replace('AFL','')
        elif 'ALT' in altitude:
            altitude = altitude.replace('ALT','')
        elif 'AGL' in altitude:
            altitude = altitude.replace('AGL','')
        elif 'MSL' in altitude:
            altitude = altitude.replace('MSL','')
        elif 'UNL' in altitude:
            # unlimited, to the sky
            altitude = None
        elif 'SFC' in altitude:
            # surface is from the floor
            altitude = None
        elif 'FT' in altitude:
            altitude = altitude.replace('FT','')
        elif altitude[0:2] == 'FL':
            altitude = altitude.replace('FL','')
            if altitude == '': altitude = 0
            altitude = int(altitude) * 100
        elif 'FO' in altitude:
            altitude = altitude.replace('FO','')
            if altitude == '': altitude = 0
            altitude = int(altitude) * 100
        elif altitude[-1] == 'M':
            altitude = int(altitude[:-1]) * 3.28084
        elif altitude[-1] == 'A':
            # above ground level, it means an altitude of 500 feet above the terrain or surface beneath the aircraft.
            altitude = int(altitude[:-1])
        elif altitude[-1] == 'F':
            altitude = altitude.replace('F','')

        if altitude == '' or altitude is None or altitude == 'NONE':
            altitude = None
        else:
            altitude = int(altitude)

        return altitude


    def altitude_restriction(AL, AH, max_altitude):
        # If the altitude is 0. Always return True
        if max_altitude == 0:
            return True, None

        in_airspace = False
        loc_airspace = ''

        # Set the altitude
        if AH is None and AL is None:
            # print("Both upper and lower limits of the airspace are not defined.")
            loc_airspace = None

        if AH is not None and AL is not None:
            if AL <= max_altitude <= AH:
                in_airspace = True
                loc_airspace = 'in'
            elif max_altitude < AL:
                loc_airspace = 'below'
            elif max_altitude > AH:
                loc_airspace = 'above'
        elif AH is None and AL is not None:
            if max_altitude >= AL:
                loc_airspace = 'in'
                in_airspace = True
            else:
                loc_airspace = 'below'
        elif AH is not None and AL is None:
            if max_altitude <= AH:
                loc_airspace = 'in'
                in_airspace = True
            else:
                loc_airspace = 'above'

        # if loc_airspace == 'in':
        #     print('Flight is in airspace')
        return in_airspace, loc_airspace



    # =================================================================
    # Make functions available to JavaScript
    # =================================================================

    js.window.create_new_flightplan = create_new_flightplan
    js.window.load_flightplan = load_flightplan
    js.window.delete_flightplan = delete_flightplan
    js.window.save_flightplan = save_flightplan
    js.window.load_enroute_fic = load_enroute_fic
    js.window.delete_enroute_fic = delete_enroute_fic
    js.window.save_enroute_to_json = save_enroute_to_json
    js.window.save_aerodrome_to_json = save_aerodrome_to_json
    js.window.load_aerodrome_from_json = load_aerodrome_from_json
    js.window.clear_cache = clear_cache
    js.window.get_top_metar_stations = get_top_metar_stations

    # ATC
    js.window.create_summary_atc = create_proxy(create_summary_atc)
    js.window.create_departure_atc = create_proxy(create_departure_atc)
    js.window.create_arrival_atc = create_proxy(create_arrival_atc)
    js.window.create_enroute_atc = create_proxy(create_enroute_atc)

    # HELPERS
    js.window.create_callsign_short = create_proxy(create_callsign_short)
    js.window.import_country_selected = create_proxy(import_country_selected)
    js.window.generate_summary_html = create_proxy(generate_summary_html)
    js.window.set_fontsizes = create_proxy(set_fontsizes)

    # GENERAL TAB
    js.window.clear_general_fields = clear_general_fields

    # DEPARTURE/ARRIVAL TAB
    js.window.populate_aerodrome_fields_from_icao = create_proxy(populate_aerodrome_fields_from_icao)
    js.window.update_aerodrome_gui_fields = update_aerodrome_gui_fields
    js.window.update_general_gui_fields = update_general_gui_fields
    js.window.update_enroute_gui_fields = update_enroute_gui_fields
    js.window.update_aerodrome_image = update_aerodrome_image

    # CLEAR FIELDS
    js.window.clear_aerodrome_fields = clear_aerodrome_fields
    js.window.clear_aerodrome_image = clear_aerodrome_image
    js.window.clear_enroute_fields = clear_enroute_fields

    js.window.cache_and_display_image = cache_and_display_image

    # DATA FUNCTIONS
    js.window.get_default_data = get_default_data
    js.window.get_default_settings = get_default_settings

    # FLIGHTPLAN LIST IN CACHE
    update_dropdown_flightplans()

    # FIC LIST IN CACHE
    update_dropdown_enroute_FIC()

    # AIRSPACE
    js.window.import_airspaces = import_airspaces
    js.window.altitude_restriction = altitude_restriction
    js.window.clean_altitude = clean_altitude
    js.window.altitude_restriction = altitude_restriction

    # METAR HELPERS
    js.window.expected_runway_number = expected_runway_number

  </script>


  <!-- Vanilla JS for tabs and flightplan buttons -->
  <script>
    const tabButtons = document.querySelectorAll(".tablinks");
    const tabContents = document.querySelectorAll(".tabcontent");

    // Function to check for missing fields and update highlighting
    function highlightMissingFields() {
        console.log("---> highlightMissingFields()");
        const inputs = [
          CALLSIGN,
          AIRCRAFT_TYPE,
          POB,
          FLIGHTPLAN,
          DEPARTURE_NAME,
          DEPARTURE_ICAO,
          DEPARTURE_POSITION,
          DEPARTURE_ATC_GROUND,
          DEPARTURE_ATC_ATIS_FREQ,
          DEPARTURE_ATC_TOWER,
          DEPARTURE_ROUTE_ALTITUDE,
          DEPARTURE_ROUTE_NAME,
          DEPARTURE_RUNWAY,
          ARRIVAL_NAME,
          ARRIVAL_ICAO,
          ARRIVAL_RUNWAY,
          ARRIVAL_ROUTE_NAME,
          ARRIVAL_ROUTE_ALTITUDE,
          ARRIVAL_CIRCUIT_ALTITUDE,
          ARRIVAL_ATC_TOWER,
          FIC_NAME,
          FIC_FREQUENCY,
          OVERHEAD,
          SQUAWK,
        ];

        // Reset all backgrounds first
        inputs.forEach(input => input.style.backgroundColor = '');

        const missing = [];
        if (!FLIGHTPLAN.value) { missing.push('Flightplan Name'); FLIGHTPLAN.style.backgroundColor = '#ffeb3b'; }
        if (!CALLSIGN.value) { missing.push('CALLSIGN'); CALLSIGN.style.backgroundColor = '#ffeb3b'; }
        if (!AIRCRAFT_TYPE.value) { missing.push('Aircraft Type'); AIRCRAFT_TYPE.style.backgroundColor = '#ffeb3b'; }
        if (!POB.value) { missing.push('POB'); POB.style.backgroundColor = '#ffeb3b'; }

        if (!DEPARTURE_NAME.value) { missing.push('Aerodrome Name (Dep.)'); DEPARTURE_NAME.style.backgroundColor = '#ffeb3b'; }
        if (!DEPARTURE_ICAO.value) { missing.push('ICAO (Dep.)'); DEPARTURE_ICAO.style.backgroundColor = '#ffeb3b'; }
        if (!DEPARTURE_POSITION.value) { missing.push('Position (Dep.)'); DEPARTURE_POSITION.style.backgroundColor = '#ffeb3b'; }
        if (!DEPARTURE_RUNWAY.value) { missing.push('Runway (Dep.)'); DEPARTURE_RUNWAY.style.backgroundColor = '#ffeb3b'; }
        if (!DEPARTURE_ROUTE_NAME.value) { missing.push('Route Name (Dep.)'); DEPARTURE_ROUTE_NAME.style.backgroundColor = '#ffeb3b'; }
        if (!DEPARTURE_ROUTE_ALTITUDE.value) { missing.push('Route Altitude (Dep.)'); DEPARTURE_ROUTE_ALTITUDE.style.backgroundColor = '#ffeb3b'; }
        if (!DEPARTURE_ATC_TOWER.value) { missing.push('Freq. Tower/Radio (Dep.)'); DEPARTURE_ATC_TOWER.style.backgroundColor = '#ffeb3b'; }
        if (DEPARTURE_CTR.value === 'CTR') {
            if (!DEPARTURE_ATC_ATIS_FREQ.value) { missing.push('Freq. ATIS (Dep.)'); DEPARTURE_ATC_ATIS_FREQ.style.backgroundColor = '#ffeb3b'; }
            if (!DEPARTURE_ATC_GROUND.value) { missing.push('Freq. Delivery/Ground (Dep.)'); DEPARTURE_ATC_GROUND.style.backgroundColor = '#ffeb3b'; }
        }

        if (!ARRIVAL_NAME.value) { missing.push('Aerodrome Name (Arr.)'); ARRIVAL_NAME.style.backgroundColor = '#ffeb3b'; }
        if (!ARRIVAL_ICAO.value) { missing.push('ICAO (Arr.)'); ARRIVAL_ICAO.style.backgroundColor = '#ffeb3b'; }
        if (!ARRIVAL_RUNWAY.value) { missing.push('Runway (Arr.)'); ARRIVAL_RUNWAY.style.backgroundColor = '#ffeb3b'; }
        if (!ARRIVAL_ROUTE_NAME.value) { missing.push('Route Name (Arr.)'); ARRIVAL_ROUTE_NAME.style.backgroundColor = '#ffeb3b'; }
        if (!ARRIVAL_ROUTE_ALTITUDE.value) { missing.push('Route Altitude (Arr.)'); ARRIVAL_ROUTE_ALTITUDE.style.backgroundColor = '#ffeb3b'; }
        if (!ARRIVAL_CIRCUIT_ALTITUDE.value) { missing.push('Route Altitude (Arr.)'); ARRIVAL_CIRCUIT_ALTITUDE.style.backgroundColor = '#ffeb3b'; }
        if (!ARRIVAL_ATC_TOWER.value) { missing.push('Freq. Tower/Radio (Arr.)'); ARRIVAL_ATC_TOWER.style.backgroundColor = '#ffeb3b'; }

        if (!FIC_NAME.value) { missing.push('FIC name'); FIC_NAME.style.backgroundColor = '#ffeb3b'; }
        if (!FIC_FREQUENCY.value) { missing.push('FIC Freq.'); FIC_FREQUENCY.style.backgroundColor = '#ffeb3b'; }
        if (!OVERHEAD.value) { missing.push('Overhead point.'); OVERHEAD.style.backgroundColor = '#ffeb3b'; }
        if (!SQUAWK.value) { missing.push('SQUAWK.'); SQUAWK.style.backgroundColor = '#ffeb3b'; }

        missing_label.textContent = missing.length ? 'Missing: ' + missing.join(', ') : 'All fields are OK! Create your ATC now.';
        if (!missing.length) {
          missing_label.style.fontSize = '12px';
          missing_label.style.color = 'green';
        } else {
          missing_label.style.fontSize = '';
          missing_label.style.color = '';
        }
    }

    // Function to replace INFORMATION with INFO in input fields
    function updateEnrouteFields() {
        document.querySelectorAll('.REPLACE_INFO').forEach(input => {
            if (input.value) {
                input.value = input.value.toUpperCase().replace(/INFORMATION/g, 'INFO');
            }
        });
    }

    tabButtons.forEach(btn => {
      btn.addEventListener("click", async () => {
        // Get the tab we're switching TO
        const targetTab = btn.getAttribute("data-tab");

        // Get the CURRENT active tab (before switching)
        const currentActiveTab = document.querySelector(".tablinks.active");
        const currentTab = currentActiveTab ? currentActiveTab.getAttribute("data-tab") : null;

        // Save data when switching tabs
        // if (pyscriptReady && window.save_flightplan && currentTab && currentTab !== targetTab) {
        //   try {
        //     await window.save_flightplan();
        //   } catch (error) {
        //     console.error("Error saving data before tab switch:", error);
        //   }
        // }

        // Switch tabs
        tabButtons.forEach(b => b.classList.remove("active"));
        tabContents.forEach(c => c.style.display = "none");
        btn.classList.add("active");
        document.getElementById(btn.getAttribute("data-tab")).style.display = "block";

        // REPLACE INFORMATION with "INFO" in the ENROUTE TAB.
        updateEnrouteFields();
        // CHECK MISSING FIELDS AFTER TAB SWITCH AND HIGHLIGHT
        highlightMissingFields();

        // WHEN THE TAB MAP IS CLICKED
        if (targetTab === "MAP") {
          if (typeof initRouteMap === "function") initRouteMap();
          if (typeof updateRoute === "function") updateRoute();
        }

      });
    });

    // Flightplan elements
    const CALLSIGN = document.getElementById('CALLSIGN');
    const AIRCRAFT_TYPE = document.getElementById('AIRCRAFT_TYPE');
    const POB = document.getElementById('POB');
    const FLIGHTPLAN = document.getElementById('FLIGHTPLAN');
    const DATETIME = document.getElementById('DATETIME');
    const FLIGHT_RULES = document.getElementById('FLIGHT_RULES');

    // Create buttons at the START page
    const new_plan_btn = document.getElementById('new_plan_btn');
    const delete_btn = document.getElementById('delete_btn');
    const fic_delete_btn = document.getElementById('fic_delete_btn');
    const fic_save_btn = document.getElementById('fic_save_btn');
    const fic_save_btn2 = document.getElementById('fic_save_btn2');


    // const retrieve_metar_btn = document.getElementById('retrieve_metar_btn');

    // Create buttons to generate ATC at the ATC page
    const BTN_HTML_SUMMARY = document.getElementById('BTN_HTML_SUMMARY');
    const BTN_HTML_SUMMARY_REV = document.getElementById('BTN_HTML_SUMMARY_REV');
    const BTN_HTML_DEPARTURE = document.getElementById('BTN_HTML_DEPARTURE');
    const BTN_HTML_DEPARTURE_REV = document.getElementById('BTN_HTML_DEPARTURE_REV');
    const BTN_HTML_ARRIVAL = document.getElementById('BTN_HTML_ARRIVAL');
    const BTN_HTML_ARRIVAL_REV = document.getElementById('BTN_HTML_ARRIVAL_REV');
    const BTN_HTML_ENROUTE = document.getElementById('BTN_HTML_ENROUTE');
    const BTN_HTML_ENROUTE_REV = document.getElementById('BTN_HTML_ENROUTE_REV');

    // Missing labels
    const missing_label = document.getElementById('missing_label');

    // Uppercase for all fields with class="UPPERCASE_input"
    document.querySelectorAll('.UPPERCASE_input').forEach(input => {
    input.addEventListener('input', () => {
        input.value = input.value.toUpperCase();
        });
    });

    document.querySelectorAll('.REPLACE_INFO').forEach(input => {
        input.addEventListener('input', () => {
            input.value = input.value.toUpperCase().replace(/INFORMATION/g, 'INFO');
            highlightMissingFields();
        });
    });


    // Initial calls to handle any existing values
    updateEnrouteFields();
    highlightMissingFields();

    // Wait for PyScript to be ready
    let pyscriptReady = false;

    function restoreSettingsFromCache() {
      /**
       * Restores user interface settings from browser localStorage if they exist
       * and updates font sizes accordingly.
       *
       * Specifically:
       * - Restores user_usage_type setting from localStorage
       * - Restores user_select_cols setting from localStorage
       * - Updates corresponding UI elements with restored values
       * - Updates font sizes based on restored settings
       *
       * If settings don't exist in localStorage, default values will be used.
       * Any errors during restoration are caught and logged to console.
       */
        try {
            // Restore settings from localStorage if they exist
            const savedUsageType = localStorage.getItem('user_usage_type');
            const savedColumns = localStorage.getItem('user_select_cols');

            if (savedUsageType) {
                window.settings.user_usage_type = savedUsageType;
                const usageTypeElement = document.getElementById('user_usage_type');
                if (usageTypeElement) {
                    usageTypeElement.value = savedUsageType;
                }
            }
            if (savedColumns) {
                window.settings.user_select_cols = savedColumns;
                const columnsElement = document.getElementById('user_select_cols');
                if (columnsElement) {
                    columnsElement.value = savedColumns;
                }
            }

            // Update font sizes with possibly restored settings
            if (window.settings && window.set_fontsizes) {
                window.settings.fontsizes = window.set_fontsizes({
                    user_usage_type: window.settings.user_usage_type,
                    user_select_cols: window.settings.user_select_cols
                });
            }
        } catch (error) {
            console.error('Error restoring settings:', error);
        }
    }

    // INITIALIZATOIN WHEN PYSCRIPT IS READY
    function checkPyScriptReady() {
      /**
       * Checks if PyScript is finished loading by testing if key functions are available.
       * Also initializes default flight plan data and settings if PyScript is ready.
       *
       * Key initializations:
       * - Sets window.flight_plan_data with default values
       * - Sets window.settings with default settings
       * - Restores cached display settings
       * - Hides loading spinner once complete
       *
       */
      if (typeof window.create_new_flightplan === 'function') {
        pyscriptReady = true;
        console.log("PyScript is ready!");
        // Get default flight plan data
        window.flight_plan_data = window.get_default_data();
        console.log("Default data is initialized.");
        // Get default settings
        window.settings = window.get_default_settings();
        console.log("Settings data is initialized.");
        // Restore settings from cache
        restoreSettingsFromCache();
        console.log("Display settings data is restored from cache.");
        // Hide loading spinner once everything is ready
        document.getElementById('loading-spinner').style.display = 'none';
      }
    }

    // Check periodically for PyScript
    const checkInterval = setInterval(() => {
      checkPyScriptReady();
      if (pyscriptReady) {
        clearInterval(checkInterval);
      }
    }, 100);

    // Connect PyScript functions to button clicks
    new_plan_btn.onclick = async () => {
      try {
        // Check if PyScript is ready
        if (!pyscriptReady) return alert("Please wait, SkyWalk is initializing..");

        // Uncheck the airspace toggle
        const airspaceToggle = document.getElementById('airspace-toggle');
        if (airspaceToggle) {
          airspaceToggle.checked = false;
          // Trigger the change event to ensure the map updates
          airspaceToggle.dispatchEvent(new Event('change'));
        }

        // Clear all input fields and departure fields
        await clear_general_fields();
        DATETIME.value = await window.create_new_flightplan();

        // Store default flight plan data
        window.flight_plan_data = await window.get_default_data();

        // Clear plan spinner selection
        document.getElementById('plan_spinner').value = "";
        document.getElementById('fic_spinner').value = "";
        document.getElementById('fic_spinner2').value = "";
        // Update missing fields
        highlightMissingFields();
        // Show success message to user
        alert("‚úÖ New flightplan created successfully!\n\nAll fields have been cleared and reset to default values.");

      } catch (error) {
        console.error("Error creating new flightplan:", error);
        alert("Error creating new flightplan. Please try again.");
      }
    };

    // Auto-load functionality moved to plan_spinner onChange event
    document.getElementById('plan_spinner').addEventListener('change', async (e) => {
      if (e.target.value && pyscriptReady && window.load_flightplan) {
        try {
          await window.load_flightplan();
          console.log("‚úÖ Flightplan loaded successfully");
          // Update missing fields after loading
          highlightMissingFields();
        } catch (error) {
          console.error("Error loading flightplan:", error);
          alert("Error loading flightplan: " + error);
        }
      }
    });

    delete_btn.onclick = async () => {
      if (pyscriptReady && window.delete_flightplan) {
        await window.delete_flightplan();
      }
    };

    document.getElementById('fic_delete_btn')?.addEventListener('click', async () => {
      if (pyscriptReady && window.delete_enroute_fic) {
        await window.delete_enroute_fic('fic_spinner');
      }
    });

    document.getElementById('fic_delete_btn2')?.addEventListener('click', async () => {
      if (pyscriptReady && window.delete_enroute_fic) {
        await window.delete_enroute_fic('fic_spinner2');
      }
    });

    // Add save button functionality
    document.getElementById('fic_save_btn')?.addEventListener('click', () => {
      if (pyscriptReady && window.save_flightplan) {
        try {
            // Save FIC data to JSON files
            window.save_enroute_to_json('ENROUTE1');
            window.alert("‚úì FIC is saved on local device");
        } catch (error) {
          console.error("Error saving FIC data:", error);
        }
      }
    });

    // Add save button functionality
    document.getElementById('fic_save_btn2')?.addEventListener('click', () => {
      if (pyscriptReady && window.save_flightplan) {
        try {
            // Save FIC data to JSON files
            window.save_enroute_to_json('ENROUTE2');
            window.alert("‚úì FIC2 is saved on local device");
        } catch (error) {
          console.error("Error saving FIC2 data:", error);
        }
      }
    });

    // DEPARTURE_USE_CACHED.onclick = async () => {
    //   if (pyscriptReady && window.load_aerodrome_from_json) {
    //     console.log("‚úÖ ---> load_aerodrome_from_json('DEPARTURE')");
    //     await window.load_aerodrome_from_json('DEPARTURE');
    //   }
    // };

    // retrieve_metar_btn.onclick = async () => {
    //   if (pyscriptReady && window.retrieve_metar) {
    //     await window.retrieve_metar('DEPARTURE');
    //   }
    // };



    document.getElementById('BTN_HTML_SUMMARY')?.addEventListener('click', () => {
      if (window.create_summary_atc) {
        window.save_flightplan({to_cache: true})
        window.create_summary_atc();
      }
    });
    document.getElementById('BTN_HTML_SUMMARY_REV')?.addEventListener('click', () => {
      if (window.create_summary_atc) {
        window.save_flightplan({to_cache: true})
        window.create_summary_atc({ reverse_path: true });
      }
    });

    document.getElementById('BTN_HTML_DEPARTURE')?.addEventListener('click', () => {
      if (window.create_departure_atc) {
        window.save_flightplan({to_cache: true})
        window.create_departure_atc();
      }
    });
    document.getElementById('BTN_HTML_DEPARTURE_REV')?.addEventListener('click', () => {
      if (window.create_departure_atc) {
        window.save_flightplan({to_cache: true})
        window.create_departure_atc({ reverse_path: true });
      }
    });

    document.getElementById('BTN_HTML_ARRIVAL')?.addEventListener('click', () => {
      if (window.create_arrival_atc) {
        window.save_flightplan({to_cache: true})
        window.create_arrival_atc();
      }
    });
    document.getElementById('BTN_HTML_ARRIVAL_REV')?.addEventListener('click', () => {
      if (window.create_arrival_atc) {
        window.save_flightplan({to_cache: true})
        window.create_arrival_atc({ reverse_path: true });
      }
    });

    document.getElementById('BTN_HTML_ENROUTE')?.addEventListener('click', () => {
      if (window.create_enroute_atc) {
        window.save_flightplan({to_cache: true})
        window.create_enroute_atc();
      }
    });
    document.getElementById('BTN_HTML_EN_REV')?.addEventListener('click', () => {
      if (window.create_enroute_atc) {
        window.save_flightplan({to_cache: true})
        window.create_enroute_atc({ reverse_path: true });
      }
    });

    // Add clear cache button handler
    document.getElementById('clear_cache_btn')?.addEventListener('click', async () => {
      /**
      * Clears the browser's cached data and reloads the page.
      * Shows a confirmation dialog before clearing.
      * Displays a loading spinner while clearing.
      *
      * Steps:
      * 1. Shows confirmation dialog
      * 2. If confirmed:
      *   - Shows loading spinner
      *   - Calls window.clear_cache()
      *   - On success: Shows success message and reloads page
      *   - On error: Shows error message
      * 3. Always hides spinner when complete
      *
      */
        if (!confirm('This will clear all saved (cached) data. Are you sure?')) return;

        const spinner = document.getElementById('loading-spinner');
        const spinnerText = spinner.querySelector('.spinner-text');
        spinnerText.textContent = 'Clearing cache...';
        spinner.style.display = 'flex';

        try {
            if (await window.clear_cache()) {
                alert('Cache cleared successfully! The page will now reload.');
                location.reload();
            } else { alert('Error clearing cache. Please try again.'); }
        } catch (error) {
            alert('Error clearing cache: ' + error);
        } finally {
            spinner.style.display = 'none';
        }
    });

    const inputs = [
      CALLSIGN,
      AIRCRAFT_TYPE,
      POB,
      FLIGHTPLAN,
      DEPARTURE_ATC_TOWER,
      DEPARTURE_ATC_ATIS_FREQ,
      DEPARTURE_ATC_GROUND,
      DEPARTURE_ROUTE_ALTITUDE,
      DEPARTURE_ROUTE_NAME,
      DEPARTURE_RUNWAY,
      DEPARTURE_POSITION,
      DEPARTURE_NAME,
      DEPARTURE_ICAO,
      ARRIVAL_NAME,
      ARRIVAL_ICAO,
      ARRIVAL_RUNWAY,
      ARRIVAL_ROUTE_NAME,
      ARRIVAL_ROUTE_ALTITUDE,
      ARRIVAL_CIRCUIT_ALTITUDE,
      ARRIVAL_ATC_TOWER,
      FIC_NAME,
      FIC_FREQUENCY,
      OVERHEAD,
      SQUAWK,
    ];
      inputs.forEach(input => {
        input.addEventListener('input', () => {
          const missing = [];
          // Reset all backgrounds first
          inputs.forEach(inp => inp.style.backgroundColor = '');

          if (!FLIGHTPLAN.value) { missing.push('Flightplan Name'); FLIGHTPLAN.style.backgroundColor = '#ffeb3b'; }
          if (!CALLSIGN.value) { missing.push('CALLSIGN'); CALLSIGN.style.backgroundColor = '#ffeb3b'; }
          if (!AIRCRAFT_TYPE.value) { missing.push('Aircraft Type'); AIRCRAFT_TYPE.style.backgroundColor = '#ffeb3b'; }
          if (!POB.value) { missing.push('POB'); POB.style.backgroundColor = '#ffeb3b'; }

          if (!DEPARTURE_NAME.value) { missing.push('Aerodrome Name (Dep.)'); DEPARTURE_NAME.style.backgroundColor = '#ffeb3b'; }
          if (!DEPARTURE_ICAO.value) { missing.push('ICAO (Dep.)'); DEPARTURE_ICAO.style.backgroundColor = '#ffeb3b'; }
          if (!DEPARTURE_POSITION.value) { missing.push('Position (Dep.)'); DEPARTURE_POSITION.style.backgroundColor = '#ffeb3b'; }
          if (!DEPARTURE_RUNWAY.value) { missing.push('Runway (Dep.)'); DEPARTURE_RUNWAY.style.backgroundColor = '#ffeb3b'; }
          if (!DEPARTURE_ROUTE_NAME.value) { missing.push('Route Name (Dep.)'); DEPARTURE_ROUTE_NAME.style.backgroundColor = '#ffeb3b'; }
          if (!DEPARTURE_ROUTE_ALTITUDE.value) { missing.push('Route Altitude (Dep.)'); DEPARTURE_ROUTE_ALTITUDE.style.backgroundColor = '#ffeb3b'; }
          if (!DEPARTURE_ATC_TOWER.value) { missing.push('Freq. Tower/Radio (Dep.)'); DEPARTURE_ATC_TOWER.style.backgroundColor = '#ffeb3b'; }
          if (!SQUAWK.value) { missing.push('SQUAWK.'); SQUAWK.style.backgroundColor = '#ffeb3b'; }
          if (DEPARTURE_CTR.value === 'CTR') {
              if (!DEPARTURE_ATC_ATIS_FREQ.value) { missing.push('Freq. ATIS (Dep.)'); DEPARTURE_ATC_ATIS_FREQ.style.backgroundColor = '#ffeb3b'; }
              if (!DEPARTURE_ATC_GROUND.value) { missing.push('Freq. Delivery/Ground (Dep.)'); DEPARTURE_ATC_GROUND.style.backgroundColor = '#ffeb3b'; }
          }

          if (!ARRIVAL_NAME.value) { missing.push('Aerodrome Name (Arr.)'); ARRIVAL_NAME.style.backgroundColor = '#ffeb3b'; }
          if (!ARRIVAL_ICAO.value) { missing.push('ICAO (Arr.)'); ARRIVAL_ICAO.style.backgroundColor = '#ffeb3b'; }
          if (!ARRIVAL_RUNWAY.value) { missing.push('Runway (Arr.)'); ARRIVAL_RUNWAY.style.backgroundColor = '#ffeb3b'; }
          if (!ARRIVAL_ROUTE_NAME.value) { missing.push('Route Name (Arr.)'); ARRIVAL_ROUTE_NAME.style.backgroundColor = '#ffeb3b'; }
          if (!ARRIVAL_ROUTE_ALTITUDE.value) { missing.push('Route Altitude (Arr.)'); ARRIVAL_ROUTE_ALTITUDE.style.backgroundColor = '#ffeb3b'; }
          if (!ARRIVAL_CIRCUIT_ALTITUDE.value) { missing.push('Route Altitude (Arr.)'); ARRIVAL_CIRCUIT_ALTITUDE.style.backgroundColor = '#ffeb3b'; }
          if (!ARRIVAL_ATC_TOWER.value) { missing.push('Freq. Tower/Radio (Arr.)'); ARRIVAL_ATC_TOWER.style.backgroundColor = '#ffeb3b'; }

          if (!FIC_NAME.value) { missing.push('FIC name'); FIC_NAME.style.backgroundColor = '#ffeb3b'; }
          if (!FIC_FREQUENCY.value) { missing.push('FIC Freq.'); FIC_FREQUENCY.style.backgroundColor = '#ffeb3b'; }
          if (!OVERHEAD.value) { missing.push('Overhead point.'); OVERHEAD.style.backgroundColor = '#ffeb3b'; }

          missing_label.textContent = missing.length ? 'Missing: ' + missing.join(', ') : 'All fields are OK! Create your ATC now.';
        });
      });
  </script>

</body>
</html>




<script>
const COUNTRIES_DATA = [
  // Europe
  'Albania', 'Austria', 'Belarus', 'Belgium',
  'Bulgaria', 'Croatia', 'Cyprus', 'Czech Republic', 'Denmark', 'Estonia',
  'Finland', 'France', 'Germany', 'Greece', 'Hungary', 'Iceland', 'Ireland',
  'Italy', 'Luxembourg', 'Malta',
  'Moldova  Republic Of', 'Montenegro', 'Netherlands',
  'Norway', 'Poland', 'Portugal', 'Romania',
  'Spain', 'Sweden', 'Switzerland', 'Turkey',
  'United Kingdom',

  // Other
  'Maldives',

  // Americas (North, Central, South, Caribbean)
  'Canada', 'Curacao', 'United States',

  // Oceania
  'Australia', 'New Zealand',
];

  function populateDropdown(selectId, dataArray) {
    const select = document.getElementById(selectId);
    if (!select) {
      console.warn(`Select element with ID '${selectId}' not found`);
      return;
    }
    dataArray.forEach(item => {
      const option = document.createElement('option');
      option.value = item;
      option.textContent = item;
      select.appendChild(option);
    });
  }
</script>


<script>
    function initializeAerodromeFields(fname) {
        // Populate dropdown on page load
        window.addEventListener('DOMContentLoaded', () => {
            populateDropdown(`${fname}_COUNTRY`, COUNTRIES_DATA);
        });

        // Download the aerodrome data when the country changes
        document.getElementById(`${fname}_COUNTRY`).addEventListener("change", async function() {
            const country = this.value;
            if (country && window.import_country_selected) {
                const spinner = document.getElementById('loading-spinner');
                const spinnerText = spinner.querySelector('.spinner-text');
                spinnerText.textContent = `Loading aerodrome data for ${country}...`;
                spinner.style.display = 'flex';
                document.body.style.cursor = 'wait';
                document.body.style.overflow = 'hidden';  // Prevent scrolling while loading
                try {
                    await window.import_country_selected(fname, country);
                } catch (error) {
                    console.error("Error importing aerodrome data:", error);
                    alert("Error loading aerodrome data. Please try again.");
                } finally {
                    spinner.style.display = 'none';
                    document.body.style.cursor = '';
                    document.body.style.overflow = '';  // Restore scrolling
                }
            }
        });

        // Populate fields when ICAO city is selected
        document.getElementById(`${fname}_ICAO_CITY`).addEventListener("change", async function() {
            const city_icao = this.value;

            // Clear all aerodrome fields first to prevent data leakage
            if (window.clear_aerodrome_fields) {
                await window.clear_aerodrome_fields(fname);
            }
            // Clear all enroute fields first to prevent data leakage
            if (fname === 'DEPARTURE' && window.clear_enroute_fields) {
                await window.clear_enroute_fields();
            }

            if (city_icao && window.populate_aerodrome_fields_from_icao) {
                // Call PyScript function to populate fields
                await window.populate_aerodrome_fields_from_icao(fname, city_icao);
                // Update missing fields
                highlightMissingFields();
            }
        });

        // Auto-save aerodrome data when fields change
        const fields = [
            `${fname}_COUNTRY`,
            `${fname}_ICAO_CITY`,
            `${fname}_CTR`,
            `${fname}_NAME`,
            `${fname}_ICAO`,
            `${fname}_POSITION`,
            `${fname}_RUNWAY`,
            `${fname}_ELEVATION`,
            `${fname}_ROUTE_NAME`,
            `${fname}_ROUTE_ALTITUDE`,
            `${fname}_CIRCUIT_ALTITUDE`,
            `${fname}_ATC_TOWER`,
            `${fname}_ATC_APPROACH`,
            `${fname}_ATC_ATIS_FREQ`,
            `${fname}_ATC_GROUND`,
            `${fname}_ATC_TELEPHONE`
        ];

        fields.forEach(fieldId => {
            const element = document.getElementById(fieldId);
            if (element) {
                element.addEventListener('change', () => {
                    if (window.flight_plan_data) {
                        window.flight_plan_data[fieldId] = element.value;
                        console.log(`Updated ${fieldId}:`, element.value);
                    }
                });
            }
        });
    }
    // Initialize with DEPARTURE
    initializeAerodromeFields('DEPARTURE');
    initializeAerodromeFields('ARRIVAL');

</script>
