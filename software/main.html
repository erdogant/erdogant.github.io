<html lang="en">

<!--
    This is the JavaScript widget for SkyWalk.
    @copyright Copyright (c) 2025 Erdogan Taskesen
    @license
    @author Erdogan Taskesen <erdogant@gmail.com>
-->

<head>
    <meta charset="UTF-8">
    <title>Skywalk Flightplan</title>

    <!--RUN FULL SCREEN-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#2A3F54">
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">

    <!--ICON-->
    <link rel="shortcut icon" type="image/png" href="./icons/airplane_gray.png">
    <link rel="icon" type="image/png" sizes="16x16 32x32" href="./icons/airplane_gray.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./icons/airplane_gray.png">
    <!--<link rel="shortcut icon" type="image/x-icon" href="https://erdogant.github.io/datasets/skywalk/figs/icons/airplane_gray.png">-->
    <!--<link rel="icon" type="image/png" sizes="16x16" href="https://erdogant.github.io/datasets/skywalk/figs/icons/airplane_gray.png">-->
    <!--<link rel="apple-touch-icon" sizes="180x180" href="https://erdogant.github.io/datasets/skywalk/figs/icons/airplane_gray.png">-->

    <!--STYLESHEETS-->
    <link rel="stylesheet" href="style.css">

    <!--CORE FILES-->
    <link rel="stylesheet" href="https://pyscript.net/releases/2025.8.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2025.8.1/core.js"></script>
    <!--<link rel="stylesheet" href="./libs/core.css">-->
    <!--<script type="module" src="./libs/core.js"></script>-->
    <!--<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>-->
    <script src="./libs/plotly-2.35.2.min.js"></script>

    <!-- Leaflet CSS -->
    <!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />-->
    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>-->
    <link rel="stylesheet" href="./libs/leaflet.css">
    <script src="./libs/leaflet.js"></script>

    <!--MANIFEST-->
    <link rel="manifest" href="/manifest.json">

    <!--ANIMATION THE ORDE OF IMPORT MATHERS!-->
    <!--<script src="./scripts/utils.js" defer></script>-->
    <script src="./scripts/rain.js" defer></script>
    <script src="./scripts/cloud.js" defer></script>
    <script src="./scripts/fog.js" defer></script>
    <script src="./scripts/sun.js" defer></script>
    <script src="./scripts/snow.js" defer></script>
    <script src="./scripts/dark.js" defer></script>
    <script src="./scripts/metar.js" defer></script

</head>


<body>

<div id="app">
        <!--<div id="loading-spinner" class="spinner-overlay" style="display: flex;">
            <div class="spinner-container">
                <div class="spinner"></div>
                <div class="spinner-text">Loading SkyWalk. Please wait..</div>
            </div>
        </div>-->

    <!-- Tab links -->
    <div class="tab">
        <button class="tablinks active" data-tab="General">‚ñ∂Ô∏è Start</button>
        <button class="tablinks" data-tab="Departure">üõ´ Departure</button>
        <button class="tablinks" data-tab="Arrival">üõ¨ Arrival</button>
        <button class="tablinks" data-tab="Enroute">‚úàÔ∏è Enroute</button>
        <button class="tablinks" data-tab="ATC">üéôÔ∏è ATC</button>
        <button class="tablinks" data-tab="Menu">‚ò∞ More</button>
    </div>

	<div id="Menu" class="tabcontent">
    	<button class="tablinks" data-tab="Config" style="cursor: pointer;">‚öôÔ∏è Config</button>
            <button class="tablinks" data-tab="MAP" style="cursor: pointer;">üó∫Ô∏è Map</button>
            <button class="tablinks" data-tab="Checklist" style="cursor: pointer;">üìã Checklist</button>
            <div class="button-row">
                <button id="BTN-WEIGHTBALANCE"
                    type="button"
                    onclick="window.open('https://www.vliegclubrotterdam.nl/wb/', '_blank')"
                    title="Weight and Balance calculator vliegclub Rotterdam">
                        ‚öñÔ∏è Weight & Balance vliegclub Rotterdam
                </button>
            </div>
            <!--CHECK FOR UPDATES-->
            <button id="updateBtn" onclick="updateApp()">Check for updates</button>
            <script src="app.js"></script>

	</div>


    <!-- =============== TAB GENERAL =============== -->
	<div id="General" class="tabcontent">

        <!-- Logo -->
        <div class="logo-container">
            <a href="https://erdogant.github.io/skywalk-docs/pages/html/index.html" target="_blank">
                <img
                    id="skywalk_logo"
                    alt="SkyWalk"
                    src="./figs/logo_skywalk.png"
                >
                    <!--id="LOGO_SKYWALK_image_cache"-->

                <!-- Canvas overlay -->
                <!--<canvas class="rain-canvas" data-prefix="LOGO_SKYWALK"></canvas>
                <canvas class="cloud-canvas"  data-prefix="LOGO_SKYWALK"></canvas>
                <canvas class="fog-canvas"  data-prefix="LOGO_SKYWALK"></canvas>
                <canvas class="flare-canvas"  data-prefix="LOGO_SKYWALK"></canvas>
                <canvas class="snow-canvas"  data-prefix="LOGO_SKYWALK"></canvas>
                <canvas class="dark-canvas"  data-prefix="LOGO_SKYWALK"></canvas>-->

            </a>
            <div class="version" style="margin-bottom: 5px; ">version: 1.0.0</div>
        </div>

        <div>
            <div class="tile" style="text-align: center; border: none;">
                <input id="FLIGHTPLAN" type="text" onchange="createDateTime()" class="tile-value" title="Name your flightplan" placeholder="My flight plan" style="flex: 1;font-size: 18px;">
                <input id="DATETIME" type="label" style="text-align: center; font-size: 12px; background-color: transparent; color: #777; border: none;" disabled>
            </div>
        </div>

        <!--<label_h1>Aircraft</label_h1>-->
        <div class="border-round-eged">
            <div class="wind-grid">
                <div class="tile">
                    <input id="CALLSIGN" type="text", class="tile-value UPPERCASE_input", title="CALLSIGN of the aircraft">
                    <span class="tile-label">CALLSIGN (PH-XYZ)</span>
                </div>
                <div class="tile">
                    <input id="AIRCRAFT_TYPE" type="text", class="tile-value UPPERCASE_input", title="Aircraft name (ROBIN400)">
                    <span class="tile-label">Aircraft name</span>
                </div>
            </div>

            <div class="wind-grid">
                <div class="tile">
                    <input id="POB" type="text", class="tile-value UPPERCASE_input", title="Persons on Board">
                    <span class="tile-label">Persons on Board</span>
                </div>

                <select id="FLIGHT_RULES", class="tile-value-dropdown", style="text-align: center;">
                    <option value="VFR">VFR</option>
                    <option value="IFR">IFR</option>
                </select>
            </div>

            <div class="wind-grid">
                <div class="tile">
                    <!--<input id="DEPARTURE_ICAO_2" type="text" class="tile-value UPPERCASE_input sync-departure" onchange="window.load_aerodrome_from_json('DEPARTURE', elementId='DEPARTURE_ICAO_2');" title="Departure ICAO">-->
                    <input id="DEPARTURE_ICAO_2" type="text" class="tile-value UPPERCASE_input sync-departure" title="Departure ICAO">
                    <span id="DEPARTURE_ICAO_2_LABEL" class="tile-label">Departure (ICAO)</span>
                </div>
                <div class="tile">
                    <!--<input id="ARRIVAL_ICAO_2" type="text" class="tile-value UPPERCASE_input sync-arrival" onchange="window.load_aerodrome_from_json('ARRIVAL', elementId='ARRIVAL_ICAO_2');" title="Arrival ICAO">-->
                    <input id="ARRIVAL_ICAO_2" type="text" class="tile-value UPPERCASE_input sync-arrival" title="Arrival ICAO">
                    <span id="ARRIVAL_ICAO_2_LABEL" class="tile-label">Arrival (ICAO)</span>
                </div>
            </div>
        </div>

        <div class="wind-grid" style="display: flex; align-items: center; gap: 8px;">
            <!-- Delete Button -->
            <button id="delete_btn" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px;" title="Delete Flight Plan">üóëÔ∏è</button>
            <!-- New Plan Button -->
            <button id="new_plan_btn" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px;" title="Create New Flight Plan">üßπ</button>

            <!-- Plan Spinner -->
            <select id="plan_spinner" class="tile-value-dropdown" onchange="this.value && window.load_flightplan()" style="flex: 1; font-size: 12px; font-weight: normal;">
                <option value="">Select and Load</option>
            </select>

            <!-- Save button -->
            <button id="save_fields_btn" onclick="window.save_flightplan()" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px;" title="Save Flight Plan">üíæ</button>
        </div>

        <!-- Bottom Buttons Container -->
        <div id="bottom-container">
            <div class="coffee-container">
                <a href="https://www.buymeacoffee.com/erdogant" target="_blank">
                    <img id="coffee_logo" alt="Coffee Donation" src="./figs/buy_me_a_coffee.png">
                </a>
            </div>

           	<center>
          		<script async src="https://media.ethicalads.io/media/client/ethicalads.min.js"></script>
          		<div data-ea-publisher="erdogantgithubio" data-ea-type="text"></div>
           	</center>
        </div>

	</div>


	<!-- ============================================= -->
	<!-- =============== TAB DEPARTURE =============== -->
	<!-- ============================================= -->

	<div id="Departure" class="tabcontent">

        <!-- Departure Information Label -->
        <label_h1>Departure Information</label_h1>

        <!-- Departure Image -->
        <!--<div class="logo-container" style="margin-top: 20px;">
            <img id="DEPARTURE_image_cache"
                alt="Departure Aerodrome"
                style="max-width: 100%; height: auto; border-radius: 10px; cursor: pointer;"
                onclick="openAerodromeMap('DEPARTURE')"
                src="./figs/default_aerodrome.jpg"
            >
        </div>-->

        <!--<div class="logo-container rain-wrapper" style="margin-top: 20px;">-->
        <div class="logo-container" style="margin-top: 20px;">
            <!--Aerodrome image-->
            <img
                id="DEPARTURE_image_cache"
                alt="Departure Aerodrome"
                src="./figs/default_aerodrome.jpg"
                onclick="openAerodromeMap('DEPARTURE')"
            >
            <!--Rain overlay-->
            <canvas class="rain-canvas" data-prefix="DEPARTURE"></canvas>
            <canvas class="cloud-canvas"  data-prefix="DEPARTURE"></canvas>
            <canvas class="fog-canvas"  data-prefix="DEPARTURE"></canvas>
            <canvas class="flare-canvas"  data-prefix="DEPARTURE"></canvas>
            <canvas class="snow-canvas"  data-prefix="DEPARTURE"></canvas>
            <canvas class="dark-canvas"  data-prefix="DEPARTURE"></canvas>
        </div>




        <label_h1>Select Departure</label_h1>

        <div class="border-round-eged" id="DEPARTURE_SELECT_AERODROME_BORDER">
            <div class="wind-grid">
                <select id="DEPARTURE_COUNTRY" class="tile-value-dropdown" style="font-weight: normal;">
                    <option value="">Select Country</option>
                    <!-- ICAO City options will be populated dynamically IN import_country_selected()-->
                </select>
                <select id="DEPARTURE_ICAO_CITY" class="tile-value-dropdown" style="font-weight: normal;">
                    <option value="">Select ICAO</option>
                    <!-- ICAO City options will be populated dynamically IN populate_aerodrome_fields_from_icao()-->
                </select>
            </div>


            <div class="button-row">
                <img id="DEPARTURE_FLAG" src="" alt="" style="width:30px; height:auto; vertical-align:middle; margin-left:6px;">
                <img id="DEPARTURE_CATAGORY_ICON" src="" alt="" style="width:35px; height:auto; vertical-align:middle; margin-left:6px;">
                <img id="DEPARTURE_VFR_ICON" src="" alt="" style="width:70px; height:auto; vertical-align:middle; margin-left:6px;">
                <!--<input type="text" id="DEPARTURE_ICAO" class="tile-value UPPERCASE_input sync-departure" onchange="window.load_aerodrome_from_json('DEPARTURE')" placeholder="ICAO">-->
                <input type="text" id="DEPARTURE_ICAO" class="tile-value UPPERCASE_input sync-departure" placeholder="ICAO">
                <button id="DEPARTURE_USE_CACHED" onclick="window.retrieve_metar('DEPARTURE')" title="Retrieve METAR weather information for the selected aerodrome" style="background-color: transparent; border: none; color: #666; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 0 8px 4px; flex: 0 0 auto; cursor: pointer;">üîÑ</button>
            </div>


            <div class="wind-grid">

                 <div class="tile">
                    <input id="DEPARTURE_WIND_DIRECTION" type="text" class="tile-value">
                    <span class="tile-label">Wind angle (¬∞)</span>
                </div>

                <div class="tile">
                    <input id="DEPARTURE_WIND_SPEED" type="text" class="tile-value">
                    <span class="tile-label">Strength (kt)</span>
                </div>

                <div class="tile">
                    <input id="DEPARTURE_WIND_GUST" type="text" class="tile-value">
                    <span class="tile-label">Gust (kt)</span>
                </div>
            </div>

            <div class="grid-one-third-two-thirds">
                <div class="tile">
                    <input id="DEPARTURE_WIND_VARIATION" type="text" class="tile-value">
                    <span class="tile-label">Variation (¬∞)</span>
                </div>

                <div class="button-row">
                    <textarea id="METAR-FIELD-DEPARTURE"
                        placeholder="METAR Information"
                        title="METAR weather information"
                        style="font-size:11px; background-color: transparent; width: 100%; min-height: 80px; max-height: 120px; resize: vertical; padding: 8px; box-sizing: border-box; border-radius: 10px"
                        aria-label="METAR Information">
                    </textarea>
                </div>
            </div>

            <div style="display: flex; gap: 1px; margin-top: 1px;">
                <input type="text" id="METAR-TEXT-DEPARTURE" readonly
                    style="transition: background-color 0.3s; width: 70%;
                           padding: 0; box-sizing: border-box; font-size: 10px;
                           border: none; background-color: transparent;
                           color: #333333; outline: none;">

                <input type="text" id="DATETIME-METAR-DEPARTURE" readonly
                    style="transition: background-color 0.3s; width: 40%;
                           padding: 0; box-sizing: border-box; font-size: 10px;
                           border: none; background-color: transparent;
                           color: #333333; outline: none;">
            </div>

        </div>


        <label_h1>Aerodrome Information</label_h1>

        <div class="collapsible" data-title="AERODROME">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">

            <div class="wind-grid">
                <div class="tile">
                    <input id="DEPARTURE_NAME" type="text" class="tile-value" title="Name of the aerodrome how it is known on the radio">
                    <span class="tile-label">Aerodrome</span>
                </div>
            </div>

            <div class="grid-two-thirds-one-third">
                <div class="tile">
                    <input id="DEPARTURE_POSITION" type="text" class="tile-value" title="Position of the Aircraft (at the apron)">
                    <span class="tile-label">Position of the aircraft</span>
                </div>

                <select id="DEPARTURE_CTR" class="tile-value-dropdown" onchange="highlightMissingFields()" style="text-align: center;">
                    <option value=""></option>
                    <option value="CTR">CTR</option>
                </select>
            </div>

            <div class="wind-grid">
                <div class="tile">
                    <input id="DEPARTURE_RUNWAY" type="text" class="tile-value" title="Fill here the runway that is in use.">
                    <span class="tile-label">
                        Runway Nr.
                        <button id="BTN-METAR-ICON-DEPARTURE_2" onclick="window.retrieve_metar('DEPARTURE')"
                            title="Use METAR weather information to automatically predict the runway. Add multiple runways seperated by / or comma. The most optimal runway will be picked automatically."
                            style="background-color: transparent; border: none; width: 10px; padding: 1px; cursor: pointer;">
                                üîÑ
                        </button>
                    </span>
                </div>
                <div class="tile">
                    <input id="DEPARTURE_ELEVATION" type="text" class="tile-value" title="Elevation of the field in feet.">
                    <span class="tile-label">Field elevation (ft)</span>
                </div>
                <div class="tile">
                    <input id="DEPARTURE_CIRCUIT_ALTITUDE" type="text" class="tile-value" title="The altitude of the circuit in feet.">
                    <span class="tile-label">Circuit altitude (ft)</span>
                </div>
            </div>

            <div class="grid-two-thirds-one-third">
                <!-- This takes 1/3 of the width -->
                <div class="tile">
                    <input id="DEPARTURE_ROUTE_NAME" type="text" class="tile-value UPPERCASE_input" title="The name of the route (e.g., MIKE/ROMEO) for departure.">
                    <span class="tile-label">Route name</span>
                </div>
                <!-- This takes 2/3 of the width -->
                <div class="tile">
                    <input id="DEPARTURE_ROUTE_ALTITUDE" type="text" class="tile-value" title="The altitude of the route in feet.">
                    <span class="tile-label">Route altitude (ft)</span>
                </div>
            </div>

            <button onclick="window.save_aerodrome_to_json('DEPARTURE')" title="Save custom aerodrome information" style="background-color: transparent; border: none; color: #666; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 4px 8px 0; flex: 0 0 auto; cursor: pointer; float: right;">üíæ</button>

        </div>
        </div>


    	  <!--<label_h1>Contact</label_h1>-->
        <div class="collapsible" data-title="CONTACT">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">

            <div class="wind-grid">
                <div class="tile">
                    <input id="DEPARTURE_ATC_GROUND" type="text" class="tile-value">
                    <span class="tile-label">Ground/ delivery (MHz)</span>
                </div>
                <div class="tile">
                    <input id="DEPARTURE_ATC_TOWER" type="text" class="tile-value">
                    <span class="tile-label">Tower/ Radio (MHz)</span>
                </div>
                <div class="tile">
                    <input id="DEPARTURE_ATC_ATIS_FREQ" type="text" class="tile-value">
                    <span class="tile-label">ATIS (MHz)</span>
                </div>
            </div>

            <div class="grid-two-thirds-one-third">
                <div class="tile">
                    <input id="DEPARTURE_ATC_TELEPHONE" type="text" class="tile-value">
                    <span class="tile-label">Telephone Number</span>
                </div>
                <div class="tile">
                    <input id="DEPARTURE_ATC_APPROACH" type="text" class="tile-value">
                    <span class="tile-label">Approach (MHz)</span>
                </div>
            </div>

            <button onclick="window.save_aerodrome_to_json('DEPARTURE')" title="Save custom aerodrome information" style="background-color: transparent; border: none; color: #666; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 4px 8px 0; flex: 0 0 auto; cursor: pointer; float: right;">üíæ</button>
        </div>
        </div>



        <label_h1>METAR WIDGETS</label_h1>

        <!-- METAR Information -->
        <div class="collapsible" data-title="WIND ENVELOPE">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">

            <div style="border: 1px solid lightgrey; border-radius: 10px; padding: 10px;">
                <div id="bottom-container">
                    <div class="warning">
                        The wind envelope shows how wind direction and strength relate to the selected runway, and marks the maximum permitted headwind and crosswind components.
                        Use it only as an educational aid. Always do your own research, check the METAR/TAF from official aerodrome sources, and check your aircraft‚Äôs operating limitations.
                    </div>
                </div>
            </div>

            <div class="button-row">
                <button id="BTN-PLOT-WIND-DEPARTURE" class="button-style" onclick="window.windEnvelope_js('DEPARTURE')">
                    Compute Crosswind/ Headwind
                </button>
            </div>

           <!-- WIND INFORMATION -->
           <div class="wind-grid">
               <div class="tile">
                   <input id="DEPARTURE_WIND_HEADWIND" readonly type="text" class="tile-value" title="Headwind is calculated based on the wind speed and direction relative to the runway. This value can not be changed." style="background-color: transparent;">
                   <span class="tile-label">Headwind (kt)</span>
               </div>

               <div class="tile">
                   <input id="DEPARTURE_WIND_CROSSWIND" readonly type="text" class="tile-value" title="Crosswind is calculated based on the wind speed and direction relative to the runway. This value can not be changed." style="background-color: transparent;">
                   <span class="tile-label">Crosswind (kt)</span>
               </div>
           </div>

           <div class="button-row">
               <div id="DEPARTURE_WIND_ENVELOPE_PLOT" style="width: 100%; box-sizing: border-box;"></div>
           </div>

           <div class="button-row">
               <textarea id="DEPARTURE_WIND_ENVELOPE_TEXT" readonly aria-readonly="true"
                   placeholder="Information about the wind envelope will be shown here."
                   style="transition: background-color 0.3s; width: 100%; min-height: 80px; max-height: 120px; resize: vertical; padding: 8px; box-sizing: border-box; border-radius: 10px">
                </textarea>
           </div>

       </div>
       </div>


        <!-- METAR-TAF WIDGET -->
        <div class="collapsible" data-title="METAR-TAF">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <div class="button-row">
                <button id="BTN-METARTAF-DEPARTURE"
                    onclick="window.set_widget('DEPARTURE', 'METARTAF')"
                    style="transition: background-color 0.3s; z-index: 1; background-color: #006280; border: 1px solid #333333; color: #ffffff; cursor: pointer;">
                    Retrieve METAR-TAF
                </button>
            </div>

            <div id="CONTAINER-METARTAF-DEPARTURE" style="display: flex; justify-content: center; align-items: center; cursor: pointer;">
                <iframe id="DEPARTURE-METARTAF-iframe"
                        src=""
                        width="100%"
                        height="500"
                        frameborder="0"
                        style="border:0; min-height:500px; overflow:hidden; display:block;"
                        title="METAR-TAF"
                        allowfullscreen
                        scrolling="no">
            </iframe>
            </div>
        </div>
        </div>

        <!-- AIRPORT-WEATHER WIDGET -->
        <div class="collapsible" data-title="AIRPORTWEATHER">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <div class="button-row">
                <button id="BTN-AIRPORTWEATHER-DEPARTURE"
                    onclick="window.set_widget('DEPARTURE', 'AIRPORTWEATHER')"
                    style="transition: background-color 0.3s; z-index: 1; background-color: #006280; border: 1px solid #333333; color: #ffffff;">
                    Retrieve AirportWeather
                </button>
            </div>

            <!--
            1. make the iframe large enough =4000 the put the commercial stuff at the bottom.
            2. Remove the top 125px of the website and hte bottom 1500px.
            3. Do not allow scroll
            -->
            <div id="CONTAINER-AIRPORTWEATHER-DEPARTURE" style="display: flex; justify-content: center; align-items: center;">
                <iframe id="DEPARTURE-airportweather-iframe"
                        src=""
                        width="100%"
                        height="4000"
                        frameborder="0"
                        style="border:0; min-height:1000px; overflow:hidden; margin-top:-125px; margin-bottom:-1500px; display:block;"
                        title="AirportWeather"
                        allowfullscreen
                        scrolling="no">
                </iframe>
            </div>

        </div>
        </div>

	</div>



    <!-- ============================================= -->
	<!-- =============== TAB ARRIVAL =============== -->
	<!-- ============================================= -->

	<div id="Arrival" class="tabcontent">

        <!-- Arrival Information Label -->
        <label_h1>Arrival Information</label_h1>

        <!--<div class="logo-container rain-wrapper" style="margin-top: 20px;">-->
        <div class="logo-container" style="margin-top: 20px;">
            <!-- Aerodrome image -->
            <img
                id="ARRIVAL_image_cache"
                alt="Arrival Aerodrome"
                src="./figs/default_aerodrome.jpg"
                onclick="openAerodromeMap('ARRIVAL')"
            >

            <!-- Canvas overlay -->
            <canvas class="rain-canvas" data-prefix="ARRIVAL"></canvas>
            <canvas class="cloud-canvas"  data-prefix="ARRIVAL"></canvas>
            <canvas class="fog-canvas"  data-prefix="ARRIVAL"></canvas>
            <canvas class="flare-canvas"  data-prefix="ARRIVAL"></canvas>
            <canvas class="snow-canvas"  data-prefix="ARRIVAL"></canvas>
            <canvas class="dark-canvas"  data-prefix="ARRIVAL"></canvas>
        </div>


        <label_h1>Select Arrival</label_h1>

        <div class="border-round-eged" id="ARRIVAL_SELECT_AERODROME_BORDER">
            <div class="wind-grid">
                <select id="ARRIVAL_COUNTRY" class="tile-value-dropdown" style="font-weight: normal;">
                    <option value="">Select Country</option>
                    <!-- ICAO City options will be populated dynamically IN import_country_selected()-->
                </select>
                <select id="ARRIVAL_ICAO_CITY" class="tile-value-dropdown" style="font-weight: normal;">
                    <option value="">Select ICAO</option>
                    <!-- ICAO City options will be populated dynamically IN populate_aerodrome_fields_from_icao()-->
                </select>
            </div>


            <div class="button-row">
                <img id="ARRIVAL_FLAG" src="" alt="" style="width:30px; height:auto; vertical-align:middle; margin-left:6px;">
                <img id="ARRIVAL_CATAGORY_ICON" src="" alt="" style="width:35px; height:auto; vertical-align:middle; margin-left:6px;">
                <img id="ARRIVAL_VFR_ICON" src="" alt="" style="width:70px; height:auto; vertical-align:middle; margin-left:6px;">
                <!--<input type="text" id="ARRIVAL_ICAO" class="tile-value UPPERCASE_input sync-arrival" onchange="window.load_aerodrome_from_json('ARRIVAL')" placeholder="ICAO">-->
                <input type="text" id="ARRIVAL_ICAO" class="tile-value UPPERCASE_input sync-arrival" placeholder="ICAO">
                <button id="ARRIVAL_USE_CACHED" onclick="window.retrieve_metar('ARRIVAL')" title="Retrieve METAR weather information for the selected aerodrome" style="background-color: transparent; border: none; color: #666; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 0 8px 4px; flex: 0 0 auto; cursor: pointer;">üîÑ</button>
            </div>


            <div class="wind-grid">

                 <div class="tile">
                    <input id="ARRIVAL_WIND_DIRECTION" type="text" class="tile-value">
                    <span class="tile-label">Wind angle (¬∞)</span>
                </div>

                <div class="tile">
                    <input id="ARRIVAL_WIND_SPEED" type="text" class="tile-value">
                    <span class="tile-label">Strength (kt)</span>
                </div>

                <div class="tile">
                    <input id="ARRIVAL_WIND_GUST" type="text" class="tile-value">
                    <span class="tile-label">Gust (kt)</span>
                </div>
            </div>

            <div class="grid-one-third-two-thirds">
                <div class="tile">
                    <input id="ARRIVAL_WIND_VARIATION" type="text" class="tile-value">
                    <span class="tile-label">Variation (¬∞)</span>
                </div>

                <div class="button-row">
                    <textarea id="METAR-FIELD-ARRIVAL"
                        placeholder="METAR Information"
                        title="METAR weather information"
                        style="font-size:11px; background-color: transparent; width: 100%; min-height: 80px; max-height: 120px; resize: vertical; padding: 8px; box-sizing: border-box; border-radius: 10px"
                        aria-label="METAR Information">
                    </textarea>
                </div>
            </div>

            <div style="display: flex; gap: 1px; margin-top: 1px;">
                <input type="text" id="METAR-TEXT-ARRIVAL" readonly
                    style="transition: background-color 0.3s; width: 70%;
                           padding: 0; box-sizing: border-box; font-size: 10px;
                           border: none; background-color: transparent;
                           color: #333333; outline: none;">

                <input type="text" id="DATETIME-METAR-ARRIVAL" readonly
                    style="transition: background-color 0.3s; width: 40%;
                           padding: 0; box-sizing: border-box; font-size: 10px;
                           border: none; background-color: transparent;
                           color: #333333; outline: none;">
            </div>
        </div>


        <label_h1>Aerodrome Information</label_h1>

        <div class="collapsible" data-title="AERODROME">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">

            <div class="wind-grid">
                <div class="tile">
                    <input id="ARRIVAL_NAME" type="text" class="tile-value" title="Name of the aerodrome how it is known on the radio">
                    <span class="tile-label">Aerodrome</span>
                </div>
            </div>

            <div class="grid-two-thirds-one-third">
                <div class="tile">
                    <input id="ARRIVAL_POSITION" type="text" class="tile-value" title="Position of the Aircraft (at the apron)">
                    <span class="tile-label">Position of the aircraft</span>
                </div>

                <select id="ARRIVAL_CTR" class="tile-value-dropdown" onchange="highlightMissingFields()" style="text-align: center;">
                    <option value=""></option>
                    <option value="CTR">CTR</option>
                </select>
            </div>

            <div class="wind-grid">
                <div class="tile">
                    <input id="ARRIVAL_RUNWAY" type="text" class="tile-value" title="Fill here the runway that is in use.">
                    <span class="tile-label">
                        Runway Nr.
                        <button id="BTN-METAR-ICON-ARRIVAL_2" onclick="window.retrieve_metar('ARRIVAL')"
                            title="Use METAR weather information to automatically predict the runway. Add multiple runways seperated by / or comma. The most optimal runway will be picked automatically."
                            style="background-color: transparent; border: none; width: 10px; padding: 1px; cursor: pointer;">
                                üîÑ
                        </button>
                    </span>
                </div>
                <div class="tile">
                    <input id="ARRIVAL_ELEVATION" type="text" class="tile-value" title="Elevation of the field in feet.">
                    <span class="tile-label">Field elevation (ft)</span>
                </div>
                <div class="tile">
                    <input id="ARRIVAL_CIRCUIT_ALTITUDE" type="text" class="tile-value" title="The altitude of the circuit in feet.">
                    <span class="tile-label">Circuit altitude (ft)</span>
                </div>
            </div>

            <div class="grid-two-thirds-one-third">
                <!-- This takes 1/3 of the width -->
                <div class="tile">
                    <input id="ARRIVAL_ROUTE_NAME" type="text" class="tile-value UPPERCASE_input" title="The name of the route (e.g., MIKE/ROMEO) for arrival.">
                    <span class="tile-label">Route name</span>
                </div>
                <!-- This takes 2/3 of the width -->
                <div class="tile">
                    <input id="ARRIVAL_ROUTE_ALTITUDE" type="text" class="tile-value" title="The altitude of the route in feet.">
                    <span class="tile-label">Route altitude (ft)</span>
                </div>
            </div>

            <button onclick="window.save_aerodrome_to_json('ARRIVAL')" title="Save custom aerodrome information" style="background-color: transparent; border: none; color: #666; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 4px 8px 0; flex: 0 0 auto; cursor: pointer; float: right;">üíæ</button>

        </div>
        </div>


    	  <!--<label_h1>Contact</label_h1>-->
        <div class="collapsible" data-title="CONTACT">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">

            <div class="wind-grid">
                <div class="tile">
                    <input id="ARRIVAL_ATC_GROUND" type="text" class="tile-value">
                    <span class="tile-label">Ground/ delivery (MHz)</span>
                </div>
                <div class="tile">
                    <input id="ARRIVAL_ATC_TOWER" type="text" class="tile-value">
                    <span class="tile-label">Tower/ Radio (MHz)</span>
                </div>
                <div class="tile">
                    <input id="ARRIVAL_ATC_ATIS_FREQ" type="text" class="tile-value">
                    <span class="tile-label">ATIS (MHz)</span>
                </div>
            </div>

            <div class="grid-two-thirds-one-third">
                <div class="tile">
                    <input id="ARRIVAL_ATC_TELEPHONE" type="text" class="tile-value">
                    <span class="tile-label">Telephone Number</span>
                </div>
                <div class="tile">
                    <input id="ARRIVAL_ATC_APPROACH" type="text" class="tile-value">
                    <span class="tile-label">Approach (MHz)</span>
                </div>
            </div>

            <button onclick="window.save_aerodrome_to_json('ARRIVAL')" title="Save custom aerodrome information" style="background-color: transparent; border: none; color: #666; width: 30px; min-width: 24px; height: 24px; padding: 0; margin: 8px 4px 8px 0; flex: 0 0 auto; cursor: pointer; float: right;">üíæ</button>
        </div>
        </div>



        <label_h1>METAR WIDGETS</label_h1>

        <!-- METAR Information -->
        <div class="collapsible" data-title="WIND ENVELOPE">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">

            <div style="border: 1px solid lightgrey; border-radius: 10px; padding: 10px;">
                <div id="bottom-container">
                    <div class="warning">
                        The wind envelope shows how wind direction and strength relate to the selected runway, and marks the maximum permitted headwind and crosswind components.
                        Use it only as an educational aid. Always do your own research, check the METAR/TAF from official aerodrome sources, and check your aircraft‚Äôs operating limitations.
                        Change the wind input fields accordingly and re-compute to see the effect on crosswind and headwind components.
                    </div>
                </div>
            </div>

            <div class="button-row">
                <button id="BTN-PLOT-WIND-ARRIVAL" class="button-style" onclick="window.windEnvelope_js('ARRIVAL')">
                    Compute Crosswind/ Headwind
                </button>
            </div>

           <!-- WIND INFORMATION -->
           <div class="wind-grid">
               <div class="tile">
                   <input id="ARRIVAL_WIND_HEADWIND" readonly type="text" class="tile-value" title="Headwind is calculated based on the wind speed and direction relative to the runway. This value can not be changed." style="background-color: transparent;">
                   <span class="tile-label">Headwind (kt)</span>
               </div>

               <div class="tile">
                   <input id="ARRIVAL_WIND_CROSSWIND" readonly type="text" class="tile-value" title="Crosswind is calculated based on the wind speed and direction relative to the runway. This value can not be changed." style="background-color: transparent;">
                   <span class="tile-label">Crosswind (kt)</span>
               </div>
           </div>

           <div class="button-row">
               <div id="ARRIVAL_WIND_ENVELOPE_PLOT" style="width: 100%; box-sizing: border-box;"></div>
           </div>

           <div class="button-row">
               <textarea id="ARRIVAL_WIND_ENVELOPE_TEXT" readonly aria-readonly="true"
                   placeholder="Compute the wind envelope to see here information."
                   style="transition: background-color 0.3s; width: 100%; min-height: 80px; max-height: 120px; resize: vertical; padding: 8px; box-sizing: border-box; border-radius: 10px">
                </textarea>
           </div>

       </div>
       </div>


        <!-- METAR-TAF WIDGET -->
        <div class="collapsible" data-title="METAR-TAF">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <div class="button-row">
                <button id="BTN-METARTAF-ARRIVAL"
                    onclick="window.set_widget('ARRIVAL', 'METARTAF')"
                    style="transition: background-color 0.3s; z-index: 1; background-color: #006280; border: 1px solid #333333; color: #ffffff; cursor: pointer;">
                    Retrieve METAR-TAF
                </button>
            </div>

            <div id="CONTAINER-METARTAF-ARRIVAL" style="display: flex; justify-content: center; align-items: center; cursor: pointer;">
                <iframe id="ARRIVAL-METARTAF-iframe"
                        src=""
                        width="100%"
                        height="500"
                        frameborder="0"
                        style="border:0; min-height:500px; overflow:hidden; display:block;"
                        title="METAR-TAF"
                        allowfullscreen
                        scrolling="no">
            </iframe>
            </div>
        </div>
        </div>

        <!-- AIRPORT-WEATHER WIDGET -->
        <div class="collapsible" data-title="AIRPORTWEATHER">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <div class="button-row">
                <button id="BTN-AIRPORTWEATHER-ARRIVAL"
                    onclick="window.set_widget('ARRIVAL', 'AIRPORTWEATHER')"
                    style="transition: background-color 0.3s; z-index: 1; background-color: #006280; border: 1px solid #333333; color: #ffffff;">
                    Retrieve AirportWeather
                </button>
            </div>

            <!--
            1. make the iframe large enough =4000 the put the commercial stuff at the bottom.
            2. Remove the top 125px of the website and hte bottom 1500px.
            3. Do not allow scroll
            -->
            <div id="CONTAINER-AIRPORTWEATHER-ARRIVAL" style="display: flex; justify-content: center; align-items: center;">
                <iframe id="ARRIVAL-airportweather-iframe"
                        src=""
                        width="100%"
                        height="4000"
                        frameborder="0"
                        style="border:0; min-height:1000px; overflow:hidden; margin-top:-125px; margin-bottom:-1500px; display:block;"
                        title="AirportWeather"
                        allowfullscreen
                        scrolling="no">
                </iframe>
            </div>

        </div>
        </div>

	</div>






    <!-- =============== TAB ENROUTE =============== -->
    <div id="Enroute" class="tabcontent">
        <label_h1>Enroute Information</label_h1>

        <div class="border-round-eged">
            <label_h2>Flight Information Centre (FIC)</label_h2>
            <div class="grid-two-thirds-one-third">
                <div class="tile">
                    <input id="FIC_NAME" type="text" class="tile-value REPLACE_INFO" style="font-size: 14px;">
                    <span class="tile-label">FIC name</span>
                </div>
                <div class="tile">
                    <input id="FIC_FREQUENCY" type="text" class="tile-value">
                    <span class="tile-label">Frequency (Mhz)</span>
                </div>
            </div>

            <div class="grid-two-thirds-one-third">
                <div class="tile">
                    <input id="OVERHEAD" type="text" class="tile-value UPPERCASE_input" style="font-size: 11px;">
                    <span class="tile-label">Overhead</span>
                </div>
                <div class="tile">
                    <input id="SQUAWK" type="text" class="tile-value">
                    <span class="tile-label">SQUAWK</span>
                </div>
            </div>

            <div class="wind-grid" style="display: flex; align-items: center; gap: 8px;">
                <!-- Delete Button -->
                <button id="fic_delete_btn" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px;" title="Delete FIC">üóëÔ∏è</button>
                <!-- Spinner -->
                <select id="fic_spinner" class="tile-value-dropdown" style="flex: 1; font-size: 12px; font-weight: normal;">
                    <option value="">Select and Load</option>
                </select>
                <!-- Save button -->
                <button id="fic_save_btn" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px;" title="Save FIC">üíæ</button>
            </div>

        </div>


        <div class="border-round-eged">
            <label_h2>Second Flight Information Centre (FIC)</label_h2>

            <div class="grid-two-thirds-one-third">
                <div class="tile">
                    <input id="FIC_NAME2" type="text" class="tile-value REPLACE_INFO" style="font-size: 14px;">
                    <span class="tile-label">Secondary FIC name</span>
                </div>
                <div class="tile">
                    <input id="FIC_FREQUENCY2" type="text" class="tile-value">
                    <span class="tile-label">frequency (Mhz)</span>
                </div>
            </div>
            <div class="grid-two-thirds-one-third">
                <div class="tile">
                    <input id="OVERHEAD2" type="text" class="tile-value UPPERCASE_input" style="font-size: 11px;">
                    <span class="tile-label">Overhead</span>
                </div>
                <div class="tile">
                    <input id="SQUAWK2" type="text" class="tile-value">
                    <span class="tile-label">SQUAWK</span>
                </div>
            </div>

            <div class="wind-grid" style="display: flex; align-items: center; gap: 8px;">
                <!-- Delete Button -->
                <button id="fic_delete_btn2" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px;" title="Delete FIC2">üóëÔ∏è</button>

                <!-- Spinner -->
                <select id="fic_spinner2" class="tile-value-dropdown" style="flex: 1; font-size: 12px; font-weight: normal;">
                    <option value="">Select and Load</option>
                </select>

                <!-- Save button -->
                <button id="fic_save_btn2" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px;" title="Save FIC2">üíæ</button>
            </div>

        </div>



    </div>

    <!-- =============== TAB ATC =============== -->


    <div id="ATC" class="tabcontent">

        <!-- ATC -->
        <label_h1>Display Settings</label_h1>

        <!--<div class="border-round-eged">-->
            <div class="wind-grid">
                <div class="tile">
                    <select id="atc_fontsize" class="tile-value-dropdown">
                        <option value="small">Small</option>
                        <option value="medium">Medium</option>
                        <option value="large" selected>Large</option>
                        <option value="xl">Extra Large</option>
                        <option value="xxl">XXL</option>
                    </select>
                    <span class="tile-label">Choose Font Size</span>
                </div>
                <div class="tile">
                    <select id="atc_columns" class="tile-value-dropdown">
                        <option value="1">1</option>
                        <option value="2" selected>2</option>
                        <option value="3">3</option>
                    </select>
                    <span class="tile-label">Choose Columns</span>
                </div>
            </div>

        <label_h1>Required Fields</label_h1>
        <div style="border: 1px solid lightgrey; border-radius: 10px; padding: 10px;">
            <div id="bottom-container">
                <div class="warning" id="missing_label">Missing: Flight plan name, CALLSIGN, Aircraft Type</div>
            </div>
        </div>


       <label_h1>Air Traffic Control (ATC)</label_h1>

       <div style="border: 1px solid lightgrey; border-radius: 10px; padding: 10px;">
           <div class="button-row">
               <button id="BTN_HTML_SUMMARY">Summary ATC</button>
                <button id="BTN_HTML_SUMMARY_REV">Reverse</button>
            </div>
            <div class="button-row">
                <button id="BTN_HTML_DEPARTURE">Departure ATC</button>
                <button id="BTN_HTML_DEPARTURE_REV">Reverse</button>
            </div>
            <div class="button-row">
                <button id="BTN_HTML_ARRIVAL">Arrival ATC</button>
                <button id="BTN_HTML_ARRIVAL_REV">Reverse</button>
            </div>
            <div class="button-row">
                <button id="BTN_HTML_ENROUTE">Enroute ATC</button>
                <button id="BTN_HTML_EN_REV">Reverse</button>
            </div>
       </div>

    </div>




    <!-- =============== TAB MAP =============== -->
    <div id="MAP" class="tabcontent">
        <label_h1>MAP</label_h1>

        <div class="wind-grid">
            <select id="layer-select" class="tile-value-dropdown">
                <option value="OpenStreetMap">OpenStreetMap</option>
                <option value="OpenTopoMap">OpenTopoMap</option>
                <!--<option value="Carto Voyager">Carto Voyager</option>-->
            </select>
        </div>

        <div class="button-row">
            <label>
                <input type="checkbox" id="aviation-toggle" checked> Show Airports
            </label>
            <label>
                <input type="checkbox" id="airspace-toggle" checked> Show Airspaces
            </label>
        </div>

        <div class="button-row">
            <div style="display: flex; align-items: center; margin-top: 5px;">
                <label style="margin-right: 5px;">Airspaces at altitude (ft):</label>
                <input type="number" id="airspace-altitude" value="1500" min="150" max="10000" step="150" style="width: 80px;">
            </div>
        </div>

        <div class="button-row">
            <div style="display: flex; gap: 10px;">
                <label>
                    <input type="checkbox" id="TMZ-toggle" unchecked>TMZ
                </label>
                <label>
                    <input type="checkbox" id="CTA_TMA-toggle" unchecked>CTA/TMA
                </label>
                <label>
                    <input type="checkbox" id="danger-toggle" unchecked>Danger
                </label>
                <label>
                    <input type="checkbox" id="prohibited-toggle" unchecked>Prohibited
                </label>
            </div>
        </div>

        <div id="map-container" style="height: 500px;">
            <div id="route-map" style="height: 100%;"></div>
            <div class="map-controls" style="position: absolute; top: 10px; right: 10px; background: none; padding: 0; z-index: 1000;">
                <button id="fullscreen-btn" onclick="toggleFullscreen()" style="width: 44px; height: 44px; padding: 0; background: white; border: 2px solid rgba(0,0,0,0.2); border-radius: 4px; cursor: pointer; touch-action: manipulation;">
                    <svg class="fullscreen-enter" viewBox="0 0 24 24" style="width: 24px; height: 24px; margin: 8px;">
                        <path d="M7,14H5v5h5v-2H7V14z M5,10h2V7h3V5H5V10z M17,17h-3v2h5v-5h-2V17z M14,5v2h3v3h2V5H14z"/>
                    </svg>
                    <svg class="fullscreen-exit" viewBox="0 0 24 24" style="width: 24px; height: 24px; margin: 8px; display: none;">
                        <path d="M5,16h3v3h2v-5H5V16z M8,8H5v2h5V5H8V8z M14,19h2v-3h3v-2h-5V19z M16,8V5h-2v5h5V8H16z"/>
                    </svg>
                </button>
            </div>
        </div>


        <!-- Leaflet CSS -->
        <!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>-->

        <label_h1>Warning</label_h1>
        <div class="warning" style="margin-bottom: 20px; border: 2px solid orange; border-radius: 10px; padding: 10px;">The airspace projections on the map are based on data that can be outdated or inaccurate. Do not navigate using the map but only use it for educational purposes.</div>



    </div>

    <!-- =============== TAB CONFIGURATIONS =============== -->

    <div id="Config" class="tabcontent">
        <!-- CONFIGURATIONS -->
        <label_h1>Information</label_h1>
        <div class="info" style="margin-bottom: 20px;">SkyWalk is a web-based tool designed to help pilots communicate effectively with Air Traffic Control (ATC). The app is free for use, is for educational purposes and does not require any registration or login. If you enjoy using SkyWalk, please consider supporting by donating a coffee.</div>

        <label_h1>Cleaning</label_h1>
        <div class="button-row" style="margin-top: 20px;">
            <button id="clear_cache_btn" style="background-color: #ff4444; color: white; cursor: pointer;">Clear Cache</button>
        </div>
        <div class="warning" style="margin-bottom: 20px;">Warning: This will permanently delete all saved flightplans and aerodrome images from your local browser storage. The reason for using this is when you want to start fresh or when you suspect that your flightplans or images are corrupted or the ATC page does not show or update. This action cannot be undone.</div>

        <label_h1>Disclaimer</label_h1>
         <div class="disclaimer" style="margin-bottom: 20px; border: 2px solid red; border-radius: 10px; padding: 10px;">SkyWalk is provided ‚Äúas is,‚Äù without any warranties, express or implied. SkyWalk is intended for educational use. The developers assume no liability for any damages arising from using this application.</div>

    </div>

    <div id="Checklist" class="tabcontent">

        <label_h1>Checklist</label_h1>
        <div style="border: 0px solid lightgrey; border-radius: 10px; padding: 10px;">
            <div id="bottom-container">
                <div class="info">
                    Flight preparations requires doing many tasks carefully. Here we seperate them into catagories to keep it organized.                </div>
            </div>
        </div>

        <div class="border-round-eged">
            <div class="wind-grid" style="display: flex; align-items: center; gap: 1px;">
                <!-- Inputfield -->
                <input id="checklist_field" type="text" class="tile-value" placeholder="My checklist" style="background-color:transparent; font-size: 18px; padding: 0.5px;">
            </div>

            <div class="wind-grid" style="display: flex; align-items: center; gap: 8px;">
                <!-- Clean Button -->
                <button id="checklist_clear_btn" onclick="checklist_clean()" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px;" title="Create New Checklist">üßπ</button>
                <!-- Delete Button -->
                <button id="checklist_delete_btn" onclick="window.delete_item_from_spinner('checklist_spinner', 'CHECKLIST', 'checklist_field')" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px;" title="Delete checklist">üóëÔ∏è</button>
                <!-- Spinner -->
                <select id="checklist_spinner" class="tile-value-dropdown" style="flex: 1; font-size: 12px; font-weight: normal;">
                    <option value="">Select and Load</option>
                </select>
                <!-- Save button -->
                <button id="checklist_save_btn" onclick="window.save_checklist_to_json('checklist_field')" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px;" title="Save Checklist">üíæ</button>
            </div>
        </div>

        <!-- Personal items -->
        <div class="collapsible" data-title="Personal">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <!-- JavaScript will fill this automatically in  window.populateChecklist("Personal checklist")-->
        </div>
        </div>

        <div class="collapsible" data-title="Passengers">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <!-- JavaScript will fill this automatically in  window.populateChecklist("Navigation checklist")-->
        </div>
        </div>

        <div class="collapsible" data-title="Flightplan">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <!-- JavaScript will fill this automatically in  window.populateChecklist("Flightplan checklist")-->
        </div>
        </div>

        <div class="collapsible" data-title="Technical">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <!-- JavaScript will fill this automatically in  window.populateChecklist("Technical checklist")-->
        </div>
        </div>

        <div class="collapsible" data-title="Departure (Aircraft)">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <!-- JavaScript will fill this automatically in  window.populateChecklist("Departure checklist")-->
        </div>
        </div>

        <div class="collapsible" data-title="Departure (Aerodrome)">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <!-- JavaScript will fill this automatically in  window.populateChecklist("Departure checklist")-->
        </div>
        </div>

        <div class="collapsible" data-title="Arrival (Aircraft)">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <!-- JavaScript will fill this automatically in  window.populateChecklist("Arrival checklist")-->
        </div>
        </div>

        <div class="collapsible" data-title="Arrival (Aerodrome)">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <!-- JavaScript will fill this automatically in  window.populateChecklist("Arrival checklist")-->
        </div>
        </div>

        <div class="collapsible" data-title="Enroute">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <!-- JavaScript will fill this automatically in  window.populateChecklist("Arrival checklist")-->
        </div>
        </div>

        <div class="collapsible" data-title="Various">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <!-- JavaScript will fill this automatically in  window.populateChecklist("Various checklist")-->
        </div>
        </div>

        <div class="collapsible" data-title="Final">
        <div class="collapsible-header"></div>
        <div class="collapsible-content">
            <!-- JavaScript will fill this automatically in  window.populateChecklist("Final checklist")-->
        </div>
        </div>

        <div class="border-round-eged">
            <div class="info" style="margin-bottom: 14px; font-size: 12px;">Personalize your checklist by adding or removing items.</div>
            <div class="wind-grid" style="display: flex; align-items: center; gap: 8px;">
                <!-- Remove Button -->
                <button id="checklist_item_del_btn" onclick="window.checklist_update_catagories('drop')" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px; margin-left: 4px;" title="Check the items then click this remove button to remove the items from the checklist.">‚ûñ</button>
                <!-- Catagories -->
                <select id="checklist_catagory_field" class="tile-value-dropdown">
                    <option value="">Catagories</option>
                </select>
                <!-- Inputfield -->
                <input id="checklist_item_field" type="text" class="tile-value" style="background-color: #ffffff;">
                <!-- Save button -->
                <button id="checklist_item_add_btn" onclick="window.checklist_update_catagories('add')" style="display: flex; justify-content: center; align-items: center; background-color: transparent; border: none; color: #666; cursor: pointer; width: 30px; height: 30px;" title="Add item to checklist">‚ûï</button>
            </div>
        </div>

        <div class="button-row">
            <button id="checklist_print"
                    type="button"
                    title="Print checklist"
                    aria-label="Print checklist"
                    onclick="checklist_print()"
                    style="background-color: #006280; border: 1px solid #333333; color: #ffffff; padding: 8px 12px; border-radius: 8px; cursor: pointer;">
                    üñ®Ô∏è Print Checklist
            </button>
        </div>

    </div>




<script>
    // MAKE REAL OFFLINE APP WITH SERVICEWORK AND SW.JS
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js')
        .then(() => console.log('Service Worker registered'))
        .catch(err => console.error('SW registration failed', err));
    }

    // // Create collapsible sections for each checklist category and wire up lazy population
    // function createChecklistSections(containerId = 'checklist_sections') {
    //   console.log('> func: createChecklistSections()');
    //   const container = document.getElementById(containerId);
    //   if (!container) {
    //     console.warn(`Checklist container "${containerId}" not found`);
    //     return;
    //   }

    function populateChecklistCatagories() {
      console.log(`> func: populateChecklistCatagories()`);
      // Get a reference to the checklist_key_field select element
      const select = document.getElementById("checklist_catagory_field");

      // Clear any existing options (except for the first placeholder)
      select.innerHTML = '<option value="">Categories</option>';

      // Iterate over each key in window.flight_plan_data['CHECKLIST']
      for (const key in window.flight_plan_data['CHECKLIST']) {
        // Get the dictionary associated with the key
        const data = window.flight_plan_data['CHECKLIST'][key];

        // Only append an option if there is at least one item in the dictionary
        if (typeof data === 'object' && data !== null && Object.keys(data).length > 0) {
          // Create a new option element for the key
          const option = document.createElement("option");
          option.value = key;
          option.textContent = key;

          // Append the new option to the select element
          select.appendChild(option);
        }
      }
    }


    // Function to populate a collapsible section from window.CHECKLIST
    function colorChecklistMenu(header, trueCount, total) {
      // console.log(`   >Total entries: ${total}. Nr checked: ${trueCount}`)
      // Set color
      if (total === 0 && trueCount === 0) {
          // No items present ‚Äî mark with light orange
          header.style.backgroundColor = '#FFDAB9';
          header.style.color = '#333333';
      } else if (trueCount === total) {
          header.style.backgroundColor = 'green';
          header.style.color = 'white';
      } else {
          header.style.backgroundColor = '';
          header.style.color = '';
      }

    }
    function populateChecklist(category) {
      console.log(`> func: populateChecklist(${category})`);

      const collapsible = document.querySelector(`[data-title="${category}"]`);
      // Normalize category string by removing the word "checklist" (case-insensitive) and trimming whitespace
      category = category.toLowerCase().replace(/checklist/gi, '').trim();

      if (!collapsible) {
        // console.log(`   >Collapsible with title "${category} checklist" not found`);
        return;
      }

      const header = collapsible.querySelector('.collapsible-header');
      const content = collapsible.querySelector('.collapsible-content');
      // const items = window.CHECKLIST[category];
      const items = window.flight_plan_data['CHECKLIST'][category];

      // If items is an empty object, hide the entire collapsible/menu and exit early
      if (typeof items === 'object' && items !== null && Object.keys(items).length === 0) {
        // Hide the collapsible so empty categories don't appear in the UI
        collapsible.style.display = 'none';
        if (header) header.style.display = 'none';
        return;
      } else {
        // Ensure visible if there are items (in case it was previously hidden)
        collapsible.style.display = '';
        if (header) header.style.display = '';
      }

      if (!items) {
        console.warn(`No data found for ${category} in window.CHECKLIST`);
        return;
      }

      // Generate checkbox HTML for each item
      content.innerHTML = Object.entries(items)
        .map(([label, checked]) =>
          `<label style="display: block; text-align: left;"><input type="checkbox" ${checked ? 'checked' : ''} data-label="${label}"> ${label}</label>`
        ).join('\n');

      // Set color of the menu
      const entries = Object.entries(items || {});
      const total = entries.length;
      let trueCount = Object.values(window.flight_plan_data['CHECKLIST'][category]).filter(value => value === true).length;
      colorChecklistMenu(header, trueCount, total)

      // Add event listeners to update window.flight_plan_data['CHECKLIST'] when checkboxes change
      content.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', function(e) {
          const label = e.target.getAttribute('data-label');
          const checked = e.target.checked;
          window.flight_plan_data['CHECKLIST'][category][label] = checked;
          console.log(`   >Updated ${category}.${label} to ${checked}`);

          // Count how many are checked
          trueCount = Object.values(window.flight_plan_data['CHECKLIST'][category]).filter(value => value === true).length;
          // Set color of the menu
          colorChecklistMenu(header, trueCount, total)
        });
      });
    }


</script>





<script>
    document.addEventListener("DOMContentLoaded", () => {
        const collapsibles = document.querySelectorAll(".collapsible");

        collapsibles.forEach(block => {
            const header = block.querySelector(".collapsible-header");
            const content = block.querySelector(".collapsible-content");

            // Set the title from data-title attribute
            header.textContent = block.dataset.title || "Untitled";

            header.addEventListener("click", () => {
                block.classList.toggle("open");

                if (block.classList.contains("open")) {
                    content.style.maxHeight = content.scrollHeight + "px";
                } else {
                    content.style.maxHeight = null;
                }
            });
        });
    });

    // function toggleCollapsibleMenu(fieldId) {
    //     const block = document.getElementById(fieldId);
    //     if (!block) return;
    //     const content = block.querySelector('.collapsible-content');
    //     block.classList.toggle('open');
    //     if (block.classList.contains('open')) {
    //         content.style.maxHeight = content.scrollHeight + "px";
    //     } else {
    //         content.style.maxHeight = null;
    //     }
    // }
    // window.toggleCollapsibleMenu = toggleCollapsibleMenu;


    function syncFields(className) {
        // SYNC FIELDS OF DEPARTURE_ICAO AND DEPARTURE_ICAO_2
        const fields = document.querySelectorAll('.' + className);
        fields.forEach(field => {
            field.addEventListener('input', e => {
                fields.forEach(f => {
                    if (f !== e.target) f.value = e.target.value.toUpperCase();
                });
            });
        });
    }

    syncFields('sync-departure');
    syncFields('sync-arrival');
</script>


<script>
    let routeMap = null;
    let routeLine = null;
    let routeMarkers = [];
    // let waypoints = [];
    let waypointMarkers = [];
    let airportLayer = null;
    let airportData = null;
    let airspaceLayer = null;
    let TMZLayer = null;


    // Define base layers
    const baseLayers = {
        'OpenStreetMap': L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' }),
        'OpenTopoMap': L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17, attribution: '&copy; OpenTopoMap' }),
        // 'Carto Voyager': L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { subdomains: 'abcd', attribution: '&copy; CARTO' }),
    };

    // Initialize map
    function initRouteMap() {
        console.log('Initializing route map');
        if (routeMap) {
            routeMap.remove();
            routeMap = null;
        }

        routeMap = L.map('route-map', {
            zoomControl: true,
            dragging: true,
            touchZoom: true,
            scrollWheelZoom: true,
            layers: [baseLayers['OpenStreetMap']] // default layer
        });

        routeMap.setView([52, 5], 6);

        // Handle layer selection
        const layerSelect = document.getElementById('layer-select');
        layerSelect.onchange = function() {
            const selectedLayer = this.value;
            Object.values(baseLayers).forEach(layer => routeMap.removeLayer(layer));
            baseLayers[selectedLayer].addTo(routeMap);
        };

        // Force resize to render correctly
        setTimeout(() => routeMap.invalidateSize(), 100);
    }

    // Update route
    async function updateRoute() {
        console.log('Updating route and checking for airport data');
        // Clear existing route line
        if (routeLine) {
            routeMap.removeLayer(routeLine);
            routeLine = null;
        }
        // Clear existing route markers
        routeMarkers.forEach(marker => routeMap.removeLayer(marker));
        routeMarkers = [];

        const depLatLon = window.flight_plan_data?.DEPARTURE_LATLON || [null, null];
        const arrLatLon = window.flight_plan_data?.ARRIVAL_LATLON || [null, null];
        const df = window.AERODROME_DATA;
        // console.log('Raw coordinates - Departure:', depLatLon, 'Arrival:', arrLatLon);

        // Clear existing airport layer
        if (airportLayer) {
            routeMap.removeLayer(airportLayer);
            airportLayer = null;
        }

        // Reset airport data
        airportData = null;

        // Use departure data as default
        console.log('Departure data available:', df ? 'Yes' : 'No');

        if (df) {
            // Create fresh airport data
            airportData = createAirportGeoJSON(df);

            // Display airports if checkbox is checked
            if (document.getElementById('aviation-toggle').checked) {
                toggleAirportLayer();
            }
        }


        if (!depLatLon?.[0] || !arrLatLon?.[0]) return;

        if (routeLine) routeLine.remove();
        routeMarkers.forEach(m => m.remove());
        routeMarkers = [];

        const depCoords = [depLatLon[0], depLatLon[1]];
        const arrCoords = [arrLatLon[0], arrLatLon[1]];
        const weight_line = 8;

        // Create or update initial waypoints array including departure and arrival while preserving user-added waypoints
        if (!Array.isArray(window.waypoints) || window.waypoints.length < 2) {
            // No existing waypoints (first load) ‚Äî initialize with departure and arrival
            window.waypoints = [depCoords, arrCoords];
        } else {
            // Preserve existing intermediate waypoints added by the user.
            // Ensure the first and last points always match current departure and arrival.
            const eps = 1e-6;
            function coordsEqual(a, b) {
                // return Math.abs(a[0] - b[0]) < eps && Math.abs(a[1] - b[1]) < eps;
                return (a[0] - b[0]) < eps && (a[1] - b[1]) < eps;
            }
            // Update departure (first) point if it changed
            if (!coordsEqual(window.waypoints[0], depCoords)) {
                window.waypoints[0] = depCoords;
            }
            // Update arrival (last) point if it changed
            if (!coordsEqual(window.waypoints[window.waypoints.length - 1], arrCoords)) {
                window.waypoints[window.waypoints.length - 1] = arrCoords;
            }
            // If somehow waypoints were reduced to <2, re-initialize
            if (window.waypoints.length < 2) {
                window.waypoints = [depCoords, arrCoords];
            }
        }

        // Create the route line with waypoints
        routeLine = L.polyline(window.waypoints, {
            color: '#8A00C4',
            weight: weight_line,
            opacity: 0.6,
            smoothFactor: 1,
            zIndex: 6000,  // Highest z-index to stay above everything
            pane: 'markerPane',  // Use marker pane to ensure line stays on top
            interactive: true    // Make line clickable for adding waypoints
        }).addTo(routeMap);

        // Add waypoint markers
        updateWaypoints();

        // Add click handler to the line to create new waypoints
        routeLine.on('click', function(e) {
            // Highlight the line when clicked
            routeLine.setStyle({weight: 5, opacity: 1});
            setTimeout(() => routeLine.setStyle({weight: weight_line, opacity: 0.8}), 200);
            const newPoint = [e.latlng.lat, e.latlng.lng];
            // Find the closest segment and insert the new point
            let minDist = Infinity;
            let insertIndex = 1;

            for (let i = 0; i < window.waypoints.length - 1; i++) {
                const dist = pointToSegmentDistance(newPoint, window.waypoints[i], window.waypoints[i + 1]);
                if (dist < minDist) {
                    minDist = dist;
                    insertIndex = i + 1;
                }
            }

            window.waypoints.splice(insertIndex, 0, newPoint);
            updateWaypoints();
        });

        const depICAO = window.flight_plan_data?.DEPARTURE_ICAO_CITY || 'Departure';
        const arrICAO = window.flight_plan_data?.ARRIVAL_ICAO_CITY || 'Arrival';

        routeMarkers.push(
            L.marker(depCoords, {
                draggable: false,
                title: depICAO,
                zIndexOffset: 7000 // Ensure departure marker stays on top
            })
                .addTo(routeMap)
                .bindPopup(depICAO, { closeButton: false })
        );
        routeMarkers.push(
            L.marker(arrCoords, {
                draggable: false,
                title: arrICAO,
                zIndexOffset: 7000 // Ensure arrival marker stays on top
            })
                .addTo(routeMap)
                .bindPopup(arrICAO, { closeButton: false })
        );

        routeMap.fitBounds(routeLine.getBounds(), {
            padding: [50, 50],
            maxZoom: 12
        });

        // Add tooltip to explain right-click functionality
        waypointMarkers.forEach(marker => {
            marker.bindTooltip("Right-click to remove waypoint", {
                direction: 'top',
                offset: [0, -10]
            });
        });
    }

    // Helper function to calculate point to segment distance
    function pointToSegmentDistance(p, v1, v2) {
        const x = p[0], y = p[1];
        const x1 = v1[0], y1 = v1[1];
        const x2 = v2[0], y2 = v2[1];

        const A = x - x1;
        const B = y - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;

        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;

        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = x - xx;
        const dy = y - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Function to update waypoint markers and route line
    function updateWaypoints() {
        // Clear existing waypoint markers
        waypointMarkers.forEach(marker => routeMap.removeLayer(marker));
        waypointMarkers = [];

        // Update route line
        routeLine.setLatLngs(window.waypoints);

        // Create new waypoint markers (skip first and last points which are airports)
        for (let i = 1; i < window.waypoints.length - 1; i++) {
            const marker = L.marker(window.waypoints[i], {
                draggable: true,
                icon: L.divIcon({
                    className: 'waypoint-icon',
                    html: '<div style="background-color: #FFFFFF; width: 13px; height: 13px; border-radius: 50%; border: 1px solid black;"></div>',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                }),
                zIndexOffset: 3000
            }).addTo(routeMap);

            // Add drag and hover handlers
            marker.on('drag', function(e) {
                window.waypoints[i] = [e.latlng.lat, e.latlng.lng];
                routeLine.setLatLngs(window.waypoints);
            });

            marker.on('contextmenu', function() {
                // Remove waypoint on right click
                window.waypoints.splice(i, 1);
                updateWaypoints();
            });

            waypointMarkers.push(marker);
        }
    }


    function toggleFullscreen() {
        const mapContainer = document.getElementById('map-container');
        const fullscreenBtn = document.getElementById('fullscreen-btn');

        if (!mapContainer || !fullscreenBtn) {
            console.error('Required elements not found for fullscreen toggle');
            return;
        }

        const enterIcon = fullscreenBtn.querySelector('.fullscreen-enter');
        const exitIcon = fullscreenBtn.querySelector('.fullscreen-exit');

        if (!enterIcon || !exitIcon) {
            console.error('Fullscreen icons not found');
            return;
        }

        const isFullscreen =
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement ||
            mapContainer.classList.contains('mobile-fullscreen');

        if (!isFullscreen) {
            // Enter fullscreen
            if (mapContainer.requestFullscreen) {
                mapContainer.requestFullscreen().catch(() => {});
            } else if (mapContainer.webkitRequestFullscreen) {
                mapContainer.webkitRequestFullscreen();
            } else if (mapContainer.mozRequestFullScreen) {
                mapContainer.mozRequestFullScreen();
            } else if (mapContainer.msRequestFullscreen) {
                mapContainer.msRequestFullscreen();
            } else {
                // Fallback for iPhone / mobile fullscreen
                mapContainer.classList.add('mobile-fullscreen');
                document.body.classList.add('no-scroll');
            }
            enterIcon.style.display = 'none';
            exitIcon.style.display = 'inline';
            fullscreenBtn.style.position = 'fixed';
            fullscreenBtn.style.zIndex = '2000';
        } else {
            // Exit fullscreen
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            } else {
                mapContainer.classList.remove('mobile-fullscreen');
                document.body.classList.remove('no-scroll');
            }
            enterIcon.style.display = 'inline';
            exitIcon.style.display = 'none';
            fullscreenBtn.style.position = 'absolute';
            fullscreenBtn.style.zIndex = '1000';
        }

        // Ensure map resizes properly
        setTimeout(() => {
            if (window.routeMap) window.routeMap.invalidateSize();
        }, 300);
    }


    // Handle fullscreen changes from any source
    function handleFullscreenChange() {
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        if (!fullscreenBtn) return;

        const enterIcon = fullscreenBtn.querySelector('.fullscreen-enter');
        const exitIcon = fullscreenBtn.querySelector('.fullscreen-exit');
        if (!enterIcon || !exitIcon) return;

        const isFullscreen = document.fullscreenElement ||
                           document.webkitFullscreenElement ||
                           document.mozFullScreenElement ||
                           document.msFullscreenElement;

        if (!isFullscreen) {
            enterIcon.style.display = 'inline';
            exitIcon.style.display = 'none';
            fullscreenBtn.style.position = 'absolute';
            fullscreenBtn.style.zIndex = '1000';
        } else {
            enterIcon.style.display = 'none';
            exitIcon.style.display = 'inline';
            fullscreenBtn.style.position = 'fixed';
            fullscreenBtn.style.zIndex = '2000';
        }
    }

    // Listen for fullscreen changes
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);


    // Initialize map and route on DOM load
    // document.addEventListener('DOMContentLoaded', () => {
    //     initRouteMap();
    //     updateRoute();

    //     // Handle tab clicks if present
    //     document.querySelectorAll('.tablinks').forEach(tab => {
    //         tab.addEventListener('click', () => {
    //             console.log('Tab clicked');
    //             setTimeout(() => {
    //                 routeMap.invalidateSize();
    //                 updateRoute();
    //             }, 100);
    //         });
    //     });
    // });

    // Simple example with a few major airports
    // const airportData = {
    //   "type": "FeatureCollection",
    //   "features": [
    //     { "type": "Feature", "properties": { "name": "Schiphol Airport (EHAM)" }, "geometry": { "type": "Point", "coordinates": [4.763385, 52.310539] } },
    //     { "type": "Feature", "properties": { "name": "Amsterdam Lelystad (EHLE)" }, "geometry": { "type": "Point", "coordinates": [5.525, 52.460] } },
    //     { "type": "Feature", "properties": { "name": "Rotterdam The Hague (EHDR)" }, "geometry": { "type": "Point", "coordinates": [4.435, 51.950] } }
    //   ]
    // };

    // Create GeoJSON from aerodrome data
    function createAirportGeoJSON(df) {
        const features = [];

        // console.log('Creating airport GeoJSON from data:', df);
        if (df) {
            for (const row of df) {
                // console.log('Processing row:', row);
                // Convert Proxy to regular object
                //
                const data = {
                    lat: row.lat?.valueOf(),
                    lon: row.lon?.valueOf(),
                    city_icao: row.city_icao?.valueOf(),
                    icao: row.icao?.valueOf(),
                    use: row.use?.valueOf(),
                    country: row.country?.valueOf(),
                    runways: String(row.runways?.valueOf() || '').toLowerCase(),
                    AERODROME_CTR: row.AERODROME_CTR?.valueOf(),
                    elevation_aerodrome: row.elevation_aerodrome?.valueOf()
                };


                // Determine runway type from runway string
                if (data.lat && data.lon && data.city_icao) {
                    // console.log('Valid coordinates found:', data.lat, data.lon, data.city_icao, data.use);
                        features.push({
                            "type": "Feature",
                            "properties": {
                                "name": data.city_icao,
                                "icao": data.icao,
                                "ctr": data.AERODROME_CTR ? true : false,
                                "elevation": data.elevation_aerodrome || 'N/A',
                                "use": data.use || 'public',
                                "runways": data.runways,
                                "runway_number": data.runway_number,
                                "country": data.country,
                            },
                        "geometry": {
                            "type": "Point",
                            "coordinates": [parseFloat(data.lon), parseFloat(data.lat)]
                        }
                    });
                }
            }
        }

        return {
            "type": "FeatureCollection",
            "features": features
        };
    }


    function extractRunwayNumbers(runwaysString) {
        if (typeof runwaysString !== "string") return [];

        // Extract ALL occurrences of number: [...]
        // Supports 'number' or "number"
        const matches = runwaysString.match(/["']number["']\s*:\s*\[([^\]]*)\]/g);

        if (!matches) return [];

        let allNumbers = [];

        for (const item of matches) {

            // Extract inside brackets of this specific occurrence
            const inside = item.match(/\[([^\]]*)\]/);
            if (!inside) continue;

            // Extract all quoted elements inside the brackets
            const nums = inside[1].match(/["']([^"']+)["']/g);
            if (!nums) continue;

            // Clean + convert to integer
            nums.forEach(n => {
                const clean = n.replace(/['"]/g, "").trim();
                const val = parseInt(clean, 10);
                if (!isNaN(val)) allNumbers.push(val);
            });
        }

        // Fallback only if *no valid runway numbers* found
        if (allNumbers.length === 0) return [45, 315];

        return allNumbers;
    }

    function selectRunwayIndices(runwayNumbers) {
        if (runwayNumbers.length >= 6) return [0, 3, 5];
        if (runwayNumbers.length >= 4) return [0, 3];
        if (runwayNumbers.length >= 2) return [0];
        return []; // not enough info
    }

    function buildRunwayRects(runwayNumbers, runwayColor) {
        const idx = selectRunwayIndices(runwayNumbers);
        if (idx.length === 0) return ""; // nothing to draw

        return idx
            .map(i => {
                const heading = runwayNumbers[i] * 10; // convert to degrees
                return `
                    <rect x="14" y="4" width="4" height="24"
                          fill="${runwayColor}"
                          stroke="#333" stroke-width="1"
                          fill-opacity="0.8" stroke-opacity="0.8"
                          transform="rotate(${heading} 16 16)" />
                `;
            })
            .join("\n");
    }

    function toggleAirportLayer() {
        // console.log('Toggle airport layer called');
        if (document.getElementById('aviation-toggle').checked) {
            if (airportLayer) return; // Layer already exists
            if (!airportData) return; // No data to display

            console.log('Adding airport layer to map');
            // Create a feature group to hold markers and circles with high z-index
            airportLayer = L.featureGroup({
                zIndex: 1000  // Ensure airport layer stays on top of everything
            }).addTo(routeMap);

            // Add GeoJSON features
            L.geoJSON(airportData, {
                pointToLayer: function(feature, latlng) {
                    const props = feature.properties;
                    const isMilitary = props.use.toLowerCase() === 'military';
                    let runwayColor = '#2196F3'; // Blue for others;
                    let circleColor = '#FFFFFF'; // White for others;
                    let runwayType = props.runways.includes('asphalt') ? 'Hard' : props.runways.includes('grass') ? 'Soft' : 'Unknown';
                    let runwayNumbers = extractRunwayNumbers(props.runways)
                    let fillOpacity = 0.3


                    const popupContent = `
                        <b>${props.name}</b>
                        <div style='width: 200px; padding: 10px; border: 1px solid lightgrey; border-radius: 5px; background-color: #f9f9f9;'>
                            <b>Country:</b> ${props.country}<br>
                            <b>Type:</b> ${props.use}<br>
                            <b>CTR:</b> ${props.ctr || isMilitary ? 'Yes' : 'No'}<br>
                            <b>Runway Elevation:</b> ${props.elevation} ft<br>
                            <b>Runway Surface:</b> ${runwayType}
                        </div>
                    `;

                    if (isMilitary) {
                        circleColor = '#8B0000'; // Red for military
                        fillOpacity = 0.15;
                    } else if (props.ctr || props.runways.includes('asphalt')) {
                        circleColor = '#FF69B4';  // pink for CTR
                        fillOpacity = 0.15;
                    } else {
                        circleColor = '#FFFFFF'; // Blue for other
                    }

                    if (runwayType === 'Hard') {
                        runwayColor = '#666666'; //Gray for hard/asphalt
                    } else if (runwayType === 'Soft') {
                        runwayColor = '#8BC34A'; //Green for soft/grass
                    } else {
                        runwayColor = '#2196F3'; //Blue for other
                    }

                    const runwayRects = buildRunwayRects(runwayNumbers, runwayColor);
                    const airstripIcon = L.divIcon({
                        className: 'airstrip-marker-icon',
                        html: `
                            <svg width="32" height="32" viewBox="0 0 32 32">
                                <circle cx="16" cy="16" r="8"
                                        fill="${circleColor}"
                                        stroke="#333"
                                        stroke-width="1.5"
                                        fill-opacity="0.9"
                                        stroke-opacity="0.8"/>
                                ${runwayRects}
                            </svg>
                        `,
                        iconSize: [32, 32],
                        iconAnchor: [16, 16]
                    });


                    // Create marker with custom icon
                    const marker = L.marker(latlng, {
                        title: props.name,
                        icon: airstripIcon, //markerIcon,
                        pane: 'markerPane',  // Use marker pane to ensure markers stay on top
                        zIndexOffset: 4000   // High z-index offset to stay above other markers
                    }).bindPopup(popupContent);

                    // Add to feature group
                    airportLayer.addLayer(marker);

                    // If it's a CTR or isMilitary, add a circle with color based on use
                    if (props.ctr || isMilitary) {
                            const circle = L.circle(latlng, {
                                radius: 14900, // 5NM in meters
                                color: circleColor,
                                weight: 1,
                                // opacity: 0.3,
                                fillOpacity: fillOpacity,
                                pane: 'markerPane'  // Use marker pane to ensure circles stay on top
                            });
                            circle.bindPopup(popupContent);
                            airportLayer.addLayer(circle);
                    }
                    return marker;
                }
            });
        } else {
            if (airportLayer) {
                routeMap.removeLayer(airportLayer);
                airportLayer = null;
                console.log('Removed airport layer');
            }
        }
    }

    function loadAirspaceData() {
        // Return the airspaces data from Python (attached to window)
        if (window.airspaces) {
            return window.airspaces;
        } else {
            console.error("‚ö†Ô∏è No airspace data is available for this region.");
            js.window.alert('‚ö†Ô∏è No airspace data is available for this region.');
            return null;
        }
    }

    // Global variable to store all airspace layers
    let airspaceLayerGroups = {};

    async function toggleAirspaceLayer() {
        const airspaceCheckbox = document.getElementById('airspace-toggle');
        const TMZCheckbox = document.getElementById('TMZ-toggle');
        const CTACheckbox = document.getElementById('CTA_TMA-toggle');
        const dangerCheckbox = document.getElementById('danger-toggle');
        const prohibitedCheckbox = document.getElementById('prohibited-toggle');

        if (!airspaceCheckbox) return;

        if (!window.airspaces) {
            console.error('No airspace data available');
            // airspaceCheckbox.checked = false;
            TMZCheckbox.checked = false;
            CTACheckbox.checked = false;
            dangerCheckbox.checked = false;
            prohibitedCheckbox.checked = false;
            return;
        }


        // Always clear existing layers first
        Object.values(airspaceLayerGroups).forEach(layer => {
            if (routeMap.hasLayer(layer)) {
                routeMap.removeLayer(layer);
            }
        });
        airspaceLayerGroups = {};

        if (airspaceCheckbox.checked) {
            console.log('Adding all airspace layers');
            // Create new layers
            const altitudeValue = parseInt(document.getElementById('airspace-altitude').value) || 1500;
            const layers = createAirspaceLayer(window.airspaces, routeMap, altitudeValue);

            // Store and add each layer by type
            if (layers) {
                Object.entries(layers).forEach(([type, layer]) => {
                    if (layer) {
                        airspaceLayerGroups[type] = layer;
                        layer.addTo(routeMap);
                    }
                });
            }
        } else {
            console.log('Removed all airspace layers');
        }

        // Sync TMZ checkbox state with main airspace toggle
        if (!TMZCheckbox.checked) {
            // TMZCheckbox.checked = airspaceCheckbox.checked;
            toggleTMZLayer();
        }

        // Sync other checkboxes with main airspace toggle
        if (!CTACheckbox.checked) {
            // CTACheckbox.checked = airspaceCheckbox.checked;
            toggleCTATMALayer();
        }

        if (!dangerCheckbox.checked) {
            // dangerCheckbox.checked = airspaceCheckbox.checked;
            toggleDangerLayer();
        }

        if (!prohibitedCheckbox.checked) {
            // prohibitedCheckbox.checked = airspaceCheckbox.checked;
            toggleProhibitedLayer();
        }
    }

    async function toggleCTATMALayer() {
        const checkbox = document.getElementById('CTA_TMA-toggle');
        if (!checkbox || !window.airspaces) return;

        const filtered = {};
        Object.entries(window.airspaces).forEach(([key, space]) => {
            const at = (space.area_type || '').toLowerCase();
            if (at.includes('cta') || at.includes('tma')) {
                filtered[key] = space;
            }
        });

        if (airspaceLayerGroups.CTA_TMA && routeMap.hasLayer(airspaceLayerGroups.CTA_TMA)) {
            routeMap.removeLayer(airspaceLayerGroups.CTA_TMA);
            delete airspaceLayerGroups.CTA_TMA;
        }

        if (checkbox.checked) {
            const altitudeValue = parseInt(document.getElementById('airspace-altitude').value) || 1500;
            const layers = createAirspaceLayer(filtered, routeMap, altitudeValue);
            if (layers && layers.CTA_TMA) {
                airspaceLayerGroups.CTA_TMA = layers.CTA_TMA;
                layers.CTA_TMA.addTo(routeMap);
            }
        } else {
            console.log('Removed CTA/TMA layer');
        }
    }

    async function toggleDangerLayer() {
        const checkbox = document.getElementById('danger-toggle');
        if (!checkbox || !window.airspaces) return;

        const filtered = {};
        Object.entries(window.airspaces).forEach(([key, space]) => {
            const at = (space.area_type || '').toLowerCase();
            if (at.includes('danger')) {
                filtered[key] = space;
            }
        });

        if (airspaceLayerGroups.danger && routeMap.hasLayer(airspaceLayerGroups.danger)) {
            routeMap.removeLayer(airspaceLayerGroups.danger);
            delete airspaceLayerGroups.danger;
        }

        if (checkbox.checked) {
            const altitudeValue = parseInt(document.getElementById('airspace-altitude').value) || 1500;
            const layers = createAirspaceLayer(filtered, routeMap, altitudeValue);
            if (layers && layers.danger) {
                airspaceLayerGroups.danger = layers.danger;
                layers.danger.addTo(routeMap);
            }
        } else {
            console.log('Removed danger layer');
        }
    }

    async function toggleProhibitedLayer() {
        const checkbox = document.getElementById('prohibited-toggle');
        if (!checkbox || !window.airspaces) return;

        const filtered = {};
        Object.entries(window.airspaces).forEach(([key, space]) => {
            const at = (space.area_type || '').toLowerCase();
            if (at.includes('prohibited')) {
                filtered[key] = space;
            }
        });

        if (airspaceLayerGroups.prohibited && routeMap.hasLayer(airspaceLayerGroups.prohibited)) {
            routeMap.removeLayer(airspaceLayerGroups.prohibited);
            delete airspaceLayerGroups.prohibited;
        }

        if (checkbox.checked) {
            const altitudeValue = parseInt(document.getElementById('airspace-altitude').value) || 1500;
            const layers = createAirspaceLayer(filtered, routeMap, altitudeValue);
            if (layers && layers.prohibited) {
                airspaceLayerGroups.prohibited = layers.prohibited;
                layers.prohibited.addTo(routeMap);
            }
        } else {
            console.log('Removed prohibited layer');
        }
    }

    async function toggleTMZLayer() {
        const TMZCheckbox = document.getElementById('TMZ-toggle');
        if (!TMZCheckbox || !window.airspaces) return;

        // Filter and process only TMZ areas
        const tmzAirspaces = {};
        Object.entries(window.airspaces).forEach(([key, space]) => {
            if (space.area_type && space.area_type.toLowerCase().includes('tmz')) {
                tmzAirspaces[key] = space;
            }
        });

        // Always remove existing TMZ layer first
        if (airspaceLayerGroups.TMZ && routeMap.hasLayer(airspaceLayerGroups.TMZ)) {
            routeMap.removeLayer(airspaceLayerGroups.TMZ);
            delete airspaceLayerGroups.TMZ;
        }

        if (TMZCheckbox.checked) {
            console.log('Adding TMZ layer');
            const altitudeValue = parseInt(document.getElementById('airspace-altitude').value) || 1500;
            const layers = createAirspaceLayer(tmzAirspaces, routeMap, altitudeValue);

            // Only add TMZ layer if it exists
            if (layers && layers.TMZ) {
                airspaceLayerGroups.TMZ = layers.TMZ;
                layers.TMZ.addTo(routeMap);
            }
        } else {
            console.log('Removed TMZ layer');
        }
    }

    // Initialize all airspace feature groups
    function initAirspaceLayerGroups(routeMap) {
        const layers = {
            CTR_CTZ: L.featureGroup().addTo(routeMap),
            CTA_TMA: L.featureGroup().addTo(routeMap),
            ATZ: L.featureGroup().addTo(routeMap),
            MATZ: L.featureGroup().addTo(routeMap),
            TMZ: L.featureGroup().addTo(routeMap),
            TRA: L.featureGroup().addTo(routeMap),
            prohibited: L.featureGroup().addTo(routeMap),
            danger: L.featureGroup().addTo(routeMap),
            restricted: L.featureGroup().addTo(routeMap),
            parachuting: L.featureGroup().addTo(routeMap),
            gliding: L.featureGroup().addTo(routeMap),
            various: L.featureGroup().addTo(routeMap),
            // NOTAM: L.featureGroup().addTo(routeMap),
            // NOTAM_ENROUTE: L.featureGroup().addTo(routeMap),
            // Optional runway layers
            // hard_runway: L.featureGroup().addTo(routeMap),
            // soft_runway: L.featureGroup().addTo(routeMap),
            // private_runway: L.featureGroup().addTo(routeMap)
        };

        const area_types = {
            CTR_CTZ: { markertype: "polygon", fill: true, fillColor: "#FF69B4", edgeColor: "#FF69B4", opacity: 0.3, weight: 1, layer: layers.CTR_CTZ, zIndex: 300 },
            CTA_TMA: { markertype: "polygon", fill: true, fillColor: '#000000', edgeColor: "#696969", opacity: 0.1, weight: 1.5, layer: layers.CTA_TMA, zindex: 100 },
            ATZ: { markertype: "polygon", fill: true, fillColor: "#FF69B4", edgeColor: "#FF69B4", opacity: 0.15, weight: 1, layer: layers.ATZ, zIndex: 300 },
            MATZ: { markertype: "circle", fill: true, fillColor: "#8B0000", edgeColor: "#8B0000", opacity: 0.15, weight: 1, layer: layers.MATZ, zIndex: 300 },
            TMZ: { markertype: "polygon", fill: true, fillColor: "#DA70D6", edgeColor: "#DA70D6", opacity: 0.1, weight: 1.3, layer: layers.TMZ, zIndex: 10 },
            TRA: { markertype: "polygon", fill: true, fillColor: "#FA8072", edgeColor: "#FA8072", opacity: 0.3, weight: 1, layer: layers.TRA, zIndex: 100 },
            prohibited: { markertype: "polygon", fill: true, fillColor: "#8B0000", edgeColor: "#8B0000", opacity: 0.3, weight: 1, layer: layers.prohibited, zindex: 3000 },
            danger: { markertype: "polygon", fill: true, fillColor: "#8B0000", edgeColor: "#8B0000", opacity: 0.3, weight: 1, layer: layers.danger, zindex: 50 },
            restricted: { markertype: "polygon", fill: true, fillColor: "#FF9248", edgeColor: "#FF9248", opacity: 0.3, weight: 1, layer: layers.restricted, zindex: 3000 },
            gliding: { markertype: "polygon", fill: true, fillColor: "#06402B", edgeColor: "#06402B", opacity: 0.3, weight: 1, layer: layers.gliding, zindex: 1000 },
            parachuting: { markertype: "circle", fill: true, fillColor: "#0096FF", edgeColor: "#0096FF", opacity: 0.2, weight: 1, layer: layers.parachuting, zindex: 2500 },
            various: { markertype: "polygon", fill: true, fillColor: "#696969", edgeColor: "#696969", opacity: 0.3, weight: 1, layer: layers.various, zindex: 300 },
            // NOTAM: { markertype: "marker", fill: false, fillColor: "#EFC238", edgeColor: "#EFC238", opacity: 0, weight: 3, layer: layers.NOTAM },
            // NOTAM_ENROUTE: { markertype: "marker", fill: false, fillColor: "#EFC238", edgeColor: "#EFC238", opacity: 0, weight: 3, layer: layers.NOTAM_ENROUTE },
            // hard_runway: { markertype: "circle", fill: true, fillColor: "#696969", edgeColor: "#696969", opacity: 0.5, weight: 1.1, layer: layers.hard_runway },
            // soft_runway: { markertype: "circle", fill: true, fillColor: "#228B22", edgeColor: "#228B22", opacity: 0.5, weight: 1.1, layer: layers.soft_runway },
            // private_runway: { markertype: "circle", fill: true, fillColor: "#ff8c00", edgeColor: "#228B22", opacity: 0.6, weight: 1.1, layer: layers.private_runway }
        };

        return { layers, area_types };
    }

    function createAirspaceLayer(airspaces, routeMap, maxAltitude = 1500) {
        if (!airspaces) return null;
        // Initialize all layers
        const { layers, area_types } = initAirspaceLayerGroups(routeMap);
        // Keep track of currently highlighted layer
        let highlightedLayer = null;

        // Function to handle highlighting
        function highlightAirspace(layer) {
            // Reset previous highlight if exists
            if (highlightedLayer) {
                highlightedLayer.setStyle({
                    weight: highlightedLayer.originalStyle.weight,
                    opacity: highlightedLayer.originalStyle.opacity,
                    fillOpacity: highlightedLayer.originalStyle.fillOpacity,
                    color: highlightedLayer.originalStyle.color,
                    fillColor: highlightedLayer.originalStyle.fillColor
                });
            }

            // Store original style
            layer.originalStyle = {
                weight: layer.options.weight,
                opacity: layer.options.opacity,
                fillOpacity: layer.options.fillOpacity,
                color: layer.options.color,
                fillColor: layer.options.fillColor
            };

            // Apply highlight style
            layer.setStyle({
                weight: layer.originalStyle.weight * 2,
                opacity: 0.8,
                fillOpacity: 0.5,
                color: '#FFFF00',  // Yellow outline for highlighted airspace
            });

            highlightedLayer = layer;

            // Bring to front
            if (layer.bringToFront) {
                layer.bringToFront();
            }
        }


        Object.values(airspaces).forEach((airspace) => {
            if (!airspace.coordinates || airspace.coordinates.length === 0) return;

            const AL = clean_altitude(airspace.altitude_lower);
            const AH = clean_altitude(airspace.altitude_higher);
            const area_type = (airspace.area_type || "").toLowerCase();

            let key = "various";
            let flagToMap = true;
            let radius = 14900;

            // Determine type and flags
            if (area_type.includes("ctr") || area_type.includes("ctz")) { key = "CTR_CTZ"; radius = 14900; }
            else if (area_type.includes("cta") || area_type.includes("tma")) { key = "CTA_TMA"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); }
            else if (area_type.includes("atz") && !area_type.includes("military")) { key = "ATZ"; }
            else if (area_type.includes("atz") && area_type.includes("military")) { key = "MATZ"; radius = 14900; }
            else if (area_type.includes("tmz")) { key = "TMZ"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); }
            else if (area_type.includes("prohibited")) { key = "prohibited"; radius = 5000 }
            else if (area_type.includes("danger")) { key = "danger"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); radius = 2000}
            else if (area_type.includes("restricted") && !area_type.includes("notam")) { key = "restricted"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); }
            else if (area_type.includes("notam")) { key = "NOTAM"; flagToMap = false; }
            else if (area_type.includes("temporary reserved")) { key = "TRA"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); }
            else if (area_type.includes("parachuting")) { key = "parachuting"; radius = 4000; }
            else if (area_type.includes("gliding")) { key = "gliding"; radius = 6000;}
            else if (area_type.includes("laser")) { key = "laser"; flagToMap = false; radius = 2000; }
            else if (area_type.includes("gas venting")) { key = "laser"; flagToMap = false; radius = 2000; }
            else { key = "various"; [flagToMap] = altitude_restriction(AL, AH, maxAltitude); radius = 2000;}

            if (!flagToMap) return;
            // if (key === "various") return;

            const popupContent = `
                <div style="font-size: 0.9em;">
                    <b>${airspace.name}</b>
                    <div style='width:250px; padding:10px; border:1px solid lightgrey; border-radius:5px; background-color:#f9f9f9;'>
                        <b>${airspace.area_type_general}</b><br>
                        <b>Altitude:</b> ${airspace.altitude_lower}${AH ? ` to ${AH} feet` : ""}<br>
                    </div>
                </div>
            `;

            const coords = airspace.coordinates.map(c => [c[0], c[1]]);
            const areaLayer = area_types[key];
            let typeToMap = areaLayer.markertype;
            if (coords.length === 1 && key !== 'ATZ') { typeToMap = "circle"; }
            let layer;

            if (typeToMap === "marker" || typeToMap === "circle") {
                coords.forEach(latlon => {
                    if (typeToMap === "marker") {
                        layer = L.marker(latlon);
                    } else {
                        layer = L.circle(latlon, {
                            radius: radius,
                            color: areaLayer.edgeColor,
                            fillColor: areaLayer.fillColor,
                            fillOpacity: areaLayer.opacity,
                            weight: areaLayer.weight,
                            zIndex: areaLayer.zindex || 400
                        });
                    }
                    // Add click handler
                    layer.on('click', function(e) {
                        highlightAirspace(this);
                    });
                    layer.bindPopup(popupContent).addTo(areaLayer.layer);
                });
            } else if (typeToMap === "polygon") {
                layer = L.polygon(coords, {
                    color: areaLayer.edgeColor,
                    fillColor: areaLayer.fillColor,
                    fillOpacity: areaLayer.opacity,
                    weight: areaLayer.weight,
                    dashArray: areaLayer.dash || null,
                    zIndex: areaLayer.zindex || 300
                });
                // Add click handler
                layer.on('click', function(e) {
                    highlightAirspace(this);
                });
                layer.bindPopup(popupContent).addTo(areaLayer.layer);
            }
        });

        return layers; // return all layer groups separately
    }

    document.addEventListener('DOMContentLoaded', () => {
        const airspaceCheckbox = document.getElementById('airspace-toggle');
        if (airspaceCheckbox) {
            airspaceCheckbox.addEventListener('change', toggleAirspaceLayer);
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        // Airport checkbox
        const airportCheckbox = document.getElementById('aviation-toggle');
        if (airportCheckbox) {
            airportCheckbox.addEventListener('change', toggleAirportLayer);
        } else {
            console.error("Airport checkbox not found in DOM!");
        }


        // Altitude input
        const altitudeInput = document.getElementById('airspace-altitude');
        if (altitudeInput) altitudeInput.addEventListener('change', toggleAirspaceLayer);

        // Airspace checkbox
        const airspaceCheckbox = document.getElementById('airspace-toggle');
        if (airspaceCheckbox) airspaceCheckbox.checked = false;
        if (airspaceCheckbox) airspaceCheckbox.addEventListener('change', toggleAirspaceLayer);

        // TMZ CHECKBOX
        const TMZCheckbox = document.getElementById('TMZ-toggle');
        if (TMZCheckbox) TMZCheckbox.checked = false;

        // CTA CHECKBOX
        const CTACheckbox = document.getElementById('CTA_TMA-toggle');
        if (CTACheckbox) CTACheckbox.checked = false;

        // DANGER CHECKBOX
        const dangerCheckbox = document.getElementById('danger-toggle');
        if (dangerCheckbox) dangerCheckbox.checked = false;

        // PROHIBITED CHECKBOX
        const prohibitedCheckbox = document.getElementById('prohibited-toggle');
        if (prohibitedCheckbox) prohibitedCheckbox.checked = false;


        if (TMZCheckbox) {
            // TMZCheckbox.checked = airspaceCheckbox.checked;
            toggleTMZLayer();
        }
        if (TMZCheckbox) {
            TMZCheckbox.addEventListener('change', toggleTMZLayer);
        }
        if (CTACheckbox) {
            // CTACheckbox.checked = airspaceCheckbox.checked;
            toggleCTATMALayer();
        }
        if (CTACheckbox) CTACheckbox.addEventListener('change', toggleCTATMALayer);

        if (dangerCheckbox) {
            // dangerCheckbox.checked = airspaceCheckbox.checked;
            toggleDangerLayer();
        }
        if (dangerCheckbox) dangerCheckbox.addEventListener('change', toggleDangerLayer);

        if (prohibitedCheckbox) {
            // prohibitedCheckbox.checked = airspaceCheckbox.checked;
            toggleProhibitedLayer();
        }
        if (prohibitedCheckbox) prohibitedCheckbox.addEventListener('change', toggleProhibitedLayer);

        // Expose updateRoute globally
        window.updateRoute = updateRoute;
    });



</script>


<script>

    function createDateTime() {
      console.log("---> createDateTime()");
      document.getElementById('DATETIME').value = nowtime(false);
    }

    // Add save button functionality
    // document.getElementById('save_fields_btn')?.addEventListener('click', () => {
    //   if (pyscriptReady && window.save_flightplan) {
    //     try {
    //       // Get flightplan name
    //       const flightplanName = document.getElementById('FLIGHTPLAN')?.value;
    //       if (!flightplanName) { window.alert("‚ÑπÔ∏è Please enter a flight plan name before saving.");
    //         return;
    //       }

    //       // Save flightplan data to JSON files
    //       window.save_flightplan();
    //       window.alert("‚úÖ Flight plan saved successfully!");

    //     } catch (error) {
    //       console.error("Error saving flightplan data:", error);
    //     }
    //   }
    // });


    function openAerodromeMap(fname) {
        const latlon = window.flight_plan_data[`${fname}_LATLON`];
        const icao = window.flight_plan_data[`${fname}_ICAO`]
        if (latlon && latlon[0] != null && latlon[1] != null) {
            const [lat, lon] = [parseFloat(latlon[0]), parseFloat(latlon[1])];
            const url = `https://www.google.com/maps?q=${lat},${lon}&z=14`;
            // const url = `https://metar-taf.com/airport/${icao}`;
            window.open(url, '_blank');
        } else {
            console.log(`No coordinates available for ${fname} aerodrome`);
        }
    }

</script>

<script>
    /* THIS PART CONTAINS THE WIDGET FUNCTIONS */

    function createAirportWeatherWidget(icao, prefix) {
        if (icao) {
            const awContainer = document.getElementById(`CONTAINER-AIRPORTWEATHER-${prefix}`);
            const awIframe = document.getElementById(`${prefix}-airportweather-iframe`);

            // Show the AirportWeather iframe for the retrieved ICAO (for the given prefix)
            try {
                if (awIframe) {
                    // set the iframe src to the ICAO page on AirportWeather
                    awIframe.src = 'https://airportweather.com/' + icao.toLowerCase();
                }
                if (awContainer) {
                    awContainer.style.display = 'block';
                }
                return true;
            } catch (e) {
                console.warn('Failed to show AirportWeather iframe:', e);
            }
        } else {
            // Hide AirportWeather container when no METAR ICAO available
            try {
                if (awContainer) { awContainer.style.display = 'none'; }
                return false;
            } catch (e) { /* ignore */ }
        }
    }

    function createMetarTafWidget(containerId, icao, name, uniqueSuffix) {
        /*Create and embed a METAR widget for an aerodrome.
        This function creates and embeds a METAR widget for an aerodrome.
        It displays METAR data, from METAR-TAF website by embedding it from metar-taf.com.
        It does so by creating container element and injecting widget into specified container.

        Args:
            containerId (str): ID of container element to create widget in
            icao (str): ICAO code of aerodrome
            name (str): Display name of aerodrome
            uniqueSuffix (str): Unique suffix for widget IDs
        */

        console.log(`üõ´ Creating METAR widget for ${icao}`);
        if (icao === 'unknown') {
            window.alert("‚ÑπÔ∏è Please enter the ICAO code before loading METAR information.");
            return false;
        }

        // Clear previous widget (if any)
        const container = document.getElementById(containerId);
        container.innerHTML = '';

        // Create unique ID for this widget instance
        const widgetId = `metartaf-${uniqueSuffix}`;

        // Create <a> element
        const link = document.createElement('a');
        link.href = `https://metar-taf.com/metar/${icao}`;
        link.id = widgetId;
        link.innerHTML = `METAR ${name}`;
        link.style = "font-size:16px; font-weight:400; color:#000; width:310px; height:435px; display:block";

        // Append link to container
        container.appendChild(link);

        // Create <script> element
        const script = document.createElement('script');
        script.async = true;
        script.defer = true;
        script.crossOrigin = "anonymous";
        script.src = `https://metar-taf.com/embed-js/${icao}?u=39426&qnh=hPa&rh=dp&target=${uniqueSuffix}`;

        // Append script to container
        container.appendChild(script);

        return true;
    }


    function nowtime(utc = false) {
        // Return current date/time as "DD-MM-YYYY HH:MM"
        // Coerce utc to boolean to be robust against truthy/falsy inputs
        const now = new Date();
        const pad = (n) => String(n).padStart(2, '0');

        if (utc) {
            const day = pad(now.getUTCDate());
            const month = pad(now.getUTCMonth() + 1);
            const year = now.getUTCFullYear();
            const hours = pad(now.getUTCHours());
            const minutes = pad(now.getUTCMinutes());
            return `${day}-${month}-${year} ${hours}:${minutes}`;
        } else {
            const day = pad(now.getDate());
            const month = pad(now.getMonth() + 1);
            const year = now.getFullYear();
            const hours = pad(now.getHours());
            const minutes = pad(now.getMinutes());
            return `${day}-${month}-${year} ${hours}:${minutes}`;
        }
    }


    function formatDateDMY(datetimeString, format='ddmmyyyy', splitchar = '/') {
        // Expecting: "16/11/2025 11:18"

        // Not in expected DD/MM/YYYY format ‚Äî bail out early
        if (typeof datetimeString !== 'string' || datetimeString.indexOf(splitchar) === -1) {
          console.warn('formatDateDMY: format unknown, returning original string');
          return datetimeString;
        }

        const [datePart, timePart] = datetimeString.split(" ");
        let day, month, year;
        if (format === 'ddmmyyyy') {
            [day, month, year] = datePart.split(splitchar);
        } else if (format === 'yyyymmdd') {
            [year, month, day] = datePart.split(splitchar);
        } else {
            console.warn('formatDateDMY: format unknown, returning original string');
            return datetimeString;
        }

        // console.log("datePart:", datePart);
        // console.log("timePart:", timePart);
        // console.log("day:", day);
        // console.log("month:", month);
        // console.log("year:", year);

        // Pad day/month if needed and validate
        const dd = day.padStart(2, "0");
        const mm = month.padStart(2, "0");
        const yyyy = year;

        return `${dd}-${mm}-${yyyy} ${timePart}`;
    }

    /**
     * Reset METAR button UI state to enabled/active.
     * Accepts either an element reference or an element ID string.
     */

    async function update_wind_gui_fields(prefix, metar_icao, metar_obj) {
        console.log(`>func: update_wind_gui_fields(${prefix})`);
        // Get the values from the input fields
        const runwayField = document.getElementById(prefix + '_RUNWAY');
        const windDirectionField = document.getElementById(prefix + '_WIND_DIRECTION');
        const windSpeedField = document.getElementById(prefix + '_WIND_SPEED');
        const windGustField = document.getElementById(prefix + '_WIND_GUST');
        const windVariationField = document.getElementById(prefix + '_WIND_VARIATION');
        const windHeadwindField = document.getElementById(prefix + '_WIND_HEADWIND');
        const windCrosswindField = document.getElementById(prefix + '_WIND_CROSSWIND');

        // Runway number is required
        if (runwayField == '') {
            alert("‚ö†Ô∏è No valid runway information available. Unable to compute the wind envelope.");
            return;
        }
        // METAR information is required
        if (metar_icao == '' || metar_icao == null) {
            alert("‚ö†Ô∏è METAR data was not retrieved. Please try to retrieve METAR information again.");
            return;
        }

        // Compute the wind direction, strength, gust and variation
        // const wind_dict = analyzeWind(metar_icao).toJs();
        const wind_dict = metar_obj.wind;
        const headwind_value = headwind(wind_dict.direction, wind_dict.speed, runwayField.value);
        const crosswind_value = crosswind(wind_dict.direction, wind_dict.speed, runwayField.value);

        // Update wind-related fields
        windDirectionField.value = (wind_dict.direction === '' || wind_dict.direction === null || wind_dict.direction === undefined || wind_dict.direction === 'None')
            ? ''
            : wind_dict.direction;

        windSpeedField.value = (wind_dict.speed === '' || wind_dict.speed === null || wind_dict.speed === undefined || wind_dict.speed === 'None')
            ? ''
            : wind_dict.speed;

        windVariationField.value = (wind_dict.variation === '' || wind_dict.variation === null || wind_dict.variation === undefined || wind_dict.variation === 'None')
            ? ''
            : String(wind_dict.variation).replace(/,/g, '-');

        windGustField.value = (wind_dict.gust === '' || wind_dict.gust === null || wind_dict.gust === undefined || wind_dict.gust === 'None')
            ? ''
            : wind_dict.gust;

        windHeadwindField.value = (headwind_value === '' || headwind_value === null || headwind_value === undefined || headwind_value === 'None')
            ? ''
            : headwind_value;

        windCrosswindField.value = (crosswind_value === '' || crosswind_value === null || crosswind_value === undefined || crosswind_value === 'None')
            ? ''
            : crosswind_value;

        console.log(`   >Runway: ${runwayField.value}`)
        console.log(`   >Headwind: ${headwind_value}`)
        console.log(`   >Crosswind: ${crosswind_value}`)
        console.log('   >Wind Dictionary:')
        console.log(`   >${wind_dict}`);
        // Compute the wind envelope
        console.log(`   >Max limits: Headwind: ${window.settings['MAX_HEADWIND_LIMIT']}, Crosswind: ${window.settings['MAX_CROSSWIND_LIMIT']}`)

    }


    async function colorMetarFields(prefix, enable=true) {
        // const buttonMetar = document.getElementById('BTN-METAR-' + prefix);
        // const buttonMetarIcon1 = document.getElementById('BTN-METAR-ICON-' + prefix + '_1');
        const buttonMetarIcon2 = document.getElementById('BTN-METAR-ICON-' + prefix + '_2');
        const metarText = document.getElementById('METAR-TEXT-' + prefix);
        const dateField = document.getElementById('DATETIME-METAR-' + prefix);
        const metarField = document.getElementById('METAR-FIELD-' + prefix);
        const windDirectionField = document.getElementById(prefix + '_WIND_DIRECTION');
        const windSpeedField = document.getElementById(prefix + '_WIND_SPEED');
        const windGustField = document.getElementById(prefix + '_WIND_GUST');
        const windVariationField = document.getElementById(prefix + '_WIND_VARIATION');
        const windHeadwindField = document.getElementById(prefix + '_WIND_HEADWIND');
        const windCrosswindField = document.getElementById(prefix + '_WIND_CROSSWIND');
        const borderFieldAerodrome = document.getElementById(prefix + '_SELECT_AERODROME_BORDER');

        if (enable) {
          // buttonMetarIcon1.disabled = false;
          // buttonMetarIcon1.style.cursor = 'pointer';
          // buttonMetarIcon2.disabled = false;
          // buttonMetarIcon2.style.cursor = 'pointer';
          // buttonMetar.disabled = false;
          // buttonMetar.style.cursor = 'pointer';
          // buttonMetar.setAttribute('aria-disabled', 'false');
          // buttonMetar.style.opacity = '1';
          // buttonMetar.style.backgroundColor = '#80B0C0';

          metarField.style.backgroundColor = 'transparent';
          metarText.style.backgroundColor = 'transparent';
          dateField.style.backgroundColor = 'transparent';
          windDirectionField.style.backgroundColor = 'transparent';
          windSpeedField.style.backgroundColor = 'transparent';
          windGustField.style.backgroundColor = 'transparent';
          windVariationField.style.backgroundColor = 'transparent';
          windHeadwindField.style.backgroundColor = 'transparent';
          windCrosswindField.style.backgroundColor = 'transparent';
          borderFieldAerodrome.style.backgroundColor = '#f5f5f5';
        } else {
          // buttonMetarIcon1.disabled = true;
          // buttonMetarIcon1.style.cursor = "not-allowed";
          // buttonMetarIcon2.disabled = true;
          // buttonMetarIcon2.style.cursor = "not-allowed";
          // buttonMetar.disabled = true;
          // buttonMetar.style.cursor = "not-allowed";
          // buttonMetar.setAttribute('aria-disabled', 'true');
          // buttonMetar.style.opacity = '0.6';

          metarText.value = ' ';
          metarField.value = 'Be patient while fetching METAR weather information...';

          // Change background color to light red/pink
          metarField.style.backgroundColor = '#ffebee';
          dateField.style.backgroundColor = '#ffebee';
          metarText.style.backgroundColor = '#ffebee';
          windDirectionField.style.backgroundColor = '#ffebee';
          windSpeedField.style.backgroundColor = '#ffebee';
          windGustField.style.backgroundColor = '#ffebee';
          windVariationField.style.backgroundColor = '#ffebee';
          windHeadwindField.style.backgroundColor = '#ffebee';
          windCrosswindField.style.backgroundColor = '#ffebee';

        }
    }


    async function set_widget(prefix, widgetname) {
        console.log(`Retrieving ${widgetname} widget for ${prefix}`);
        const icao = document.getElementById(prefix + '_ICAO').value || '';
        const button = document.getElementById(`BTN-${widgetname}-${prefix}`);

        // Styling button
        button.disabled = true;
        button.setAttribute('aria-disabled', 'true');
        button.style.opacity = '0.6';
        button.style.cursor = 'Be patient while fetching widgets...';

        // Create the METAR-TAF widget
        if (widgetname === 'AIRPORTWEATHER') {
            // Create the AirportWeather widget
            const airportWidgetResult = createAirportWeatherWidget(icao, prefix);
        } else if (widgetname === 'METARTAF') {
            // Create the METAR-TAF widget
            const metarWidgetResult = createMetarTafWidget(`CONTAINER-METARTAF-${prefix}`, icao, name, prefix);
        }

        // Styling button
        button.disabled = false;
        button.style.cursor = 'pointer';
        button.setAttribute('aria-disabled', 'false');
        button.style.opacity = '1';
        button.style.backgroundColor = '#80B0C0';
    }


  </script>

<script>

    document.getElementById('atc_fontsize').addEventListener('change', (e) => {
        if (window.settings) {
            window.settings.atc_fontsize = e.target.value;
            console.log('Updated atc_fontsize:', window.settings.atc_fontsize);
            window.settings.fontsizes = window.set_fontsizes(window.settings.atc_fontsize);
            // Save to localStorage
            localStorage.setItem('atc_fontsize', e.target.value);
        }
    });

    document.getElementById('atc_columns').addEventListener('change', (e) => {
        if (window.settings) {
            window.settings.atc_columns = e.target.value;
            console.log('Updated nr. columns:', window.settings.atc_columns);
            // Save to localStorage
            localStorage.setItem('atc_columns', e.target.value);
        }
    });

</script>


<!-- Javascript functionality -->
<script>
    // const DEFAULT_ICAO_IMAGE = "https://erdogant.github.io/datasets/skywalk/figs/oskar-kadaksoo-f_rLDn5m2XQ-unsplash.jpg";

    // Function to cache and set image source
    async function cacheAndSetImage(url, imgElementId) {
      // Import/save and then load cached image
      if (pyscriptReady) {
        await cache_and_display_image(url, imgElementId);
      }

    }

    // Load default departure image on page load
    // document.addEventListener("DOMContentLoaded", () => {
    //   cacheAndSetImage(DEFAULT_ICAO_IMAGE, 'DEPARTURE_image_cache');
    //   cacheAndSetImage(DEFAULT_ICAO_IMAGE, 'ARRIVAL_image_cache');
    // });

  // // List of images to cache
  // const IMAGES_TO_CACHE = {
  //   skywalk_logo: "https://erdogant.github.io/datasets/skywalk/figs/Slide1.PNG",
  //   coffee_logo: "https://erdogant.github.io/datasets/skywalk/figs/buy_me_a_coffee.png"
  // };
  // // Default ICAO image URL (not cached with others since it's used differently)
  // const DEFAULT_ICAO_IMAGE = "https://erdogant.github.io/datasets/skywalk/figs/oskar-kadaksoo-f_rLDn5m2XQ-unsplash.jpg";
  // window.DEFAULT_ICAO_IMAGE = DEFAULT_ICAO_IMAGE
  // const CACHE_NAME = "skywalk-cache-v1";

  // // Function to cache and set image source
  // async function cacheAndSetImage(url, imgElementId) {
  //   const cache = await caches.open(CACHE_NAME);

  //   // Try loading from cache
  //   let response = await cache.match(url);
  //   if (!response) {
  //     console.log(`Image not cached yet. Downloading: ${url}`);
  //     response = await fetch(url);
  //     await cache.put(url, response.clone());
  //   } else {
  //     console.log(`Loaded from cache: ${url}`);
  //   }

  //   const blob = await response.blob();
  //   const objectURL = URL.createObjectURL(blob);
  //   const imgElement = document.getElementById(imgElementId);
  //   if (imgElement) {
  //     imgElement.src = objectURL;
  //   } else {
  //     console.warn(`Image element not found: ${imgElementId}`);
  //   }
  // }

  // // Initialize caching on page load
  // document.addEventListener("DOMContentLoaded", () => {
  //   for (const [elementId, url] of Object.entries(IMAGES_TO_CACHE)) {
  //     cacheAndSetImage(url, elementId);
  //   }

  //   // Load default departure image on page load
  //   cacheAndSetImage(DEFAULT_ICAO_IMAGE, 'DEPARTURE_image_cache');
  //   cacheAndSetImage(DEFAULT_ICAO_IMAGE, 'ARRIVAL_image_cache');
  // });
</script>

<script>
  /**
   * Update a flag image element by country code (2-letter ISO).
   * - imgId: id of the <img> element
   * - countryCode: two-letter ISO country code (e.g. 'ua', 'nl'). Can be uppercase; function lower-cases it.
   *
   * This function is exposed on window as updateFlag so it can be called from PyScript:
   *   js.window.updateFlag('DEPARTURE', 'ua')
   */
  function updateFlag(prefix, countryCode) {
    try {
      console.log(`>func: updateFlag(${prefix}, ${countryCode})`);

      if (countryCode == null || countryCode === '') {
          countryCode = window.flight_plan_data?.[`${prefix}_COUNTRY_CODE`];
      }

      const img = document.getElementById(`${prefix}_FLAG`);
      if (!img){
          console.log(`   >Warning: img element not found: ${img}`)
          return;
      }

      if (!countryCode || String(countryCode).trim() === '' || countryCode==='remove') {
        console.log(`   >Warning: no Country code`)
        img.style.display = 'none';
        img.alt = '';
        img.src = '';
        return;
      }

      // Normalize
      const code = String(countryCode).trim().toLowerCase();

      // Only accept two-letter codes (basic check); if not 2 letters, hide
      if (!/^[a-z]{2}$/.test(code)) {
        console.log(`   >Warning: Country code has more then 2 chars`)
        img.style.display = 'none';
        img.alt = '';
        img.src = '';
        return;
      }

      // Build SVG URL (flagcdn). Use svg first; fallback to PNG if error.
      const svgUrl = `https://flagcdn.com/${code}.svg`;
      // const pngUrl = `https://flagcdn.com/w80/${code}.png`;
      cache_and_display_image(svgUrl, `${prefix}_FLAG`)

      console.log(`   >Set Flag to: ${svgUrl}`)
      // img.src = svgUrl;
      img.alt = countryCode.toUpperCase();
      img.style.display = 'inline-block';
    } catch (e) {
      console.warn('updateFlag error', e);
    }
  }


</script>


<!--============================================-->
<!-- PyScript configuration -->
<!--============================================-->


<py-config>
  packages = ["pandas", "numpy", "jinja2", "requests"]
</py-config>


<script>
// Add event listeners for FIC spinners
document.getElementById('fic_spinner')?.addEventListener('change', function() {
    if (this.value && window.load_enroute_fic) {
        window.load_enroute_fic('fic_spinner');
    }
});

document.getElementById('fic_spinner2')?.addEventListener('change', function() {
    if (this.value && window.load_enroute_fic) {
        window.load_enroute_fic('fic_spinner2');
    }
});

// Add event listeners for checklist spinners
document.getElementById('checklist_spinner')?.addEventListener('change', async function() {
    if (this.value && window.load_spinner_selection) {
        console.log(`> addEventListener: checklist_spinner`);
        // Update the checklist using the selection from cache (Python async)
        await window.load_spinner_selection('checklist_spinner', 'CHECKLIST');
        // Rebuild sections and categories after loading
        // createChecklistSections();
        populateChecklistCatagories();
        // checklist_populate();
    }
});

</script>



<!-- PyScript for flightplan functionality -->
  <script type="py">
    # Standard library imports
    import json
    import os
    import sys
    import re
    import pathlib
    import tempfile
    import base64
    from datetime import datetime
    from io import BytesIO
    from urllib.parse import urlparse
    import urllib.parse
    import webbrowser
    import math

    # Third party imports
    import pandas as pd
    import numpy as np
    import zipfile
    import requests
    import ast
    import asyncio
    from jinja2 import Environment, DictLoader
    # from math import radians, cos

    # JavaScript/browser imports
    import js
    from js import Blob, URL, window
    from pyodide.http import pyfetch
    from pyodide.ffi import create_proxy

    import logging
    logger = logging.getLogger('SKYWALK')

    def get_default_checklist():
        print('> func: default_checklist()')
        checklist = {
                "personal": {
                    'Paper, Pen, Watch, Sunglasses, Hat': False,
                    'Medical papers': False,
                    'Pilot Licence': False,
                    'Passport/ identity card': False,
                    'Flight Logbook': False,
                    'Accu pack': False,
                    'Headset': False,
                    },

                "passengers": {
                  'Brief the Passenger(s)': False,
                    'Passport/ identity card Passenger(s)': False,
                    'Headset': False,
                    },

                "flightplan": {'Submit Flight Plan/ Flight Notification': False},

                "technical": {'Weight and Balance': False,
                              'Fuel Computations': False,
                              },

                "departure (aircraft)": {
                    'Official Aircraft Papers (The bag or suitcase)': False,
                    'Checklist Aircraft': False,
                    'Check outstanding complaints; become aware of known issues': False,
                    'Check the journal for available flight hours': False,
                    'Dinghy/swimming suit for overwater flight': False,
                    'Fuel draining (remove water at lowest point before moving the aircraft)': False,
                    },

                "departure (aerodrome)": {
                  'Departure Name': False,
                  'Departure Altitude': False,
                  'Circuit Altitude': False,
                  'Runway number (expected)': False,
                  'NOTAMS': False,
                  'Weather Information (METAR/ TAF)': False,
                  'Take-off/ Landing Distance': False,
                  'ATC frequencies': False,
                  },

                "arrival (aircraft)": {
                    'Take out personal valuable items': False,
                    'Take out keys, journal, bag or suitcase': False,
                    'Secure the wings with the strap': False,
                    'Lock the doors/ canopy': False,
                    'Close flightplan': False,
                    'Register and pay landing fee (C)': False,
                    'Prior Permission Required (PPR) by phone': False,
                    },

                "arrival (aerodrome)": {
                  'Arrival Name': False,
                  'Arrival Altitude': False,
                  'Circuit Altitude': False,
                  'Runway number (expected)': False,
                  'NOTAMS': False,
                  'Weather Information (METAR/ TAF)': False,
                  'Take-off/ Landing Distance': False,
                  'ATC frequencies': False,
                  },

                "enroute": {
                    'Navigation Plan': False,
                    'Alternate aerodrome': False,
                    'Flight levels and airspaces': False,
                    'Weather Information (METAR/ TAF)': False,
                    'AIP/AIC information printed': False,
                    'ATC frequencies (FIR/FIS)': False,
                    },

                "various": {
                    'Activate flight plan after takeoff': False,
                    },

                "final": {
                    'Flight plan/ Flight Notification is approved': False,
                    },

                }

        return checklist

    def get_default_settings():
        """Get default settings"""
        print('> func: get_default_settings()')

        # 'coffee_logo': 'https://erdogant.github.io/datasets/skywalk/figs/buy_me_a_coffee.png',
        # 'skywalk_logo': 'https://erdogant.github.io/datasets/skywalk/figs/Slide1.PNG',
        # 'img_default_icao': 'https://erdogant.github.io/datasets/skywalk/figs/oskar-kadaksoo-f_rLDn5m2XQ-unsplash.jpg',

        return {
            'DEPARTURE_COUNTRY': '',
            'DEPARTURE_ICAO': '',
            'DEPARTURE_ICAO_CITY': '',
            'ARRIVAL_COUNTRY': '',
            'ARRIVAL_ICAO': '',
            'ARRIVAL_ICAO_CITY': '',
            'MAX_HEADWIND_LIMIT': 25,
            'MAX_CROSSWIND_LIMIT': 15,
            'fontsizes': {'TOWER': 16, 'PILOT': 18, 'TITLE': 20},
            'atc_fontsize': 'large',
            'atc_columns': '2',

            'link_coffee': "https://www.buymeacoffee.com/erdogant",
            'link_skywalk': 'http://erdogant.github.io/skywalk-docs/',

            'FIG_DIR': 'https://erdogant.github.io/datasets/skywalk/figs/',

            'coffee_logo': './figs/buy_me_a_coffee.png',
            'skywalk_logo': './figs/logo_skywalk.png',
            'img_default_icao': './figs/default_aerodrome.jpg',

            'img_default_wind_envelope': 'https://erdogant.github.io/datasets/skywalk/figs/windsock_mark-konig-OsYYPaPgIjw-unsplash.jpg',
            'url_default_wind_envelope': 'https://erdogant.github.io/skywalk-docs/pages/html/Departure_Arrival.html#cloud-plot',
            'img_default_cloud_plot': 'https://erdogant.github.io/datasets/skywalk/figs/dylan-mcleod-vY7GkgvTj-k-unsplash.jpg',
            'url_default_cloud_plot': 'https://erdogant.github.io/skywalk-docs/pages/html/Departure_Arrival.html#cloud-plot',

            'unzipKey': "GpZzcnXiLleytOr5Y7WC@",
            'url_aerodromes': 'https://erdogant.github.io/datasets/skywalk/aerodromes/',
            'url_aerodromes_images': 'https://erdogant.github.io/datasets/skywalk/aerodromes_images/',
            'url_airspaces': 'https://erdogant.github.io/datasets/skywalk/airspaces/',

            'html_templates': 'https://erdogant.github.io/datasets/skywalk/html_templates/',
        }


    def get_default_data():
        """Get default flightplan data structure - copied from utils_skywalk.py"""
        print('> func: get_default_data()')
        return {
            # General Flightplan
            'FLIGHTPLAN': '',           # Name of the flightplan
            'DATETIME': datetime.now().strftime('%d-%m-%Y %H:%M'),
            'CALLSIGN': '',             # Aircraft callsign
            'CALLSIGN_SHORT': '',       # Short callsign (auto-generated)
            'AIRCRAFT_TYPE': '',        # Aircraft type/model
            'FLIGHT_RULES': 'VFR',      # VFR/IFR
            'POB': '',                  # Persons on board

            # Departure
            'DEPARTURE_ICAO': '',               # ICAO code
            'DEPARTURE_ICAO_CITY': '',          # ICAO code with City
            'DEPARTURE_NAME': '',               # Aerodrome name
            'DEPARTURE_POSITION': '',           # Position at apron
            'DEPARTURE_RUNWAY': '',             # The user selected Runway
            'DEPARTURE_RUNWAYS': '',            # All available Runways
            'DEPARTURE_RUNWAY_LENGTH': '',      # The length of the Runway
            'DEPARTURE_RUNWAY_SURFACE': '',     # The surface of the Runway
            'DEPARTURE_ELEVATION': '',          # The Runway ELEVATION
            'DEPARTURE_ROUTE_NAME': '',         # Departure route name
            'DEPARTURE_ROUTE_ALTITUDE': '',     # Departure route altitude
            'DEPARTURE_CIRCUIT_ALTITUDE': '',   # Departure circuit altitude
            'DEPARTURE_CTR': False,             # CTR checkbox state
            'DEPARTURE_COUNTRY': '',            # Country selection
            'DEPARTURE_COUNTRY_CODE': '',       # Country code selection
            'DEPARTURE_IMAGE': None,            # Image of the departure
            'DEPARTURE_URL_WEBSITE': None,      # Website of the Aerodrome
            'DEPARTURE_URL_WIKIPEDIA': None,    # Website of the Aerodrome
            'DEPARTURE_LATLON': [None, None],   # Latlon
            'DEPARTURE_METAR_ICAO': '',         # METAR for the specific ICAO
            'DEPARTURE_METAR': '',              # METAR
            'DEPARTURE_WIND_ENVELOPE': '',      # WIND ENVELOPE
            'DEPARTURE_CLOUD': '',              # CLOUD DATA
            'DEPARTURE_TIMEZONE': '',           # Timezone

            # Departure ATC
            'DEPARTURE_ATC_TOWER': '',            # Tower/Radio frequency
            'DEPARTURE_ATC_ATIS_FREQ': '',        # ATIS frequency
            'DEPARTURE_ATC_GROUND': '',           # Delivery/Ground frequency
            'DEPARTURE_ATC_APPROACH': '',         # Approach
            'DEPARTURE_ATC_TELEPHONE': '',        # Telephone Tower

            # Arrival
            'ARRIVAL_ICAO': '',                   # ICAO code
            'ARRIVAL_ICAO_CITY': '',              # ICAO code with City
            'ARRIVAL_NAME': '',                   # Aerodrome name
            'ARRIVAL_POSITION': '',               # Position at apron
            'ARRIVAL_RUNWAY': '',                 # The user selected Runway
            'ARRIVAL_RUNWAYS': '',                # All available Runways
            'ARRIVAL_RUNWAY_LENGTH': '',          # The length of the Runway
            'ARRIVAL_RUNWAY_SURFACE': '',         # The surface of the Runway
            'ARRIVAL_ELEVATION': '',              # The Runway ELEVATION
            'ARRIVAL_ROUTE_NAME': '',             # Arrival route name
            'ARRIVAL_ROUTE_ALTITUDE': '',         # Arrival route altitude
            'ARRIVAL_CIRCUIT_ALTITUDE': '',       # Arrival circuit altitude
            'ARRIVAL_CTR': False,                 # CTR checkbox state
            'ARRIVAL_COUNTRY': '',                # Country selection
            'ARRIVAL_COUNTRY_CODE': '',           # Country code selection
            'ARRIVAL_IMAGE': None,                # Image of the departure
            'ARRIVAL_URL_WEBSITE': None,          # Website of the Aerodrome
            'ARRIVAL_URL_WIKIPEDIA': None,        # Website of the Aerodrome
            'ARRIVAL_LATLON': [None, None],       # Latlon
            'ARRIVAL_METAR_ICAO': '',             # METAR
            'ARRIVAL_METAR': '',                  # METAR
            'ARRIVAL_WIND_ENVELOPE': '',          # WIND ENVELOPE
            'ARRIVAL_CLOUD': '',                  # CLOUD DATA
            'ARRIVAL_TIMEZONE': '',               # Timezone

            # Arrival ATC
            'ARRIVAL_ATC_TOWER': '',        # Tower/Radio frequency
            'ARRIVAL_ATC_ATIS_FREQ': '',    # ATIS frequency
            'ARRIVAL_ATC_GROUND': '',       # Delivery/Ground frequency
            'ARRIVAL_ATC_APPROACH': '',     # Approach
            'ARRIVAL_ATC_TELEPHONE': '',    # Telephone Tower

            # Enroute
            'FIC_NAME': '',             # FIC name
            'FIC_FREQUENCY': '',        # FIC frequency
            'OVERHEAD': '',             # Overhead point
            'SQUAWK': '',               # Squawk code
            # Enroute (second FIC/overhead/squawk)
            'FIC_NAME2': '',            # Second FIC name
            'FIC_FREQUENCY2': '',       # Second FIC frequency
            'OVERHEAD2': '',            # Second overhead point
            'SQUAWK2': '',             # Second squawk code

            # NOTAM data
            'NOTAM': {'data': {}},      # NOTAM data

            # CHECKLIST
            'CHECKLIST': get_default_checklist(),
        }

    # ================================================
    # GENERIC FUNCTIONS
    # ================================================

    def update_dropdown(elementId, cacheName, keepSelection=True, elementId2=None):
        """Update the dropdown with cached info.

        Parameters
        ----------
        elementId : str
            The ID of the HTML element to be updated.
        cacheName : str
            The name of the cache from which the data will be fetched.
        keepSelection : bool, optional
            Whether to keep the current selection in the dropdown (default is True).
        elementId2 : str, optional
            An alternative ID to use if `keepSelection` is True and the current
            selection is empty.
        """
        print(f"> func: update_dropdown()")

        # Get all keys from localStorage
        storage_length = js.localStorage.length
        cName = cacheName.upper() + '_'
        cached_names = set()

        for i in range(storage_length):
            key = js.localStorage.key(i)
            if key and key.upper().startswith(cName):
                cached_names.add(str(key).replace(cName, ''))

        # Convert to list and sort alphabetically
        cached_names = sorted(list(cached_names))

        # Update dropdown
        select = js.document.getElementById(elementId)
        user_selection = select.value

        # Set user_selection with the value elementId2 name if user selection is empty
        if keepSelection and elementId2 and user_selection == '':
            user_selection = js.document.getElementById(elementId2).value

        if select:
            # Clear existing options except the first placeholder
            select.innerHTML = f'<option value="">Select and Load</option>'

            # Add each detected item as an option
            for name in cached_names:
                option = js.document.createElement('option')
                option.value = name
                option.textContent = name
                select.appendChild(option)

            # Set to user selection:
            if keepSelection:
                select.value = user_selection

            print(f"   >‚úÖ Updated {elementId} with {len(cached_names)} {cacheName.lower()}s")
        else:
            print(f"   >‚ö†Ô∏è Dropdown {elementId} not found for {cacheName.lower()}.")



    async def load_spinner_selection(elementId, cacheName):
        """Load selected from localStorage"""
        print(f'> func: load_spinner_selection({elementId})')

        # Get the user selection from the spinner element
        user_selection = js.document.getElementById(elementId).value

        if not user_selection or user_selection == "":
            print("   >‚ö†Ô∏è No {cacheName} selected")
            return

        print(f"   >üìÇ Loading {cacheName}: {user_selection}")

        # Load from cache (localStorage)
        storage_key = f"{cacheName}_{user_selection}"
        json_data = js.localStorage.getItem(storage_key)

        if not json_data:
            print(f"   >‚ö†Ô∏è {cacheName} not found: {user_selection}")
            js.window.alert(f"‚ö†Ô∏è {cacheName} '{user_selection}' was not found.")
            return

        # Parse JSON
        try:
            data_dict = json.loads(json_data)
            print(f"   >‚úÖ Loaded {cacheName}: {len(data_dict)} fields for {elementId}")

            # Do stuff for the spinner
            if elementId == 'checklist_spinner':
                js.window.flight_plan_data['CHECKLIST'] = data_dict
                js.document.getElementById('checklist_field').value = user_selection
                checklist_populate()

            print(f"   >‚úÖ [elementId] '{user_selection}' loaded successfully")
        except Exception as e:
            print(f"   >‚ö†Ô∏è Error loading {user_selection}: {e}")
            js.window.alert(f"‚ùó Error loading {user_selection}: {e}")


    # ================================================
    # CHECKLIST
    # ================================================

    def checklist_update_catagories(operation):
        """Update the categories of the checklist.

        This function safely adds or removes items from the CHECKLIST structure
        stored in `js.window.flight_plan_data`. It validates that the checklist
        and the selected category exist and are dictionaries to avoid
        TypeError: 'builtin_function_or_method' object is not subscriptable and
        other indexing errors.

        Parameters
        ----------
        operation : str
            Either 'add' to add an item or 'drop' to remove an item.
        """

        if not js.window.flight_plan_data.get('CHECKLIST'):
            print('   > ‚ö†Ô∏è CHECKLIST not found in [js.window.flight_plan_data]')
            return

        # Get item name and category (normalize)
        itemName = js.document.getElementById('checklist_item_field').value.strip()
        catName = js.document.getElementById('checklist_catagory_field').value.lower()

        # Shortcut to the checklist dict
        checklist = js.window.flight_plan_data['CHECKLIST']
        blacklist = ['NAME', 'aerodrome']

        if operation == 'add':
            # Validate category exists and is a dict
            if (catName not in checklist) or not isinstance(checklist[catName], dict):
                js.window.alert(f"‚ö†Ô∏è Category '{catName}' does not exist or is not a valid category.")
                print(f"   > ‚ö†Ô∏è Category '{catName}' missing or invalid in CHECKLIST")
                return

            if itemName == '':
                js.window.alert(f"‚ö†Ô∏è Input name is required to {operation} an item.")
                return

            # Only add if not already present
            if itemName in checklist[catName]:
                print(f'    > Item "{itemName}" already exists in category: {catName}')
                js.window.alert(f'‚ö†Ô∏è Item "{itemName}" already exists in category: {catName}')
            else:
                # Add item to catagory
                checklist[catName][itemName] = False
                print(f'    > Added "{itemName}" to category: {catName}')
                js.document.getElementById('checklist_item_field').value = ''
        elif operation == 'drop':
            # Check whether any checkboxes are marked for deletion
            isdel = False
            for key in checklist.keys():
                # Skip the ones in blacklist
                if key not in blacklist:
                    if isinstance(checklist[key], dict):
                        # Collect items to delete first
                        items_to_delete = []
                        for item in checklist[key].keys():
                            print(f'{key}-{item}: {checklist[key][item]}')
                            if checklist[key][item]:
                                # Confirm deletion
                                if js.window.confirm(f"Delete: [{item}] from the [{key}] category?"):
                                    items_to_delete.append(item)

                        # Now delete the collected items
                        for item in items_to_delete:
                            checklist[key].pop(item, None)
                            isdel = True

            if not isdel:
                js.window.alert(f'‚ö†Ô∏è No items are marked to be removed. Please check the items first.')
        else:
            print(f'    > ‚ö†Ô∏è Unknown operation: {operation}')
            return

        # Update checklist UI
        checklist_populate()


    def checklist_populate():
        """Populate the checklist with data from js.window.flight_plan_data['CHECKLIST'].

        This function iterates over each key in `js.window.flight_plan_data['CHECKLIST']`.
        If the value associated with a key is a dictionary, it calls `js.window.populateChecklist()`
        to populate the checklist with that data.

        Returns
        -------
        None
            This function does not return anything. It only updates the checklist in place.
            If `js.window.flight_plan_data['CHECKLIST']` is not found or does not contain any dictionaries,
            it prints a warning message and returns early.

        """
        print('> func: checklist_populate()')
        if not js.window.flight_plan_data.get('CHECKLIST'):
            print('   > ‚ö†Ô∏è CHECKLIST not found in [js.window.flight_plan_data]')
            return

        # Populate the checklist
        for key in js.window.flight_plan_data['CHECKLIST'].keys():
            if isinstance(js.window.flight_plan_data['CHECKLIST'][key], dict):
                # A match is created for the data-title to fill the right elements
                js.window.populateChecklist(f"{key.title()}")

        # Automatically create the checklists
        # window.createChecklistSections()
        # window.populateChecklistCatagories()

    def save_checklist_to_json(elementId):
        """Save custom checklist data to localStorage. """
        print(f'> func: save_checklist_to_json()')


        # Store the CHECKLIST to localStorage
        listname = js.document.getElementById(elementId).value.strip()
        if listname == '':
            print('Name is required. Nothing saved. <return>')
            js.window.alert(f"‚ö†Ô∏è Please provide a checklist name before saving.")
            return

        cache_key = 'CHECKLIST_' + listname
        # Store Cache key in flightplan
        js.window.flight_plan_data['CHECKLIST']['NAME'] = cache_key
        # Convert to JSON string
        json_data = json.dumps(js.window.flight_plan_data['CHECKLIST'])
        # Save to cache
        js.localStorage.setItem(cache_key, json_data)

        # Update the checklist list
        update_dropdown('checklist_spinner', cacheName='CHECKLIST', keepSelection=True, elementId2='checklist_field');
        message = f"‚úÖ Checklist {listname} is saved with the catagories and items."
        print(message)
        js.window.alert(message)

        # Return
        return True


    def checklist_clean(verbose='info'):
        print('> func: checklist_clean()')
        # Clean the fields
        js.document.getElementById('checklist_field').value = ''
        select = js.document.getElementById('checklist_spinner')
        select.value = 'Select and Load'

        # Set the default checklist
        js.window.flight_plan_data['CHECKLIST'] = get_default_checklist()

        # Populate checklist with defaults
        checklist_populate()

        if verbose=='info':
            js.window.alert(f"‚ÑπÔ∏è Default checklist catagories and items are loaded.")


    def check_items_complete(listname):
        # Get items from checklist
        check_items = js.window.flight_plan_data['CHECKLIST'][listname]

        # Check if all items are True
        if all(check_items.values()):
            icon = '‚ÑπÔ∏è'
        else:
            icon = '‚ö†Ô∏è'
        return icon

    def checklist_print():
        print(f'> func: checklist_print()')
        html_content = generate_checklist_html(include_badges=False)
        # print(html_content)
        open_html(html_content)
        return

    def create_badge_html(badges):
        html = '<div style="margin-left: 20px; display: flex; flex-wrap: wrap; gap: 6px;">'
        html += ''.join([f'<img src="{url}" alt="badge">' for url in badges])
        html += '</div>'
        return html

    def create_status_html(item, classtype='note', width='80'):
        return f"""
        <div class="{classtype}" style="background-color:{item['color']}; padding: 6px 10px; margin: 6px 0 6px 20px; border-radius: 4px; width: {width}%;">
            <strong>{item['message']}</strong>
        </div>
        """

    def badge_color(badge):
        # Get colors matched to state
        if 'error' in str(badge):
            return 'red'
        elif 'warning' in str(badge):
            return 'orange'
        elif 'success' in str(badge):
            return 'green'
        elif 'info' in str(badge):
            return 'blue'

    def weight_balance(fname, return_type='badge'):
        status = 'OK'
        message = 'Weight & Balance Inside Envelope'
        badge = 'success'
        return {'status': status, 'message': message, 'badge': badge, 'color': badge_color(badge)}

    def aircraft_weight(fname, return_type='badge'):
        status = 'OK'
        message = 'Weight within MTOW'
        badge = 'success'
        return {'status': status, 'message': message, 'badge': badge, 'color': badge_color(badge)}

    def fuel(fname, return_type='badge'):
        status = 'OK'
        message = 'Fuel within range'
        badge = 'success'
        return {'status': status, 'message': message, 'badge': badge, 'color': badge_color(badge)}

    def generate_checklist_html(include_badges=False):
        # from badges import weight_balance, aircraft_weight, fuel
        # from badges import create_ATC_badges
        # from badges import flight_rules, wind_envelope, crosswind, headwind, cloud_ceiling, visibility
        # from badges import RWY_required, runway_direction, route
        from collections import defaultdict

        if not js.window.flight_plan_data.get('CHECKLIST'):
            js.window.alert('‚ö†Ô∏è Create a new checklist before printing.')
            return None

        data = js.window.flight_plan_data['CHECKLIST']

        weight_status = weight_balance('DEPARTURE', return_type='dict')
        aircraft_status = aircraft_weight('DEPARTURE', return_type='dict')
        fuel_status = fuel('ARRIVAL', return_type='dict')

        # section_order = [
        #     "personal", "navigation", "flightplan", "technical", "aerodrome",
        #     "departure", "arrival", "various", "final"]

        # Only print those with at least one item
        counts = {k: len(v) for k, v in data.items() if isinstance(v, dict) and len(v) > 0}
        section_order = list(counts.keys())

        html = """
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; font-size: 13px; padding: 20px; margin: 0; }
                h2 { border-bottom: 1px solid #ccc; margin-top: 30px; }
                .section { margin-bottom: 20px; }
                .item { display: flex; align-items: flex-start; margin: 6px 0; }
                .item label { display: flex; align-items: flex-start; }
                .item input[type="checkbox"] { margin-right: 10px; margin-top: 2px; transform: scale(1.2); flex-shrink: 0; }
                .label-text { display: inline-block; max-width: 90%; word-wrap: break-word; }
                .name-tag { font-size: 14px; font-weight: bold; padding: 6px 0 20px; display: block; }
                .note { background-color: #f8f9fa; border-left: 4px solid #888; padding: 10px; margin-bottom: 10px; font-size: 12px; }
                .columns { display: flex; flex-wrap: wrap; gap: 20px; }
                .column { flex: 1 1 45%; min-width: 300px; }
            </style>
        </head>
        <body>
        """

        # Get checklist name from gui
        checklist_name = js.document.getElementById('checklist_field').value
        if checklist_name != '':
            html += f"<class='name-tag'><h1>Checklist {data['NAME']}</h1>"

        for section in section_order:
            if section in data:
                if section == "aerodrome":
                    continue
                    # FOR THE MOMENT, LETS NOT DO THE THINGS BELOW

                    items = list(data[section].items())
                    grouped_items = defaultdict(list)

                    for label, checked in items:
                        if ' - ' in label:
                            labelname, labelitem = label.split(' - ', 1)
                            grouped_items[labelname].append((labelitem, checked, label))
                        else:
                            grouped_items[""].append((label, checked, label))

                    for labelname, group in grouped_items.items():
                        html += "<div style='border-top: 2px solid #333; margin: 30px 0; width: 100%;'></div>"
                        html += f"<div class='section'><h3>{labelname}</h3><div class='columns'>"

                        half = len(group) // 2
                        left_items = group[:half]
                        right_items = group[half:]

                        for col_items in [left_items, right_items]:
                            html += "<div class='column'>"
                            for labelitem, checked, full_label in col_items:
                                checked_html = "checked" if checked else ""
                                html += f"<div class='item'><label><input type='checkbox' {checked_html}><span class='label-text'>{labelitem}</span></label></div>"

                                fname = None
                                for key in ['DEPARTURE', 'ARRIVAL', 'ALTERNATE']:
                                    if st.session_state['DATA'][key]['AERODROME']['ICAO'] in full_label:
                                        fname = key
                                        break

                                if fname:
                                    if 'metar' in full_label.lower() and include_badges:
                                        html += create_status_html(flight_rules(fname, return_type='dict'), classtype='note')
                                        html += create_status_html(wind_envelope(fname, return_type='dict'), classtype='note')
                                        html += create_status_html(crosswind(fname, return_type='dict'), classtype='note')
                                        html += create_status_html(headwind(fname, return_type='dict'), classtype='note')
                                        html += create_status_html(cloud_ceiling(fname, return_type='dict'), classtype='note')
                                        html += create_status_html(visibility(fname, return_type='dict'), classtype='note')

                                    if 'circuit' in full_label.lower() and include_badges:
                                        html += create_status_html(route(fname, 'CIRCUIT_ALTITUDE', return_type='dict'), classtype='note')
                                        html += create_status_html(route(fname, 'ALTITUDE', return_type='dict'), classtype='note')
                                        html += create_status_html(route(fname, 'ROUTE_NAME', return_type='dict'), classtype='note')

                                    if 'ATC' in full_label and include_badges:
                                        html += create_badge_html(create_ATC_badges(fname, return_type='dict'))

                                    if 'distance' in full_label.lower() and include_badges:
                                        html += create_status_html(runway_direction(fname, return_type='dict'), classtype='note')
                                        html += create_status_html(RWY_required(fname, 'DISTANCE_REQUIRED', return_type='dict'), classtype='note')
                                        html += create_status_html(RWY_required(fname, 'DISTANCE_REQUIRED_50ft', return_type='dict'), classtype='note')

                            html += "</div>"
                        html += "</div></div>"

                else:
                    html += f"<div class='section'><h2>{section.capitalize()}</h2><div class='columns'>"
                    items = list(data[section].items())
                    if len(items) > 0:
                        half = len(items) // 2
                        left_items = items[:half]
                        right_items = items[half:]

                        for col_items in [left_items, right_items]:
                            html += "<div class='column'>"
                            for label, checked in col_items:
                                checked_html = "checked" if checked else ""
                                html += f"<div class='item'><label><input type='checkbox' {checked_html}><span class='label-text'>{label}</span></label></div>"

                                if section == "technical" and include_badges:
                                    if 'weight' in label.lower():
                                        html += create_status_html(weight_status)
                                        html += create_status_html(aircraft_status)
                                    if 'fuel' in label.lower():
                                        html += create_status_html(fuel_status)

                            html += "</div>"
                        html += "</div></div>"

        html += "</body></html>"

        print_button = """
            <button onclick=\"window.print()\" style=\"
                margin-bottom: 10px;
                padding: 6px 12px;
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            \">üñ®Ô∏è Print Checklist</button>
        """

        html = f"{print_button}{html}"
        return html


    # ================================================
    # CACHE HELPERS
    # ================================================

    def clear_cache():
        """Clear all cached data from localStorage"""
        try:
            # Clears everything stored in localStorage
            js.localStorage.clear()

            # If you also use sessionStorage:
            js.sessionStorage.clear()
            print("üßπ Cache cleared successfully")
            return True
        except Exception as e:
            print(f"‚ùå Error clearing cache: {e}")
            return False


    def is_cached(cache_key):
        try:
            cached = js.localStorage.getItem(cache_key)
            # Check if value exists and is truthy (not null/undefined)
            return bool(cached)
        except:
            return False


    def save_to_cache(cache_key, data, encode_base64=False):
        """Save data to localStorage with optional base64 encoding"""
        try:
            if encode_base64:
                data = base64.b64encode(data).decode('utf-8')
            js.localStorage.setItem(cache_key, data)
            print(f"üíæ Cached {cache_key}: {len(data)} bytes")
            return True
        except Exception as e:
            print(f"‚ùå Error saving to cache: {e}")
            return False


    async def load_cached_zip(cache_key, url=None):
        """Load data from cache or download and cache it
        Args:
            cache_key: Key to use for caching
            url: URL to fetch data from if not in cache
        Returns:
            bytes: The loaded data
        """
        if is_cached(cache_key):
            print(f"üì¶ Using cached data for: {cache_key}")
            cached_data = load_from_cache(cache_key)
            return cached_data

        if url:
            print(f"‚¨áÔ∏è Downloading from: {url}")
            data = await fetch_zip(url)
            if data:
                save_to_cache(cache_key, data, encode_base64=True)
                return data
        return None


    def load_from_cache(cache_key):
        try:
            cached_data = js.localStorage.getItem(cache_key)
            if cached_data:
                # Decode base64 string to bytes
                data = base64.b64decode(cached_data)
                print(f"üì¶ Loaded {len(data)} bytes from cache")
                return data
            print("‚ö†Ô∏è Cache returned null")
            return None
        except Exception as e:
            print(f"‚ö†Ô∏è Error decoding cached data: {e}")
            return None


    # Fetch ZIP from remote and save to cache
    async def fetch_zip(url):
        filepath = urlparse(url).path
        zipname = os.path.splitext(os.path.basename(filepath))[0]
        print(f"üì• Fetching: {url}")
        print(f"üì• Fetching: {zipname}")

        response = await pyfetch(url)
        if response.ok:
            # Get bytes directly as Python bytes object
            zip_bytes = await response.bytes()
            save_to_cache(zipname, zip_bytes, encode_base64=True)
            return zip_bytes
        else:
            print(f"‚ùå Failed to download {url} - Status: {response.status}")
            # js.document.getElementById('loading-spinner').style.display = 'none'
            return None


    # Extract CSV inside the ZIP
    def extract_csv_from_zip(zip_bytes, password=None):
        print('----> extract_csv_from_zip()')
        try:
            print(f"üîì Extracting ZIP file ({len(zip_bytes)} bytes)...")
            with zipfile.ZipFile(BytesIO(zip_bytes)) as z:
                files = z.namelist()
                print(f"üìÇ Files in ZIP: {files}")
                name = files[0]  # First file in ZIP
                print(f"üìÑ Reading: {name}")
                if password is None:
                    with z.open(name) as f:
                        df = pd.read_csv(f, sep=';')
                else:
                    with z.open(name, pwd=password.encode()) as f:
                        df = pd.read_csv(f, sep=';')
                print(f"‚úÖ CSV parsed: {len(df)} rows, {len(df.columns)} columns")
            return df
        except zipfile.BadZipFile as e:
            print(f"‚ùå BadZipFile error: {e}")
            print(f"First 100 bytes: {zip_bytes[:100]}")
            raise
        except Exception as e:
            print(f"‚ùå Error extracting CSV: {type(e).__name__}: {e}")
            # js.document.getElementById('loading-spinner').style.display = 'none'
            raise


    # ================================================
    # METAR HELPERS
    # ================================================

    def get_top_metar_stations(fname, n=5, return_df=False):
        # Retrieve all metar stations for the country
        print(f'>func: get_top_metar_stations({fname}, {n})')

        icao = js.window.flight_plan_data[f'{fname}_ICAO']
        lat = js.window.flight_plan_data[f'{fname}_LATLON'][0]
        lon = js.window.flight_plan_data[f'{fname}_LATLON'][1]

        print(f'   >icao: {icao}, lat: {lat}, lon: {lon}')

        # Import METAR data
        df_stations = get_metar_stations(todf=True)
        # print(df_stations)

        if n is None or n > df_stations.shape[0]:
            n = df_stations.shape[0]

        # If icao is in df_stations
        # if icao in df_stations['icao'].values:
        #    print(f'   >Found {icao} in METAR stations')
        #    return [icao]

        # Return all or selection
        if (lat is not None) and (lon is not None):
            # Compute haversine distance
            df_stations['distance_to_target'] = haversine_distances(lat, lon, df_stations['lat'].values, df_stations['lon'].values)
            # df_stations['distance_to_target'] = df_stations.apply(lambda row: compute.haversine(row['lat'], row['lon'], lat, lon), axis=1)
            # Sort on closest METAR stations
            df_stations.sort_values(by='distance_to_target', inplace=True)
        else:
            df_stations['distance_to_target'] = None

        # Filter on top distance metar stations
        icao_stations = list(df_stations['icao'].values[0:int(n)])
        # name_stations = list(df_stations['name'].values[0:int(n)])

        # print(df_stations)
        # print(icao_stations)
        # print(name_stations)

        # Return
        if return_df:
            return df_stations
        else:
            return icao_stations


    def get_metar_stations(fname=None, todf=True):
        if fname == 'DEPARTURE':
            AERODROME_DATA = window.AERODROME_DEPARTURE_DATA.copy()
        elif fname == 'ARRIVAL':
            AERODROME_DATA = window.AERODROME_ARRIVAL_DATA.copy()
        else:
            AERODROME_DATA = window.AERODROME_DATA.copy()

        if todf:
            icao_with_metar = [
            {"icao": item["icao"], "lat": item["lat"], "lon": item["lon"], "country": item["country"], "name": item["name"]}
                for item in AERODROME_DATA
                if item.get("metar_station") is True
            ]
            icao_with_metar = pd.DataFrame(icao_with_metar)
        else:
            icao_with_metar = {
                item["icao"]: {"lat": item["lat"], "lon": item["lon"], "country": item["country"], "name": item["name"]}
                for item in AERODROME_DATA
                if item.get("metar_station") is True
            }

        # Return
        return icao_with_metar


    def remove_wind_envelope_plot(fname):
        print(f"> func: remove_wind_envelope_plot({fname})")

        # Clear field
        element = js.document.getElementById(f'{fname}_WIND_ENVELOPE_TEXT')
        element.value = ''
        element = js.document.getElementById(f'{fname}_WIND_ENVELOPE_PLOT')
        element.innerHTML = ''


    def remove_metar_widget(fname):
        """Remove METAR widget for the specified aerodrome if it exists"""
        print(f"> func: remove_metar_widget({fname})")

        # Clear the METAR container
        widget_id = f"{fname}-WidgetContainer"
        widget = js.document.getElementById(widget_id)
        # Clear the container instead of removing it
        if widget:
            widget.innerHTML = ''
            print(f"   >üßπ Cleared METAR widget for {fname}")

        # Clear the airportweather container
        # widget_id = f"{fname}-airportweather-container"
        # widget = js.document.getElementById(widget_id)
        # Clear the container instead of removing it
        # if widget:
        #     widget.innerHTML = ''
        #     print(f"üßπ Cleared airportweather widget for {fname}")

        datetime_field = js.document.getElementById(f'DATETIME-METAR-{fname}')
        # button = js.document.getElementById(f'BTN-METAR-{fname}')
        metarField = js.document.getElementById(f'METAR-FIELD-{fname}')
        metarText = js.document.getElementById(f'METAR-TEXT-{fname}')

        windDirectionField = js.document.getElementById(fname + '_WIND_DIRECTION');
        windSpeedField = js.document.getElementById(fname + '_WIND_SPEED');
        windGustField = js.document.getElementById(fname + '_WIND_GUST');
        windVariationField = js.document.getElementById(fname + '_WIND_VARIATION');
        windHeadwindField = js.document.getElementById(fname + '_WIND_HEADWIND');
        windCrosswindField = js.document.getElementById(fname + '_WIND_CROSSWIND');

        # button.style.backgroundColor = '#006280';
        datetime_field.style.backgroundColor = 'transparent';
        metarField.style.backgroundColor = 'transparent';
        metarText.style.backgroundColor = 'transparent';

        metarText.value = ' '
        datetime_field.value = ''
        metarField.value = ''
        windDirectionField.value = '';
        windSpeedField.value = '';
        windGustField.value = '';
        windVariationField.value = '';
        windHeadwindField.value = '';
        windCrosswindField.value = '';

        # Clear datetime
        js.window.flight_plan_data[f'{fname.upper()}_METAR'] = ''
        js.window.flight_plan_data[f'{fname.upper()}_METAR_ICAO'] = ''
        print(f"üßπ Cleared METAR datetime for {fname}")


    def haversine_distances(lat1, lon1, lats, lons):
        distances = np.array(list(map(lambda x, y: haversine(lat1, lon1, x, y), lats, lons)))
        return distances


    def haversine(lat1, lon1, lat2, lon2):
        """
        Calculate the Haversine distance between two sets of latitude and longitude coordinates.

        Parameters
        ----------
        lat1 : float
            Latitude of the first point in degrees.
        lon1 : float
            Longitude of the first point in degrees.
        lat2 : float
            Latitude of the second point in degrees.
        lon2 : float
            Longitude of the second point in degrees.

        Returns
        -------
        float
            The Haversine distance between the two points in kilometers.

        Example
        -------
        >>> haversine(37.7749, -122.4194, 34.0522, -118.2437)
        >>> 616.7752155325443

        """
        # if (lat1 is None) or (lon1 is None) or (lat2 is None) or (lon2 is None):
        #     print(lat1)
        #     return None

        R = 6371  # Radius of the Earth in kilometers

        # Convert latitude and longitude from degrees to radians
        lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])

        # Haversine formula
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        a = math.sin(dlat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

        # Distance in kilometers
        distance = R * c
        return distance

    # ================================================
    # AIRSPACE HELPERS
    # ================================================

    # Main loader: called from JS
    async def import_country_selected(fname, country):
        print(f'>func: import_country_selected({fname}, {country})')
        zip_bytes = None

        try:
            url = js.window.settings['url_aerodromes'] + country.replace(' ', '_') + ".zip"
            zip_bytes = await load_cached_zip(f"aerodrome_{country}", url)

            if zip_bytes:
                unzipKey = js.window.settings['unzipKey']
                df = extract_csv_from_zip(zip_bytes, unzipKey)
                js.console.log(f"   >‚úÖ Aerodromes loaded for {country}: {len(df)} rows.")
                print(f"   >‚úÖ Successfully loaded {len(df)} aerodromes for {country}")
                # print(df['country_code'])

                # For now, just show the first few entries
                # print(df.head().to_string())
                # print(f"Available columns: {df.columns.tolist()}")

                country_code = np.unique(df.get('country_code', ['']))
                country_code = country_code[0]
                print(country_code)

                try:
                    # Store data in global variable
                    if fname == 'DEPARTURE':
                        js.window.AERODROME_DEPARTURE_DATA = df.to_dict('records')
                    elif fname == 'ARRIVAL':
                        js.window.AERODROME_ARRIVAL_DATA = df.to_dict('records')

                    # Combine departure and arrival data when possible and store in global variable
                    concat_country_aerodromes()

                    # Update flag
                    window.updateFlag(fname, country_code)

                except AttributeError as e:
                    error_msg = f"‚ö†Ô∏è Error processing aerodrome data: {str(e)}"
                    print(f"‚ùå {error_msg}")
                    js.window.alert("‚ö†Ô∏è Error processing aerodrome data. Please check your input and try again.");
                    return

                # Populate the dropdown with aerodrome data
                if 'city_icao' in df.columns:
                    icao_codes = df['city_icao'].dropna().unique().tolist()
                    print(f"   >üìç Found {len(icao_codes)} unique ICAO cities")

                    # Clear and populate the dropdown
                    select = js.document.getElementById(f'{fname}_ICAO_CITY')

                    # Clear existing options except the first placeholder
                    select.innerHTML = '<option value="">Select ICAO</option>'

                    # Add each ICAO city as an option
                    for icao in sorted(icao_codes):
                        option = js.document.createElement('option')
                        option.value = icao
                        option.textContent = icao
                        select.appendChild(option)

                    print(f"   >‚úÖ Populated {fname}_ICAO_CITY dropdown with {len(icao_codes)} cities")
                else:
                    print(f"   >‚ö†Ô∏è '{fname}_city_icao' column not found in dataframe")
                    print(f"   >Available columns: {df.columns.tolist()}")
        except Exception as e:
            error_msg = f"   >‚ö†Ô∏è No airspace data available for {country}: {str(e)}"
            print(f"{error_msg}")
            js.window.alert(f"‚ö†Ô∏è No airspace data is available for the selected country: {country}.")
            # js.document.getElementById('loading-spinner').style.display = 'none'
            return

        # Get and then concat airspaces
        concat_airspaces(country)

        # Hide loading spinner when done
        # js.document.getElementById('loading-spinner').style.display = 'none'


    def concat_airspaces(country):
        # Import airspace polygon data
        new_airspaces = import_airspaces(country)

        if new_airspaces:
            # Create country-specific prefixed keys
            prefixed_airspaces = {}
            for key, value in new_airspaces.items():
                new_key = f"{country}_{key}"
                value['country_id'] = country  # Add country identifier to the airspace data
                prefixed_airspaces[new_key] = value

            if hasattr(js.window, 'airspaces') and js.window.airspaces:
                # Append new country data to existing airspaces
                js.window.airspaces.update(prefixed_airspaces)
            else:
                # Initialize with first country
                js.window.airspaces = prefixed_airspaces
        # print(js.window.airspaces.keys())


    # ================================================
    # AERODROME HELPERS
    # ================================================

    def concat_country_aerodromes():
        # Combine departure and arrival data when possible and store in global variable

        # Check whether data is available
        has_departure = hasattr(window, "AERODROME_DEPARTURE_DATA")
        has_arrival   = hasattr(window, "AERODROME_ARRIVAL_DATA")

        # Store only what is available
        if has_departure and not has_arrival:
            js.window.AERODROME_DATA = js.window.AERODROME_DEPARTURE_DATA
        elif not has_departure and has_arrival:
            js.window.AERODROME_DATA = js.window.AERODROME_ARRIVAL_DATA
        elif has_departure and has_arrival:
            dep = window.AERODROME_DEPARTURE_DATA
            arr = window.AERODROME_ARRIVAL_DATA

            # handle both lists and dicts automatically
            if isinstance(dep, list) and isinstance(arr, list):
                window.AERODROME_DATA = dep + arr
                print("OPTION 1")
            elif isinstance(dep, dict) and isinstance(arr, dict):
                window.AERODROME_DATA = {**dep, **arr}
                print("OPTION 2")
            else:
                # fallback: convert to list if mixed
                window.AERODROME_DATA = list(dep) + list(arr)
                print("OPTION 3")
        else:
            window.AERODROME_DATA = {}


    async def populate_aerodrome_fields_from_icao(fname, city_icao):
        """Populate aerodrome fields when ICAO city is selected."""
        print(f'> func: populate_aerodrome_fields_from_icao({fname}, {city_icao})')

        # Load from cache if available
        isLoaded = await load_aerodrome_from_json(fname.upper(), icao=city_icao, verbose='silent')
        if isLoaded:
            print(f"   >‚úÖ Aerodrome is loaded from cache! <do not retrieve any other data>")
            return

        # Get the stored dataframe
        if not hasattr(js.window, f'AERODROME_{fname}_DATA'):
            print(f"   >‚ö†Ô∏è No aerodrome data available:'AERODROME_{fname}_DATA'")
            return

        # Get data
        if fname == 'DEPARTURE':
            df = js.window.AERODROME_DEPARTURE_DATA
        elif fname == 'ARRIVAL':
            df = js.window.AERODROME_ARRIVAL_DATA

        # Get data for specific ICAO
        row_dict = get_icao_data(df, city_icao)

        if not row_dict:
            print(f"   >‚ö†Ô∏è No data found for {city_icao}")
            return

        # Get runway data
        rwy_ids, rwy_list = retrieve_runways(row_dict)
        # print(rwy_ids)

        # Store data
        CTR_BOOL = row_dict['AERODROME_CTR']
        FREQ_TOWER_RADIO = row_dict['freqs.TOWER'] if CTR_BOOL else row_dict['freqs.RADIO']
        js.window.flight_plan_data[f"{fname}_ICAO"] = row_dict['icao']
        js.window.flight_plan_data[f"{fname}_ICAO_CITY"] = city_icao
        js.window.flight_plan_data[f"{fname}_RUNWAYS"] = rwy_list
        js.window.flight_plan_data[f"{fname}_RUNWAY"] = clean_string(rwy_ids)
        js.window.flight_plan_data[f"{fname}_NAME"] = row_dict['name']
        js.window.flight_plan_data[f"{fname}_ELEVATION"] = str(row_dict['elevation_aerodrome']).split('.')[0]
        js.window.flight_plan_data[f"{fname}_METAR"] = ''
        js.window.flight_plan_data[f"{fname}_METAR_ICAO"] = ''
        js.window.flight_plan_data[f"{fname}_WIND_ENVELOPE"] = ''

        ctr_value = 'CTR' if CTR_BOOL else ''
        js.window.flight_plan_data[f"{fname}_CTR"] = ctr_value
        js.document.getElementById(f'{fname}_CTR').value = ctr_value
        js.document.getElementById(f'{fname}_CTR').dispatchEvent(js.Event.new('change'))

        js.window.flight_plan_data[f"{fname}_COUNTRY"] = row_dict['country']
        js.window.flight_plan_data[f"{fname}_COUNTRY_CODE"] = row_dict['country_code']
        js.window.flight_plan_data[f"{fname}_IMAGE"] = row_dict.get('url.wikipedia.aerodrome.image', None)
        js.window.flight_plan_data[f"{fname}_URL_WEBSITE"] = row_dict.get('url.website', '')
        js.window.flight_plan_data[f"{fname}_URL_WIKIPEDIA"] = row_dict.get('url.wikipedia', '')
        js.window.flight_plan_data[f"{fname}_LATLON"] = [row_dict.get('lat', None), row_dict.get('lon', None)]

        # Update route map if both departure and arrival coordinates are available
        # if hasattr(js.window, 'updateRouteLine'): js.window.updateRouteLine()
        js.window.flight_plan_data[f"{fname}_TIMEZONE"] = row_dict.get('tz', None)

        if fname == 'DEPARTURE':
            # Handle FREQ_TOWER_RADIO
            js.window.flight_plan_data["DEPARTURE_ATC_TOWER"] = clean_string(FREQ_TOWER_RADIO)

            # MAPPING OF THE FREQUENCIES
            field_mapping = {
              f"{fname}_ATC_ATIS_FREQ": 'freqs.ATIS',
              f"{fname}_ATC_GROUND": 'freqs.DELIVERY/GROUND',
              f"{fname}_ATC_APPROACH": 'freqs.APPROACH',
              f"{fname}_ATC_TELEPHONE": 'freqs.TELEPHONE',
              'FIC_NAME': 'freqs.FIC_NAME',
              'FIC_FREQUENCY': 'freqs.FIC_FREQUENCY',
              'FIC_NAME2': 'freqs.FIC_NAME_2',
              'FIC_FREQUENCY2': 'freqs.FIC_FREQUENCY_2',
            }

            # FILL THE FREQUENCIES
            for key, colname in field_mapping.items():
              freq_raw = row_dict[colname]
              freq_clean = clean_string(freq_raw)
              js.window.flight_plan_data[key] = freq_clean
              print(f"  {key}: {js.window.flight_plan_data[key]}")

        # Update GUI fields for aerodrome
        update_aerodrome_gui_fields(fname)

        # Update images for aerodrome
        await update_aerodrome_image(fname)

        # Remove METAR widget
        remove_metar_widget(fname)

        # remove wind envelope plot
        remove_wind_envelope_plot(fname)

        # Retrieve METAR
        await js.window.retrieve_metar(fname)

    # ================================================
    # GUI HELPERS
    # ================================================

    def clean_string(value):
        # Convert to string and strip brackets/quotes
        freq_str = str(value).strip().strip('[]').replace("'", "").replace('"', '')
        # Split, clean, and filter empty items
        parts = [f.strip() for f in freq_str.split(',') if f.strip()]
        # Return
        return ', '.join(parts)

    def create_callsign_short(CALLSIGN):
        # Create short callsign automatically
        CALLSIGN_SHORT = ''
        if CALLSIGN is not None and CALLSIGN != '':
            CALLSIGN_SHORT = CALLSIGN[0] + CALLSIGN[-2:]
        return CALLSIGN_SHORT

    def TEXT_INFORMATION_RECEIVED():
        """Return text confirming information received"""
        return '<br><br>INFORMATION <strong class="pilot_text"> [ .   .   .   .   .   . ]</strong> RECEIVED,'

    async def clear_general_fields():
        """Clear all GENERAL GUI fields and flight_plan_data"""
        print("üßπ Clearing all GENERAL fields...")

        # List of all departure fields to clear
        field_ids = [
          'FLIGHTPLAN',
          'DATETIME',
          'CALLSIGN',
          'AIRCRAFT_TYPE',
          'FLIGHT_RULES',
          'POB',
        ]

        # Clear GUI fields
        for field_id in field_ids:
            element = js.document.getElementById(field_id)
            if element:
                if field_id == 'FLIGHT_RULES':
                    element.value = 'VFR'
                else:
                    element.value = ''

        # Clear flight_plan_data
        keys = field_ids + ['CALLSIGN_SHORT']
        for key in keys:
            if key == 'FLIGHT_RULES':
                js.window.flight_plan_data[key] = 'VFR'
            else:
                js.window.flight_plan_data[key] = ''

        # Clear checklist
        get_default_checklist()


    def update_general_gui_fields(flight_plan_dict):
        """Update GENERAL GUI fields from js.window.flight_plan_data"""
        print('----> update_general_gui_fields()')
        print("üîÑ Updating GENERAL GUI fields...")

        fields = ['FLIGHTPLAN', 'CALLSIGN', 'AIRCRAFT_TYPE', 'POB', 'FLIGHT_RULES', 'DATETIME']
        for field in fields:
            if flight_plan_dict.get(field):
                js.document.getElementById(field).value = flight_plan_dict[field]


    def update_enroute_gui_fields(enroute_dict, spinner_name):
        """Update ENROUTE GUI fields from js.window.flight_plan_data"""
        print('>func: update_enroute_gui_fields()')
        print("üîÑ Updating ENROUTE GUI fields...")

        # Get all fields that need updating
        if spinner_name == 'fic_spinner':
            fields = ['FIC_NAME', 'FIC_FREQUENCY', 'OVERHEAD', 'SQUAWK']
        else:
            fields = ['FIC_NAME2', 'FIC_FREQUENCY2', 'OVERHEAD2', 'SQUAWK2']

        # Update each GUI field from flight_plan_data
        for field in fields:
            element = js.document.getElementById(field)
            if element:
                value = js.window.flight_plan_data.get(field, '')
                element.value = value if value not in ('', None, 'None', 'nan') else ''

        for field in fields:
            if enroute_dict.get(field):
                js.document.getElementById(field).value = enroute_dict[field]



    def update_aerodrome_gui_fields(fname):
        """Update GENERAL GUI fields from js.window.flight_plan_data"""
        print('> func: update_aerodrome_gui_fields()')

        # List of field IDs to update
        field_ids = [
            f'{fname}_COUNTRY',
            f'{fname}_ICAO_CITY',
            f'{fname}_NAME',
            f'{fname}_ICAO',
            f'{fname}_POSITION',
            f'{fname}_RUNWAY',
            f'{fname}_ELEVATION',
            f'{fname}_ROUTE_NAME',
            f'{fname}_ROUTE_ALTITUDE',
            f'{fname}_CIRCUIT_ALTITUDE',
            f'{fname}_CTR',
            f'{fname}_ATC_TOWER',
            f'{fname}_ATC_APPROACH',
            f'{fname}_ATC_ATIS_FREQ',
            f'{fname}_ATC_GROUND',
            f'{fname}_ATC_TELEPHONE',
        ]

        # Only update these fields based on DEPARTURE
        if fname == 'DEPARTURE':
            field_ids = field_ids + [
                'FIC_NAME',
                'FIC_FREQUENCY',
                'SQUAWK',
                'OVERHEAD',
                'FIC_NAME2',
                'FIC_FREQUENCY2',
                'SQUAWK2',
                'OVERHEAD2',
            ]

        updated_count = 0
        for field_id in field_ids:
            # Get the value from flight_plan_data
            value = js.window.flight_plan_data.get(field_id)

            # Get the HTML element
            element = js.document.getElementById(field_id)

            # Only continue if element exists
            if element:
                # Convert value to string and handle special cases
                if value is not None and value != '' and str(value) != 'nan' and str(value) != 'None':

                  # Handle boolean for CTR
                    if field_id == f'{fname}_CTR':
                        element.value = 'CTR' if (value or str(value).lower() == 'true') else ''
                    else:
                        element.value = str(value)

                    updated_count += 1
                    print(f"  ‚úì Updated {field_id}: {element.value}")
                else:
                    # Clear the field if no value
                    element.value = ''
            else:
                print(f"  >‚ö†Ô∏è Element not found: {field_id}")

        # For the ICAO field: also sync its mirror
        icao_element = js.document.getElementById(f'{fname}_ICAO')
        element_icao_2 = js.document.getElementById(f'{fname}_ICAO_2')
        element_icao_2.value = icao_element.value

        # Set a check for the loaded ICAO
        icao_label = js.document.getElementById(f'{fname}_ICAO_2_LABEL')
        if element_icao_2.value == '':
            icao_label.textContent = f'{fname.title()} (ICAO)'
        else:
            icao_label.textContent = f'‚úÖ {fname.title()} (ICAO)'

        # print(js.window.flight_plan_data.get(f'{fname}_CTR'))
        # print(js.window.flight_plan_data.get(f'{fname}_ATC_TOWER'))
        # print(js.window.flight_plan_data.get(f'{fname}_ATC_TOWER'))

        print(f"   >‚úÖ Updated {updated_count} GUI fields")


    async def clear_enroute_fields():
        """Clear all ENROUTE GUI fields and flight_plan_data"""
        print('----> clear_enroute_fields()')
        print("üßπ Clearing all ENROUTE fields...")

        # Clear GUI fields
        js.document.getElementById('FIC_NAME').value = ''
        js.document.getElementById('FIC_FREQUENCY').value = ''
        js.document.getElementById('OVERHEAD').value = ''
        js.document.getElementById('SQUAWK').value = ''
        js.document.getElementById('FIC_NAME2').value = ''
        js.document.getElementById('FIC_FREQUENCY2').value = ''
        js.document.getElementById('OVERHEAD2').value = ''
        js.document.getElementById('SQUAWK2').value = ''

        # Clear enroute fields
        enroute_keys = [
            'FIC_NAME', 'FIC_FREQUENCY', 'FIC_NAME2', 'FIC_FREQUENCY2',
            'OVERHEAD', 'OVERHEAD2', 'SQUAWK', 'SQUAWK2',
        ]

        for key in enroute_keys:
            js.window.flight_plan_data[key] = ''


    async def clear_aerodrome_fields(fname):
        """Clear all aerodrome GUI fields and flight_plan_data"""
        print(f'> func: clear_aerodrome_fields({fname})')
        print(f"   >üßπ Clearing all {fname} fields...")

        # List of all departure/arrival fields to clear - ensure critical fields are included
        field_ids = [
            f'{fname}_COUNTRY',
            f'{fname}_ICAO_CITY',
            f'{fname}_CTR',
            f'{fname}_NAME',
            f'{fname}_ICAO',
            f'{fname}_POSITION',
            f'{fname}_RUNWAY',
            f'{fname}_ELEVATION',
            f'{fname}_ROUTE_NAME',
            f'{fname}_ROUTE_ALTITUDE',
            f'{fname}_CIRCUIT_ALTITUDE',
            f'{fname}_ATC_TOWER',
            f'{fname}_ATC_APPROACH',
            f'{fname}_ATC_ATIS_FREQ',
            f'{fname}_ATC_GROUND',
            f'{fname}_ATC_TELEPHONE',
            f'DATETIME-METAR-{fname}',
            f'METAR-FIELD-{fname}',
            f'METAR-TEXT-{fname}',
            f'{fname}_WIND_DIRECTION',
            f'{fname}_WIND_SPEED',
            f'{fname}_WIND_GUST',
            f'{fname}_WIND_VARIATION',
            f'{fname}_WIND_HEADWIND',
            f'{fname}_WIND_CROSSWIND',
        ]

        print(f"Clearing fields for {fname}:")

        # First clear the unique field names
        element = js.document.getElementById(f'{fname}_ICAO_2')
        element.value = ''
        element = js.document.getElementById(f'{fname}_ICAO_2_LABEL')
        element.textContent = f'{fname.title()} (ICAO)'

        # Clear aerdrome image
        js.document.getElementById(f'{fname}_image_cache').src = js.window.settings['img_default_icao']

        # Clear all GUI fields with overlapping names
        for field_id in field_ids:
            element = js.document.getElementById(field_id)
            if element:
                print(f"   >üßπ Clearing {field_id}")
                element.value = ''
                # Trigger change event to update any dependent fields
                if field_id.endswith('_CTR'):
                    js.document.getElementById(field_id).dispatchEvent(js.Event.new('change'))

        # Clear flight_plan_data for aerodrome fields
        keys = [
            f'{fname}_COUNTRY', f'{fname}_COUNTRY_CODE', f'{fname}_ICAO_CITY',
            f'{fname}_ICAO', f'{fname}_ICAO_CITY', f'{fname}_NAME',
            f'{fname}_POSITION', f'{fname}_RUNWAY', f'{fname}_ELEVATION',
            f'{fname}_RUNWAYS', f'{fname}_ROUTE_NAME', f'{fname}_ROUTE_ALTITUDE',
            f'{fname}_CIRCUIT_ALTITUDE', f'{fname}_CTR', f'{fname}_IMAGE',
            f'{fname}_URL_WEBSITE', f'{fname}_URL_WIKIPEDIA', f'{fname}_LATLON',
            f'{fname}_METAR_ICAO', f'{fname}_METAR', f'{fname}_WIND_ENVELOPE',
            f'{fname}_CLOUD', f'{fname}_TIMEZONE', f'{fname}_ATC_TOWER',
            f'{fname}_ATC_ATIS_FREQ', f'{fname}_ATC_GROUND', f'{fname}_ATC_APPROACH',
            f'{fname}_ATC_TELEPHONE', f'{fname}_RUNWAY_LENGTH', f'{fname}_RUNWAY_SURFACE',
        ]

        for key in keys:
            if key == f'{fname}_CTR':
                js.window.flight_plan_data[key] = False
            elif '_LATLON' in key:
                js.window.flight_plan_data[key] = [None, None]
            elif key in [f'{fname}_METAR', f'{fname}_METAR_ICAO', f'{fname}_WIND_ENVELOPE']:
                js.window.flight_plan_data[key] = ''
            elif key in [f'{fname}_CLOUD', f'{fname}_RUNWAYS']:
                js.window.flight_plan_data[key] = ''
            else:
                js.window.flight_plan_data[key] = ''

        # Remove METAR widget
        remove_metar_widget(fname)
        # Remove wind envelope
        remove_wind_envelope_plot(fname)
        # Remove flag
        js.window.updateFlag(fname, 'remove')
        # Remove VFR icon
        js.window.updateFlightCatagoryIcon(fname, remove=True)
        # Update missing fields colors
        js.window.highlightMissingFields()

        # Clear selectionbox (WARNING: CAN NOT BE CLEARED HERE BECAUSE THE ICOA SELECTIONS WILL BE RESET AFTER SELECTION)
        # select = js.document.getElementById(f'{fname}_ICAO_CITY')
        # select.innerHTML = '<option value="">Select ICAO</option>'


    # ================================================
    # IMAGE HELPERS
    # ================================================

    async def update_aerodrome_image(fname):
        """Update image from DEPARTURE_IMAGE or ARRIVAL_IMAGE or use default"""
        print(f"> func: update_aerodrome_image({fname})")

        # Update flag
        window.updateFlag(fname)

        # Get the image URL from flight_plan_data
        # 1. from GitHub
        # 2. from wikipedia
        # 3. from default
        image_url1 = os.path.join(js.window.settings['url_aerodromes_images'], js.window.flight_plan_data[f'{fname}_ICAO']) + '.png' if js.window.flight_plan_data[f'{fname}_ICAO'] != '' else None
        image_url2 = js.window.flight_plan_data.get(f'{fname}_IMAGE')

        for image_url in [image_url1, image_url2]:
            if await cache_and_display_image(image_url, f'{fname}_image_cache'):
                print(f"  üìã {fname}_IMAGE from flight_plan_data: {image_url}")
                return

        # Set the default image when all other fails
        js.document.getElementById(f'{fname}_image_cache').src = js.window.settings['img_default_icao']


    async def cache_and_display_image(url, img_element_id):
        """Cache and display an image using browser cache API"""
        # If the URL is invalid or missing, return without displaying an image
        if not url or str(url) == 'None' or str(url) == '' or str(url) == 'nan' or not str(url).startswith('http'):
            return False

        try:
            cache = await js.caches.open("skywalk-cache-v1")

            # Try loading from cache
            response = await cache.match(url)

            if not response:
                print(f"  üì• Image not cached, downloading: {url}")
                response = await js.fetch(url)
                if response.ok:
                    await cache.put(url, response.clone())
                else:
                    print(f"  ‚ùå Failed to fetch image: {response.status}")
                    return False
            else:
                print(f"  üì¶ Loaded from cache: {url}")

            # Convert response to blob and display
            blob = await response.blob()
            object_url = js.URL.createObjectURL(blob)
            js.document.getElementById(img_element_id).src = object_url
            print(f"  ‚úÖ Image displayed: {img_element_id}")
            return True

        except Exception as e:
            print(f"  ‚ùå Error caching/displaying image: {e}")
            raise
            return False


    def get_icao_data(df, city_icao, colname='city_icao'):
        """Load custom icao from disk and update"""
        row_dict = {}
        for df_row in df:
            if df_row.get('city_icao') == city_icao:
                row_dict = df_row
                break
        # Return
        return row_dict

    # ================================================
    # WIND ENVELOPE HELPERS
    # ================================================

    def compute_wind_envelope(fname):
        """Compute the wind envelope based on the METAR data and runway number.

        The wind envelope can be used to visually see whether the crosswind/headwind remains within the limits
        with variable winds. To compute this, the wind strenghts is kept constant but the wind angle is varied
        from 0-360 degrees. If the red line (the present wind conditions) crosses the the blue line
        (the maximum wind limits), it indicates that certain wind angles can push the aircraft outside the maximum
        crosswind/headwind limits.

        The wind envelope is computed with the following parameters:
        - runway_number: The runway number.
        - max_headwind: The maximum headwind limit.
        - max_crosswind: The maximum crosswind limit.

        From the METAR data, the following parameters are used:
        - wind direction: The wind direction.
        - wind strength: The wind strength.
        - wind gust: The wind gust.
        - wind variation: The wind variation.

        """
        logger.info(f"func: compute_wind_envelope() - {fname}")
        # In case the user has changed the runway input, update the flightplan data
        #  js.window.flight_plan_data.update(
        #     {f"{fname}_RUNWAY": self.RUNWAY_input.text.strip()}
        # )

        # Get the METAR data and runway number
        METAR_DATA = js.window.flight_plan_data.get(f"{fname}_METAR_ICAO", {})
        RUNWAY = js.window.flight_plan_data.get(f"{fname}_RUNWAY", "")
        # Check if the runway and METAR data are set, otherwise show a popup and return
        if RUNWAY == "" or METAR_DATA == {}:
            logger.warning(f"Set the runway.")
            print("Set Runway", "Please set the runway.")
            return

        # In case the user has changed the wind input fields, update the METAR data
        # logger.info(f"Updating in dict from GUI fields")
        # METAR_DATA["wind"]["direction"] = format_wind_direction(
        #     self.wind_direction_input.text.strip()
        # )
        # METAR_DATA["wind"]["speed"] = self.wind_speed_input.text.strip()
        # METAR_DATA["wind"]["gust"] = self.wind_gust_input.text.strip()
        # METAR_DATA["wind"]["variation"] = self.wind_variation_input.text.strip()
        # Update the flightplan data with the METAR data
        js.window.flight_plan_data[f"{fname}_METAR"] = METAR_DATA

        # Compute the wind envelope
        # WIND_ENVELOPE = compute.wind_envelope_kivy(
        #     METAR_DATA=METAR_DATA,
        #     runway_number=RUNWAY,
        #     max_headwind=app.SETTINGS["MAX_HEADWIND_LIMIT"],
        #     max_crosswind=app.SETTINGS["MAX_CROSSWIND_LIMIT"],
        #     make_plot=True,
        #     show_message=True,
        #     temp_dir=get_tempdir("TEMP_IMAGES"),
        # )

        # Update the flightplan data with the wind envelope
        # js.window.flight_plan_data.update({f"{self.fname}_WIND_ENVELOPE": WIND_ENVELOPE})
        # Render the wind envelope and show the image in the GUI
        # self._render_wind_envelope()


    # ================================================
    # RUNWAY HELPERS
    # ================================================

    def retrieve_runways(row_dict):
        """Retrieve the runways from ICAO"""
        # row_dict = get_icao_data(df, city_icao)
        rwy_ids, rwy_list = [], []

        # Get all INFORMATION for the selected ICAO
        if row_dict:
            runways = row_dict.get("runways", [])
            if isinstance(runways, str): runways = ast.literal_eval(runways)
            rwy_ids = [r["id"] for r in runways if isinstance(r, dict) and "id" in r]
            rwy_list = options_runway_number(runways)

        # Return
        return rwy_ids, rwy_list


    def options_runway_number(data):
        """Retrieve all available runways based on aerodrome ICAO."""
        runways = []
        if data is not None:
            runways = [num for rwy in data for num in rwy.get("number", [])]
            runways = list(filter(lambda x: x != '', runways))

        # Return
        return runways


    # def JsToPy(js_object):
    #     """Convert javascript dictionary object to python.
    #       Example
    #       -------
    #       >>> js_object = {'test': true}
    #       >>> JsToPy(js_object)
    #     """
    #     # return json.loads(js_string)
    #     return js_object.to_py()


    def expected_runway_number(fname, wind_direction='', wind_strength=''):
        """Compute the expected runway based on wind information for a given aerodrome."""
        print(f'> func: expected_runway_number({fname})')
        # Defaults
        expect_runway = ''
        runwayField = js.document.getElementById(fname + "_RUNWAY")
        extra_runways = runwayField.value.strip()

        # Get all runways for the aerodrome. We need to copy the list to avoid modifying the original data
        runways = js.window.flight_plan_data[f"{fname}_RUNWAYS"].copy()

        # Add more runways if provided
        if extra_runways is not None and extra_runways.strip() != '':
            rwys_clean = re.findall(r'\d+', extra_runways)
            runways.extend(rwys_clean)
            runways = list(set(runways))
        print(f'   >All available runways: {runways}')

        # Extract wind information from METAR data
        # wind_dict = analyzeWind(metar_icao)
        # wind_direction = wind_dict.get('direction', '')
        # wind_strength = wind_dict.get('speed', '')

        # Compute the expected runway number
        if (len(runways) > 0) and (wind_direction is not None) and is_numeric(wind_direction):
            results = list(map(lambda x: runway_headwind(wind_direction, wind_strength, x), runways))
            if np.any(results):
                expect_runway = runways[np.where(results)[0][0]]
        else:
            # js.window.messages = f'No wind direction: {wind_direction} or wind strength: {wind_strength} or runways: {runways}.'
            print(f'   >No wind direction {wind_direction} or wind_strength {wind_strength} or runways {runways} found')

        # Update the GUI input field
        if (expect_runway != '' and expect_runway is not None):
            # Set new runway
            runwayField.value = expect_runway
            # Change color
            runwayField.style.backgroundColor = "#e6f0ff";
            # metarText.value = js.window.messages;

        # Return
        print(f'   >Predicted runway: {expect_runway}')
        return expect_runway

    def correctRunwayNumber(runway_direction):
        """Correct the runway number by extracting the first two characters from the provided runway direction."""
        if isinstance(runway_direction, str) and len(runway_direction) > 1:
            runway_direction = runway_direction[0:2]
            runway_direction = int(runway_direction)
        return runway_direction

    def runway_headwind(wind_direction, wind_strength, runway_direction):
        """Compute whether the input runway number has headwind.

        The runway number is determined on the headwind component.
        If there is any headwind given wind direction, wind strength and runway direction, then
        it is the predicted runway number. However, the aerodrome always decides which runway is
        in use. On borderline results, it can be different than what is computed.

        Parameters
        ----------
        wind_direction : int[0-360]
            The wind direction in degrees.
        wind_strength : float
            The strenght of the wind.
        runway_direction : String or integer
            The runway direction in degrees but in 2 decimals '24' or '06' etc.

        Returns
        -------
        bool
            True: if runway direction matches to the wind.
            False: if runway direction does not match to the wind.

        Examples
        --------
        >>> # Example usage:
        >>> wind_direction = 179
        >>> wind_strength = 15
        >>> runway_direction = "27A"
        >>> runway_direction = "09"
        >>> OK = runway_headwind(wind_direction, wind_strength, runway_direction)
        >>> print(OK)
        """
        if (wind_direction is None) or not is_numeric(wind_direction) or (wind_strength is None) or (runway_direction is None):
            return None

        runway_direction = correctRunwayNumber(runway_direction)
        if not isinstance(runway_direction, (int, float)):
            return None

        cos_result = headwind(wind_direction, wind_strength, runway_direction)

        if cos_result > 0:
            return True
        else:
            return False

    # ================================================
    # WIND HELPERS
    # ================================================

    def variable_wind_range(wind_vrb):
        # Input looks like: '190-350' or '340-40'
        if isinstance(wind_vrb, list): wind_vrb = wind_vrb[0]
        if wind_vrb == '' or wind_vrb is None:
            return None
        total_range = None
        # Split
        wind_vrb = np.array(wind_vrb.split('-'))
        # Check numeric
        wind_vrb = wind_vrb[np.array(list(map(is_numeric, wind_vrb)))]
        # Continue
        if len(wind_vrb) > 0:
            # Make int
            wind_vrb = list(map(int, wind_vrb))
            # Always make a list of 2
            if len(wind_vrb) >= 2:
                start, end = wind_vrb[0], wind_vrb[-1]
            else:
                start, end = wind_vrb[0], wind_vrb[0]

            # Compute range
            if start <= end:
                total_range = np.array(list(range(start, end + 1, 10)))
            else:
                total_range = np.array(list(range(start, 360, 10)) + list(range(0, end + 1, 10)))
        # Total range
        return total_range

    def crosswind(wind_direction, wind_strength, runway_direction):
        """Compute crosswind strength.

        Crosswind component = sin(runway-wind Direction)*strength

        Parameters
        ----------
        wind_direction : int[0-360]
            The wind direction in degrees.
        wind_strength : float
            The strenght of the wind.
        runway_direction : String or integer
            The runway direction in degrees but in 2 decimals '24' or '06' etc.

        Returns
        -------
        result : float
            crosswind strength.

        Examples
        --------
        # Example usage:
        >>> wind_direction = 250
        >>> wind_strength = 4
        >>> runway_direction = "27"
        >>> cw = crosswind(wind_direction, wind_strength, runway_direction)
        >>> print(f"Result: {cw}")

        """
        print(f'   >func: crosswind({wind_direction}, {wind_strength}, {runway_direction})')
        if (wind_direction is None) or not is_numeric(wind_direction) or (wind_strength is None) or (runway_direction is None):
            print(f'Error: Wind direction:{wind_direction} and wind strength:{wind_strength} should be numeric')
            return None

        runway_direction = correctRunwayNumber(runway_direction)
        if not isinstance(runway_direction, (int, float)):
            return None

        radians_difference = math.radians(wind_direction - (runway_direction * 10))
        result = round(math.sin(radians_difference) * wind_strength, 1)
        if result == 0: result = int(result)
        return result

    def headwind(wind_direction, wind_strength, runway_direction):
        """Compute headwind strength.

        Headwind component = cos(runway-wind direction)*strength

        Parameters
        ----------
        wind_direction : int[0-360]
            The wind direction in degrees.
        wind_strength : float
            The strenght of the wind.
        runway_direction : String or integer
            The runway direction in degrees but in 2 decimals '24' or '06' etc.

        Returns
        -------
        result : float
            crosswind strength.

        Examples
        --------
        # Example usage:
        >>> wind_direction = 250
        >>> runway_direction = "27"
        >>> wind_strength = 4
        >>> hw = headwind(wind_direction, wind_strength, runway_direction)
        >>> print(f"Result: {hw}")

        """
        print(f'   >func: headwind({wind_direction}, {wind_strength}, {runway_direction})')
        if (wind_direction is None) or not is_numeric(wind_direction) or (wind_strength is None) or (runway_direction is None):
            return None
        # Check runway
        runway_direction = correctRunwayNumber(runway_direction)
        if not isinstance(runway_direction, (int, float)):
            return None

        # print(wind_direction)
        # print(wind_strength)
        # print(runway_direction)

        radians_difference = math.radians(wind_direction - (runway_direction * 10))
        result = round(math.cos(radians_difference) * wind_strength, 1)
        if result == 0: result = int(result)
        return result

    def is_numeric(value):
        """
        Check whether the input string is a numerical value.

        Parameters
        ----------
        value : str
            The input string to be checked.

        Returns
        -------
        bool
            True if the input string is a numerical value, False otherwise.

        Example
        -------
        >>> is_numeric("-2.9")
        >>> True
        >>> is_numeric("2.33")
        >>> True
        >>> is_numeric("22272")
        >>> True
        >>> is_numeric("0.003")
        >>> True
        >>> is_numeric("-0.003")
        >>> True
        >>> is_numeric("abc")
        >>> False
        >>> is_numeric("1.2.3")
        >>> False
        >>> is_numeric("1B")
        >>> False

        """
        # Check if the string is empty
        if (isinstance(value, str) and value == ''):
            return False
        if isinstance(value, (float, int)):
            return True
        if value is None:
            return False
        if isinstance(value, str):
            value = value.strip()

        # Allow negative numbers (starting with '-' at the beginning)
        if value[0] == '-':
            value = value[1:]

        # Allow decimal points in the string
        parts = value.split('.')
        if len(parts) <= 2 and all(part.isnumeric() for part in parts):
            return True

        return False

    # ================================================
    # FLIGHTPLAN HELPERS
    # ================================================

    async def create_new_flightplan():
        """Initialize new flightplan - returns current datetime for UI"""
        # Get current datetime for UI
        current_time = datetime.now().strftime("%d-%m-%Y %H:%M")
        print("üÜï Creating new flightplan...")

        # Store default flight plan data
        # js.window.flight_plan_data = await get_default_data()

        # Reset flight plan data
        js.window.flight_plan_data = {
            'DEPARTURE_LATLON': [None, None],
            'ARRIVAL_LATLON': [None, None],
            'DEPARTURE_COUNTRY': '',
            'ARRIVAL_COUNTRY': '',
        }
        js.window.flight_plan_data['CHECKLIST'] = get_default_checklist()

        # Populate checklist items
        checklist_populate()

        # Clear fields
        await clear_general_fields()
        await clear_aerodrome_fields('DEPARTURE')
        await clear_aerodrome_fields('ARRIVAL')
        await clear_enroute_fields()
        checklist_clean(verbose='silent')

        # Remove METAR widget
        # remove_metar_widget('DEPARTURE')
        # remove_metar_widget('ARRIVAL')

        # Remove wind envelope
        # remove_wind_envelope_plot('DEPARTURE')
        # remove_wind_envelope_plot('ARRIVAL')

        select = js.document.getElementById('DEPARTURE_ICAO_CITY')
        select.innerHTML = '<option value="">Select ICAO</option>'
        select = js.document.getElementById('ARRIVAL_ICAO_CITY')
        select.innerHTML = '<option value="">Select ICAO</option>'

        js.window.AERODROME_DEPARTURE_DATA = {}
        js.window.AERODROME_ARRIVAL_DATA = {}
        js.window.AERODROME_DATA = {}
        js.window.airspaces = {}
        js.window.waypoints = []
        js.window.METAR_DEPARTURE = ''
        js.window.METAR_ARRIVAL = ''

        print("‚úÖ New flightplan initialized - all fields cleared")
        return current_time


    async def delete_flightplan():
        """Delete selected flightplan from localStorage"""
        plan_name = js.document.getElementById('plan_spinner').value

        if not plan_name or plan_name == "":
            print("‚ö†Ô∏è No flightplan selected")
            return

        # Confirm deletion
        if not js.window.confirm(f"Are you sure you want to delete '{plan_name}'?"):
            print("‚ùå Deletion cancelled")
            return

        # Delete from localStorage
        storage_key = f"FLIGHTPLAN_{plan_name}"
        js.localStorage.removeItem(storage_key)
        print(f"‚úÖ Flightplan '{plan_name}' deleted")

        # Clear the dropdown selection
        js.document.getElementById('plan_spinner').value = ""

        # Update the flightplan list
        update_dropdown('plan_spinner', cacheName='FLIGHTPLAN', keepSelection=False, elementId2='FLIGHTPLAN')

        """Create new flightplan with current timestamp"""
        await clear_general_fields()
        await clear_aerodrome_fields('DEPARTURE')
        await clear_aerodrome_fields('ARRIVAL')
        await clear_enroute_fields()

        # Clean all fields from checklist
        # get_default_checklist()
        js.window.flight_plan_data['CHECKLIST'] = get_default_checklist()
        # populate checklist items
        checklist_populate()

        # Clean flag
        # updateFlag('DEPARTURE', 'remove')
        # updateFlag('ARRIVAL', 'remove')


    async def delete_item_from_spinner(spinner_name, cacheName, elementId2=None):
        """Delete selected dropdown item in local cache"""
        # Get dropdown selection
        user_selection = js.document.getElementById(spinner_name).value

        if not user_selection or user_selection == "":
            print(f"‚ö†Ô∏è No {cacheName} in {spinner_name} selected")
            return

        # Confirm deletion
        if not js.window.confirm(f"Are you sure you want to delete '{user_selection}'?"):
            print("‚ùå Deletion cancelled")
            return

        # Create cache key
        cache_key = f"{cacheName}_{user_selection}"

        # Delete from localStorage
        js.localStorage.removeItem(cache_key)
        print(f"‚úÖ {cacheName} '{user_selection}' deleted")

        # Clear the GUI dropdown selection
        js.document.getElementById(spinner_name).value = ""

        # Clear the GUI fields
        if spinner_name == 'fic_spinner':
            js.document.getElementById('FIC_NAME').value = ''
            js.document.getElementById('FIC_FREQUENCY').value = ''
            js.document.getElementById('OVERHEAD').value = ''
            js.document.getElementById('SQUAWK').value = ''
        elif spinner_name == 'fic_spinner2':
            js.document.getElementById('FIC_NAME2').value = ''
            js.document.getElementById('FIC_FREQUENCY2').value = ''
            js.document.getElementById('OVERHEAD2').value = ''
            js.document.getElementById('SQUAWK2').value = ''

        if elementId2 is not None:
            js.document.getElementById(elementId2).value = ''

        # Update the spinner-dropdown list
        if spinner_name == 'fic_spinner' or spinner_name == 'fic_spinner2':
            update_dropdown('fic_spinner', cacheName='enroute', keepSelection=False)
            update_dropdown('fic_spinner2', cacheName='enroute', keepSelection=False)
        elif spinner_name == 'checklist_spinner':
            update_dropdown(spinner_name, cacheName=cacheName, keepSelection=False)
            # Set the default checklist
            checklist_clean(verbose='silent')
        else:
            update_dropdown(spinner_name, cacheName=cacheName, keepSelection=False)


    async def load_enroute_fic(spinner_name):
        """Load selected FIC from localStorage"""
        print(f'> func: load_enroute_fic({spinner_name})')

        # Get the user selection from the spinner element
        user_selection = js.document.getElementById(spinner_name).value

        if not user_selection or user_selection == "":
            print("   >‚ö†Ô∏è No Enroute FIC selected")
            return

        print(f"   >üìÇ Loading Enroute: {user_selection}")

        # Clear relevant fields based on spinner
        if spinner_name == 'fic_spinner':
            js.document.getElementById('FIC_NAME').value = ''
            js.document.getElementById('FIC_FREQUENCY').value = ''
            js.document.getElementById('OVERHEAD').value = ''
            js.document.getElementById('SQUAWK').value = ''
        elif spinner_name == 'fic_spinner2':
            js.document.getElementById('FIC_NAME2').value = ''
            js.document.getElementById('FIC_FREQUENCY2').value = ''
            js.document.getElementById('OVERHEAD2').value = ''
            js.document.getElementById('SQUAWK2').value = ''

        print(f"   >üìÇ Loading Enroute: {user_selection}")

        # Load from cache (localStorage)
        storage_key = f"ENROUTE_{user_selection}"
        json_data = js.localStorage.getItem(storage_key)

        if not json_data:
            print(f"   >‚ö†Ô∏è ENROUTE not found: {user_selection}")
            js.window.alert(f"‚ö†Ô∏è ENROUTE '{user_selection}' was not found.")
            return

        # Parse JSON
        try:
            enroute_dict = json.loads(json_data)
            print(f"   >‚úÖ Loaded ENROUTE: {len(enroute_dict)} fields for {spinner_name}")

            # Update the keys in enroute_dict in case of fic_spinner2
            if spinner_name == 'fic_spinner2':
                enroute_dict['FIC_NAME2'] = enroute_dict.pop('FIC_NAME', None)
                enroute_dict['FIC_FREQUENCY2'] = enroute_dict.pop('FIC_FREQUENCY', None)
                enroute_dict['OVERHEAD2'] = enroute_dict.pop('OVERHEAD', None)
                enroute_dict['SQUAWK2'] = enroute_dict.pop('SQUAWK', None)

            # Fill the flight_plan_data dictionary
            for key, value in enroute_dict.items():
                print(f"   >ENROUTE Key: {key}, Value: {value}")
                js.window.flight_plan_data[key] = value if value not in ('', None, 'None', 'nan') else ''

            # Update GUI FIELDS
            update_enroute_gui_fields(enroute_dict, spinner_name)
            # Update missing fields colors
            js.window.highlightMissingFields()


            print(f"   >‚úÖ Flightplan '{user_selection}' loaded successfully")
        except Exception as e:
            print(f"   >‚ö†Ô∏è Error loading flightplan: {e}")
            js.window.alert(f"‚ùó Error loading flight plan: {e}")


    async def load_flightplan():
        """Load flightplan from localStorage"""
        print(f"> func: load_flightplan()")

        plan_name = js.document.getElementById('plan_spinner').value

        # First clear all fields
        # await clear_general_fields()
        # await clear_aerodrome_fields('DEPARTURE')
        # await clear_aerodrome_fields('ARRIVAL')
        # await clear_enroute_fields()

        if not plan_name or plan_name == "":
            print("‚ö†Ô∏è No flightplan selected")
            return

        # Remove METAR widget
        remove_metar_widget('DEPARTURE')
        remove_metar_widget('ARRIVAL')

        # remove wind envelope plot
        remove_wind_envelope_plot('DEPARTURE')
        remove_wind_envelope_plot('ARRIVAL')

        # Set default values for dropdown elements
        select = js.document.getElementById('DEPARTURE_ICAO_CITY')
        select.innerHTML = '<option value="">Select ICAO</option>'
        select = js.document.getElementById('ARRIVAL_ICAO_CITY')
        select.innerHTML = '<option value="">Select ICAO</option>'

        # Load from localStorage
        storage_key = f"FLIGHTPLAN_{plan_name}"
        json_data = js.localStorage.getItem(storage_key)

        if not json_data:
            print(f"   >‚ö†Ô∏è Flightplan not found: {plan_name}")
            js.window.alert(f"‚ö†Ô∏è Flightplan '{plan_name}' not found.")
            return

        # Parse JSON
        try:
            # Load json data file
            flight_plan_dict = json.loads(json_data)
            print(f"   >‚úÖ Loaded {len(flight_plan_dict)} fields")

            # Initialize empty waypoints array
            js.window.waypoints = []
            # js.window.messages = ''

            # Fill the flight_plan_data dictionary from the loaded JSON data
            for key, value in flight_plan_dict.items():
                js.window.flight_plan_data[key] = value

            # print(js.window.flight_plan_data)
            # js.window.waypoints = window.flight_plan_data['WAYPOINTS']

            # Update GUI FIELDS
            update_general_gui_fields(flight_plan_dict)
            update_aerodrome_gui_fields('DEPARTURE')
            update_aerodrome_gui_fields('ARRIVAL')

            # Update IMAGES
            await update_aerodrome_image('DEPARTURE')
            await update_aerodrome_image('ARRIVAL')

            # Update Flag
            js.window.updateFlag('DEPARTURE', 'remove')
            js.window.updateFlag('ARRIVAL', 'remove')
            # Update VFR icon
            js.window.updateFlightCatagoryIcon('DEPARTURE', remove=True)
            js.window.updateFlightCatagoryIcon('ARRIVAL', remove=True)

            # Add data to javascript global cache. This is needed for the aerodrome selection and plotting on the map
            if flight_plan_dict['DEPARTURE_COUNTRY'] != '':
                await import_country_selected('DEPARTURE', flight_plan_dict['DEPARTURE_COUNTRY'])
                # Update spinner
                element = js.document.getElementById('DEPARTURE_ICAO_CITY')
                element.value = flight_plan_dict['DEPARTURE_ICAO_CITY']

            if flight_plan_dict['ARRIVAL_COUNTRY'] != '':
                await import_country_selected('ARRIVAL', flight_plan_dict['ARRIVAL_COUNTRY'])
                # Update spinner
                element = js.document.getElementById('ARRIVAL_ICAO_CITY')
                element.value = flight_plan_dict['ARRIVAL_ICAO_CITY']

            # Populate checklist
            checklist_populate()

            # Update METAR
            js.window.retrieve_metar('DEPARTURE', verbose='silent')
            js.window.retrieve_metar('ARRIVAL', verbose='silent')

            print(f"   >‚úÖ Flightplan '{plan_name}' loaded successfully")
        except Exception as e:
            print(f"   >‚ùó Error loading flightplan: {e}")
            js.window.alert(f"‚ùó Error loading flight plan: {e}")


    def save_flightplan(to_cache=True):
        """Save current flightplan data to localStorage"""

        # STORE FIELDS FROM GENERAL IN FLIGHTPLAN
        js.window.flight_plan_data["FLIGHTPLAN"] = js.document.getElementById('FLIGHTPLAN').value;
        js.window.flight_plan_data["POB"] = js.document.getElementById('POB').value;
        js.window.flight_plan_data["FLIGHT_RULES"] = js.document.getElementById('FLIGHT_RULES').value;
        js.window.flight_plan_data["DATETIME"] = js.document.getElementById('DATETIME').value;
        js.window.flight_plan_data["AIRCRAFT_TYPE"] = js.document.getElementById('AIRCRAFT_TYPE').value;
        js.window.flight_plan_data["CALLSIGN"] = js.document.getElementById('CALLSIGN').value;
        js.window.flight_plan_data["CALLSIGN_SHORT"] = js.window.create_callsign_short(js.document.getElementById('CALLSIGN').value);
        # STORE FIELDS FROM ENROUTE IN FLIGHTPLAN
        js.window.flight_plan_data["FIC_NAME"] = js.document.getElementById('FIC_NAME').value;
        js.window.flight_plan_data["FIC_FREQUENCY"] = js.document.getElementById('FIC_FREQUENCY').value;
        js.window.flight_plan_data["OVERHEAD"] = js.document.getElementById('OVERHEAD').value;
        js.window.flight_plan_data["SQUAWK"] = js.document.getElementById('SQUAWK').value;
        js.window.flight_plan_data["FIC_NAME2"] = js.document.getElementById('FIC_NAME2').value;
        js.window.flight_plan_data["FIC_FREQUENCY2"] = js.document.getElementById('FIC_FREQUENCY2').value;
        js.window.flight_plan_data["OVERHEAD2"] = js.document.getElementById('OVERHEAD2').value;
        js.window.flight_plan_data["SQUAWK2"] = js.document.getElementById('SQUAWK2').value;
        # STORE ROUTE AND POSITION FIELDS IN FLIGHTPLAN
        js.window.flight_plan_data["DEPARTURE_ROUTE_NAME"] = js.document.getElementById('DEPARTURE_ROUTE_NAME').value;
        js.window.flight_plan_data["DEPARTURE_POSITION"] = js.document.getElementById('DEPARTURE_POSITION').value;
        js.window.flight_plan_data["ARRIVAL_ROUTE_NAME"] = js.document.getElementById('ARRIVAL_ROUTE_NAME').value;
        js.window.flight_plan_data["ARRIVAL_POSITION"] = js.document.getElementById('ARRIVAL_POSITION').value;
        # STORE WAYPOINTS
        # js.window.flight_plan_data['WAYPOINTS'] = js.window.waypoints
        # ALL OTHER FIELDS SHOULD BE STORE ALREADY IN THE FLIGHTPLAN DATA

        # GET FLIGHTPLAN NAME
        flightplan_name = js.window.flight_plan_data["FLIGHTPLAN"]
        if flightplan_name is None or flightplan_name == '':
            js.window.alert("‚ÑπÔ∏è Please enter a flight plan name before saving.")

        # Print the saved variables array
        print("-------------SAVE FLIGHTPLAN DATA TO DICT-------------")
        print(f"> func: save_flightplan({flightplan_name})")

        # Convert flight_plan_data to JSON string
        flight_plan_dict = {}
        keys = get_default_data()
        for key in keys:
            try:
                value = js.window.flight_plan_data.get(key)
                # Convert JavaScript objects to Python objects
                if hasattr(value, 'to_py'):
                    value = value.to_py()
                flight_plan_dict[key] = value
            except Exception as e:
                print(f"   >‚ö†Ô∏è Failed to save {key}: {e}")

        # Print Data
        for key, value in flight_plan_dict.items():
            if value != '' and value != None and value != {} and value != []:
                print(f"     >{key}: '{value}'")

        # Save to cache
        if to_cache and flightplan_name and flightplan_name != "":
            print("-------------SAVE FLIGHTPLAN DATA TO CACHE-------------")

            # Convert to JSON string
            json_data = json.dumps(flight_plan_dict)

            # Save to localStorage with key "FLIGHTPLAN_"
            storage_key = f"FLIGHTPLAN_{flightplan_name}"
            js.localStorage.setItem(storage_key, json_data)

            # Get localStorage info
            # print_local_storage()

            # Update the list of saved flightplans
            update_dropdown('plan_spinner', cacheName='FLIGHTPLAN', keepSelection=True, elementId2='FLIGHTPLAN')
            # Update the enroute list
            update_dropdown('fic_spinner', cacheName='enroute', keepSelection=True)
            update_dropdown('fic_spinner2', cacheName='enroute', keepSelection=True)

            print("---------------DATA SAVED-------------------")
            js.window.alert("‚úÖ Flight plan saved successfully!");
            return True


    async def load_aerodrome_from_json(fname, elementId=None, icao=None, verbose='info'):
        # Load aerodrome data for departure or arrival from localStorage.
        print(f'> func: load_aerodrome_from_json({fname})')

        # Get element ID for ICAO
        if elementId is None: elementId = f'{fname}_ICAO'
        element = js.document.getElementById(elementId)
        icaoName = element.value.strip().upper() or ''
        if icao is not None:
            icaoName = re.search(r'\(([^)]+)\)', icao).group(1)
            icaoName = icaoName.strip().upper()

        # Get cached data
        cache_key = fname + '_' + icaoName
        json_data = js.localStorage.getItem(cache_key)

        # Check whether the cached data for the other (departure or arrival) aerdrome exists
        if not json_data:
            fname_opposite = 'DEPARTURE' if fname == 'ARRIVAL' else 'ARRIVAL'
            json_data = js.localStorage.getItem(fname_opposite + '_' + icaoName)
            if json_data:
                # This is a hack where I need to replace the name of DEPARTURE into ARRIVAL or the otherway arround. The reason is that I want to re-use departure and arrival aerodromes for each other if none exists.
                json_data = json_data.replace(fname_opposite, fname)

        if json_data:
            # Use the user saved aerodrome data
            pass
        elif not json_data and js.window.flight_plan_data[f'{fname}_ICAO_CITY'] == '':
            # No saved aerodrome but I nothing selected
            # Clean all GUI fields
            message = f"‚ÑπÔ∏è No custom saved aerodrome found for {icaoName}. Please select the aerodrome in the {fname.lower()} tab and check the input fields before saving."
            print(message)
            if verbose == 'info': js.window.alert(message)
            await clear_aerodrome_fields(fname)
            return False
        else:
            # No saved aerodrome and nothing selected
            message = f'‚ö†Ô∏è {fname.title()} aerodrome ({icaoName}) not valid or previously saved. Please choose the aerodrome using the selection box first.'
            print(message)
            if verbose == 'info': js.window.alert(message)

            # Get the original selected ICAO
            icaoSelected = js.document.getElementById(f'{fname}_ICAO_CITY')
            # Extract the string that is between parentheses in the alert message (e.g. the ICAO) and set it as the spinner value
            icao_value = re.search(r'\(([^)]+)\)', icaoSelected.value).group(1)
            # Store previous value back elements and flight plan
            js.document.getElementById(f'{fname}_ICAO').value = icao_value
            js.document.getElementById(f'{fname}_ICAO_2').value = icao_value
            js.window.flight_plan_data[f'{fname}_ICAO'] = icao_value
            # Update missing fields colors
            js.window.highlightMissingFields()
            # Return
            return False


        # Parse JSON
        try:
            fname_dict = json.loads(json_data)
            fname_dict[f'{fname}_RUNWAY'] = ''

            print(f"   >‚úÖ Loaded {len(fname_dict)} fields")

            # Clear aerodrome fields
            await clear_aerodrome_fields(fname)

            # Overwrite the keys in the flight_plan_data dictionary from the loaded JSON data
            for key, value in fname_dict.items():
                print(f"Key: {key}, Value: {value}")
                js.window.flight_plan_data[key] = value

            # Update GUI fields
            update_aerodrome_gui_fields(fname)

            # Update aerodrome image
            await update_aerodrome_image(fname)

            # Update spinners
            if fname_dict[f'{fname}_COUNTRY'] != '':
                # Update the country and load into memory
                await import_country_selected(fname, fname_dict[f'{fname}_COUNTRY'])
                # Get the ICAO CITY name
                element = js.document.getElementById(f'{fname}_ICAO_CITY')
                # Set the ICAO spinner
                element.value = fname_dict[f'{fname}_ICAO_CITY']

            # Update missing fields colors
            js.window.highlightMissingFields()

            # Remove METAR widget
            remove_metar_widget(fname)

            # Remove wind envelope
            remove_wind_envelope_plot(fname)

            # Update flag
            # window.updateFlag(fname)

            # Retrieve METAR data during loading of the aerodrome
            await js.window.retrieve_metar(fname, verbose=verbose)

            print(f"   >‚úÖ Aerodrome {icaoName} successfully loaded from cache: {fname.lower()}")
            # js.window.alert(f"‚úÖ Aerodrome {icaoName} successfully loaded for {fname.lower()}")
            return True
        except Exception as e:
            print(f"   >‚ö†Ô∏è Error loading aerodrome data: {str(e)}")
            js.window.alert(f"‚ùó Error loading aerodrome data for {icaoName}: {str(e)}")
            return False


    def save_aerodrome_to_json(fname):
        """Save custom aerodrome data (ICAO) to localStorage

        Saves data for either departure/arrival aerodrome data to browser's localStorage.
        For departure/arrival, saves relevant fields starting with that prefix.
        For enroute, saves specific enroute-related fields.
        All fields are saved but not all are loaded in load_aerodrome_from_json such as RUNWAY since they depend on weather conditions.

        Args:
            fname (str): Either 'DEPARTURE', 'ARRIVAL' to indicate what data to save

        The data is saved with a key format of:
        - For departure/arrival: [DEPARTURE|ARRIVAL]_[ICAO]

        Example:
            save_aerodrome_to_json('DEPARTURE')
            save_aerodrome_to_json('ARRIVAL')
        """
        print(f'> func: save_aerodrome_to_json({fname})')
        dict_fname = {}

        # Get flightplan data from dictionary
        flight_data = js.window.flight_plan_data

        # Create Cache key
        cache_key = fname + '_' + flight_data[f"{fname}_ICAO"]
        # Retrieve keys for dictionary
        dict_fname = {k: v for k, v in flight_data.items() if k.startswith(fname)}

        # Update the dictionary with data from GUI
        for key in dict_fname.keys():
            # Do not store RUNWAY keys because runways are determined by the weather conditions
            element = js.document.getElementById(key)
            # Check whether field GUI exists using truthiness check which handles JsNull
            if element and hasattr(element, 'value'):
                field_value = element.value
                if field_value and str(field_value) not in ('nan', 'None', ''):
                    print(f'Saving to {cache_key} dictionary: {key}: {field_value}')
                    dict_fname[key] = field_value

        # Save to cache
        message = f"‚úÖ Custom {fname.lower()} field information for {flight_data.get(f'{fname}_ICAO', '')} is saved."
        print(f'   >{message}')
        window.alert(message)
        # Convert to JSON string
        json_data = json.dumps(dict_fname)
        # Save to cache
        js.localStorage.setItem(cache_key, json_data)
        # save_to_cache(cache_key, dict_fname)


    def save_enroute_to_json(prefix):
        """Save custom enroute data to localStorage.

        Args:
            prefix (str): 'ENROUTE1', 'ENROUTE2'
        """
        print(f'> func: save_enroute_to_json({prefix})')

        # Create empty dict
        dict_enroute = {}

        # Store the FIC to localStorage
        if prefix == 'ENROUTE1':
            # Create cache key
            listname = js.document.getElementById('FIC_NAME').value
            cache_key = 'ENROUTE_' + listname.upper().strip()

            enroute_fields = {
                'FIC_NAME': js.document.getElementById('FIC_NAME').value,
                'FIC_FREQUENCY': js.document.getElementById('FIC_FREQUENCY').value,
                'OVERHEAD': js.document.getElementById('OVERHEAD').value,
                'SQUAWK': js.document.getElementById('SQUAWK').value,
            }
        elif prefix == 'ENROUTE2':
            # Create cache key
            listname = js.document.getElementById('FIC_NAME2').value
            cache_key = 'ENROUTE_' + listname.upper().strip()

            enroute_fields = {
                'FIC_NAME': js.document.getElementById('FIC_NAME2').value,
                'FIC_FREQUENCY': js.document.getElementById('FIC_FREQUENCY2').value,
                'OVERHEAD': js.document.getElementById('OVERHEAD2').value,
                'SQUAWK': js.document.getElementById('SQUAWK2').value
            }
        else:
            print(f'   >Invalid prefix: {prefix}')
            return

        if not listname or listname == '':
            return

        # Only store non-empty values
        for key, value in enroute_fields.items():
            if value and str(value) not in ('nan', 'None', ''):
                dict_enroute[key] = value
            else:
                dict_enroute[key] = ''

        # Save to cache
        print(f'   >{prefix} SAVED: {cache_key}')
        # Convert to JSON string
        json_data = json.dumps(dict_enroute)
        # Save to cache
        js.localStorage.setItem(cache_key, json_data)
        # Update the enroute list
        update_dropdown('fic_spinner', cacheName='enroute', keepSelection=True)
        update_dropdown('fic_spinner2', cacheName='enroute', keepSelection=True)
        print(f"   >‚úÖ FIC data saved and dropdown updated")


    def print_local_storage():
        # Get localStorage info

        print(f"   >üíæ Saved to localStorage: {storage_key}")
        print(f"   Storage Type: Browser localStorage")
        print(f"   Storage Location: Browser's IndexedDB/localStorage database")
        print(f"   Key: {storage_key}")
        print(f"   Size: {len(json_data)} bytes")

        # Print browser-specific path hints
        print(f"   Browser localStorage is typically stored at:")
        if sys.platform == 'win32':
            print(f"   - Chrome: %LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Local Storage")
            print(f"   - Firefox: %APPDATA%\\Mozilla\\Firefox\\Profiles\\<profile>\\storage\\default")
            print(f"   - Edge: %LOCALAPPDATA%\\Microsoft\\Edge\\User Data\\Default\\Local Storage")
        elif sys.platform == 'darwin':
            print(f"   - Chrome: ~/Library/Application Support/Google/Chrome/Default/Local Storage")
            print(f"   - Firefox: ~/Library/Application Support/Firefox/Profiles/<profile>/storage/default")
            print(f"   - Safari: ~/Library/Safari/LocalStorage")
        else:
            print(f"   - Chrome: ~/.config/google-chrome/Default/Local Storage")
            print(f"   - Firefox: ~/.mozilla/firefox/<profile>/storage/default")


    # ================================================
    # ATC HELPERS
    # ================================================

    async def create_summary_atc(reverse_path=False):
        """Create ATC summary (placeholder function)"""
        print("Creating ATC summary...")
        # Generate HTML content
        html_content = await generate_summary_html(reverse_path=reverse_path)
        # Open in browser
        # open_html(html_content, 'ATC_Summary_reverse' if reverse_path else 'ATC_Summary')
        open_html(html_content)

    async def create_departure_atc(reverse_path=False):
        """Create ATC Departure (placeholder function)"""
        print("Creating Departure summary...")
        # Generate HTML content
        html_content = await generate_departure_html(reverse_path=reverse_path)
        # Open in browser
        # open_html(html_content, 'ATC_Departure_reverse' if reverse_path else 'ATC_Departure')
        open_html(html_content)

    async def create_arrival_atc(reverse_path=False):
        """Create ATC Arrival (placeholder function)"""
        print("Creating Arrival summary...")
        # Generate HTML content
        html_content = await generate_arrival_html(reverse_path=reverse_path)
        # Open in browser
        # open_html(html_content, 'ATC_Arrival_reverse' if reverse_path else 'ATC_Arrival')
        open_html(html_content)

    async def create_enroute_atc(reverse_path=False):
        """Create ATC Enroute (placeholder function)"""
        print("Creating Enroute summary...")
        # Generate HTML content
        html_content = await generate_enroute_html(reverse_path=reverse_path)
        # Open in browser
        # open_html(html_content, 'ATC_Enroute_reverse' if reverse_path else 'ATC_Enroute')
        open_html(html_content)


    async def generate_summary_html(reverse_path=False):
        """Generate HTML content for summary screen similar to ATC_SUMMARY."""

        flight_data = js.window.flight_plan_data
        settings = js.window.settings

        try:
            # Set departure and arrival
            if reverse_path:
                DEPARTURE, ARRIVAL = 'ARRIVAL', 'DEPARTURE'
            else:
                DEPARTURE, ARRIVAL = 'DEPARTURE', 'ARRIVAL'

            # Prepare frequency and tower info
            ATC_FREQUENCIES = create_freq_list_combined([DEPARTURE, ARRIVAL])
            ATC_TOWER_FREQ_DEP, ATC_TOWER_NAME_DEP = get_ATC_TOWER(DEPARTURE)
            ATC_TOWER_FREQ_ARR, ATC_TOWER_NAME_ARR = get_ATC_TOWER(ARRIVAL)

            empty_field = '[ . . . . . . . . . ]'
            html_content = {
                'CALLSIGN': flight_data.get('CALLSIGN', '') or empty_field,
                'CALLSIGN_SHORT': flight_data.get('CALLSIGN_SHORT', '') or empty_field,
                'AIRCRAFT_TYPE': flight_data.get('AIRCRAFT_TYPE', '') or empty_field,
                'FLIGHT_RULES': flight_data.get('FLIGHT_RULES', '') or empty_field,
                'POB': flight_data.get('POB', '') or empty_field,

                'REQUEST_INFORMATION': '' if flight_data.get(f'{ARRIVAL}_CTR', False) else 'REQUEST AERODROME INFORMATION',
                'TEXT_INFORMATION_RECEIVED': TEXT_INFORMATION_RECEIVED() if flight_data.get(f'{ARRIVAL}_CTR', False) else '',
                'CTR_REGION_BOOL_DEPARTURE': 'true' if flight_data.get(f'{DEPARTURE}_CTR', False) else 'false',
                'CTR_REGION_BOOL_ARRIVAL': 'true' if flight_data.get(f'{ARRIVAL}_CTR', False) else 'false',

                'DEPARTURE_POSITION': flight_data.get(f'{DEPARTURE}_POSITION', '') or 'at the Apron',
                'DEPARTURE_RUNWAY': flight_data.get(f'{DEPARTURE}_RUNWAY', '') or empty_field,
                'DEPARTURE_NAME': flight_data.get(f'{DEPARTURE}_NAME', '') or empty_field,
                'DEPARTURE_ROUTE_NAME': flight_data.get(f'{DEPARTURE}_ROUTE_NAME', '') or empty_field,
                'DEPARTURE_ROUTE_ALTITUDE': flight_data.get(f'{DEPARTURE}_ROUTE_ALTITUDE', '') or empty_field,
                'DEPARTURE_ICAO': flight_data.get(f'{DEPARTURE}_ICAO', '') or empty_field,

                'FIC_NAME': flight_data.get('FIC_NAME', '') or empty_field,
                'FIC_FREQUENCY': flight_data.get('FIC_FREQUENCY', ''),
                'FIC_SQUAWK': flight_data.get('SQUAWK', ''),
                'OVERHEAD': flight_data.get('OVERHEAD', flight_data.get(f'{DEPARTURE}_ROUTE_NAME', '') or empty_field),
                'ATC_FREQUENCIES': ATC_FREQUENCIES,
                'ATC_ATIS_FREQ_DEP': flight_data.get(f'{DEPARTURE}_ATC_ATIS_FREQ', ''),
                'OVERHEAD2': flight_data.get('OVERHEAD2', ''),
                'FIC_SQUAWK2': flight_data.get('SQUAWK2', ''),

                'ATC_TOWER': ATC_TOWER_FREQ_DEP,
                'DELIVERY_OR_RADIO': ATC_TOWER_NAME_DEP if ATC_TOWER_NAME_DEP == 'RADIO' else 'DELIVERY',
                'ATC_GROUND': ATC_TOWER_FREQ_DEP if ATC_TOWER_NAME_DEP == 'RADIO' else flight_data.get(f'{DEPARTURE}_ATC_GROUND', ''),

                'ARRIVAL_ICAO': flight_data.get(f'{ARRIVAL}_ICAO', '') or empty_field,
                'ARRIVAL_ROUTE_ALTITUDE': flight_data.get(f'{ARRIVAL}_ROUTE_ALTITUDE', '') or empty_field,
                'ARRIVAL_NAME': flight_data.get(f'{ARRIVAL}_NAME', '') or empty_field,
                'ARRIVAL_ROUTE_NAME': flight_data.get(f'{ARRIVAL}_ROUTE_NAME', ''),
                'ATC_TOWER_ARR': ATC_TOWER_FREQ_ARR,
                'ATC_TOWER_NAME': ATC_TOWER_NAME_ARR,
                'ARRIVAL_RUNWAY': flight_data.get(f'{ARRIVAL}_RUNWAY', '') or empty_field,

                'GRID_COLUMNS': settings.get('atc_columns', 1),
            }
            if reverse_path:
                html_content['FIC_NAME'] = flight_data.get('FIC_NAME2', '') or empty_field
                html_content['FIC_FREQUENCY'] = flight_data.get('FIC_FREQUENCY2', '')
                html_content['OVERHEAD'] = flight_data.get('OVERHEAD2', '')
                html_content['FIC_SQUAWK'] = flight_data.get('SQUAWK2', '')

            fontsizes = settings.get('fontsizes')

            css_content = {
                'FONT_SIZE_TOWER': fontsizes.get('TOWER'),
                'FONT_SIZE_PILOT': fontsizes.get('PILOT'),
                'FONT_SIZE_TITLE': fontsizes.get('TITLE'),
                'FONT_SIZE_SUBTITLE': fontsizes.get('TITLE') - 2,
                'BACKGROUND_COLOR_TITLE': '#6b21a8',
            }
            html_string = await personalize_content(html_content, 'ATC_summary_template.html.j2')
            css_string = await personalize_content(css_content, 'style_template.css.j2')

            html_with_css = f"""
            <style>
            {css_string}
            </style>
            {html_string}
            """
            return html_with_css
        except Exception as e:
            return f"<p>Error generating Summary HTML: {str(e)}</p>"


    async def generate_departure_html(reverse_path=False):
        """Generate HTML content for departure screen similar to ATC_DEPARTURE. """

        flight_data = js.window.flight_plan_data
        settings = js.window.settings

        try:
            # Set departure and arrival
            if reverse_path:
                DEPARTURE, ARRIVAL = 'ARRIVAL', 'DEPARTURE'
            else:
                DEPARTURE, ARRIVAL = 'DEPARTURE', 'ARRIVAL'

            # Create string of all Frequencies
            ATC_FREQUENCIES = create_freq_list_combined(DEPARTURE)
            ATC_TOWER_FREQ, ATC_TOWER_NAME = get_ATC_TOWER(DEPARTURE)

            # Prepare HTML content data
            empty_field = '[ . . . . . . . . . ]'
            html_content = {
                'CALLSIGN': flight_data.get('CALLSIGN', '') or empty_field,
                'CALLSIGN_SHORT': flight_data.get('CALLSIGN_SHORT', '') or empty_field,
                'AIRCRAFT_TYPE': flight_data.get('AIRCRAFT_TYPE', '') or empty_field,
                'FLIGHT_RULES': flight_data.get('FLIGHT_RULES', ''),
                'POB': flight_data.get('POB', '') or empty_field,

                'ARRIVAL_NAME': flight_data.get(f'{ARRIVAL}_NAME', '') or empty_field,
                'ARRIVAL_RUNWAY': flight_data.get(f'{ARRIVAL}_RUNWAY', '') or empty_field,
                'ARRIVAL_ROUTE_ALTITUDE': str(flight_data.get(f'{ARRIVAL}_ROUTE_ALTITUDE', '')) or empty_field,
                'ARRIVAL_ICAO': flight_data.get(f'{ARRIVAL}_ICAO', '') or empty_field,

                'CTR_REGION_BOOL': 'true' if flight_data.get(f'{DEPARTURE}_CTR', False) else 'false',
                'DEPARTURE_POSITION': flight_data.get(f'{DEPARTURE}_POSITION', '') or 'at the Apron',
                'DEPARTURE_RUNWAY': flight_data.get(f'{DEPARTURE}_RUNWAY', '') or empty_field,
                'DEPARTURE_NAME': flight_data.get(f'{DEPARTURE}_NAME', '') or empty_field,
                'DEPARTURE_ROUTE_NAME': flight_data.get(f'{DEPARTURE}_ROUTE_NAME', '') or empty_field,
                'DEPARTURE_ROUTE_ALTITUDE': flight_data.get(f'{DEPARTURE}_ROUTE_ALTITUDE', '') or empty_field,
                'DEPARTURE_CITY_ICAO': flight_data.get(f'{DEPARTURE}_NAME', '') or empty_field,
                'DEPARTURE_ICAO': flight_data.get(f'{DEPARTURE}_ICAO', '') or empty_field,

                'ATC_TOWER': ATC_TOWER_FREQ,
                'ATC_ATIS_FREQ_DEP': flight_data.get(f'{DEPARTURE}_ATC_ATIS_FREQ', ''),
                'DELIVERY_OR_RADIO': ATC_TOWER_NAME if ATC_TOWER_NAME == 'RADIO' else 'DELIVERY',
                'ATC_GROUND': ATC_TOWER_FREQ if ATC_TOWER_NAME == 'RADIO' else flight_data.get(f'{DEPARTURE}_ATC_GROUND', ''),
                'ATC_FREQUENCIES': ATC_FREQUENCIES,

                'GRID_COLUMNS': settings.get('atc_columns', 1),
            }

            # Prepare CSS content
            fontsizes = settings.get('fontsizes')
            css_content = {
                'FONT_SIZE_TOWER': fontsizes.get('TOWER'),
                'FONT_SIZE_PILOT': fontsizes.get('PILOT'),
                'FONT_SIZE_TITLE': fontsizes.get('TITLE'),
                'FONT_SIZE_SUBTITLE': fontsizes.get('TITLE') - 2,
                'BACKGROUND_COLOR_TITLE': '#4769b1',
            }

            html_string = await personalize_content(html_content, 'ATC_departure_template.html.j2')
            css_string = await personalize_content(css_content, 'style_template.css.j2')

            # Embed CSS in the HTML content
            html_with_css = f"""
            <style>
            {css_string}
            </style>
            {html_string}
            """

            return html_with_css

        except Exception as e:
            return f"<p>Error generating Deparature HTML: {str(e)}</p>"


    async def generate_arrival_html(reverse_path=False):
        """Generate HTML content for arrivak screen similar to ATC_ARRIVAL."""

        flight_data = js.window.flight_plan_data
        settings = js.window.settings

        try:
            # Set departure and arrival
            if reverse_path:
                DEPARTURE, ARRIVAL = 'ARRIVAL', 'DEPARTURE'
            else:
                DEPARTURE, ARRIVAL = 'DEPARTURE', 'ARRIVAL'

            # Create string of all Frequencies
            ATC_FREQUENCIES = create_freq_list_combined(ARRIVAL)
            ATC_TOWER_FREQ, ATC_TOWER_NAME = get_ATC_TOWER(ARRIVAL)

            # Set the content to customize the html
            empty_field = '[ . . . . . . . . . ]'
            html_content = {
                'AIRCRAFT_TYPE': flight_data.get('AIRCRAFT_TYPE', '') or empty_field,
                'CALLSIGN': flight_data.get('CALLSIGN', '') or empty_field,
                'CALLSIGN_SHORT': flight_data.get('CALLSIGN_SHORT', '') or empty_field,
                'FLIGHT_RULES': flight_data.get('FLIGHT_RULES', '') or empty_field,
                'CIRCUIT_ALTITUDE': flight_data.get('CIRCUIT_ALTITUDE', '') or empty_field,
                'ARRIVAL_CITY_ICAO': flight_data.get(f'{ARRIVAL}_ICAO', '') or empty_field,
                'POB': flight_data.get('POB', '') or empty_field,

                'ARRIVAL_NAME': flight_data.get(f'{ARRIVAL}_NAME', '') or empty_field,
                'ARRIVAL_RUNWAY': flight_data.get(f'{ARRIVAL}_RUNWAY', '') or empty_field,
                'ARRIVAL_ROUTE_NAME': flight_data.get(f'{ARRIVAL}_ROUTE_NAME', '') or empty_field,
                'ARRIVAL_ROUTE_ALTITUDE': flight_data.get(f'{ARRIVAL}_ROUTE_ALTITUDE', '') or empty_field,

                'DEPARTURE_ICAO': flight_data.get(f'{DEPARTURE}_ICAO', '') or empty_field,
                'ARRIVAL_ICAO': flight_data.get(f'{ARRIVAL}_ICAO', '') or empty_field,

                'REQUEST_INFORMATION': '' if flight_data.get(f'{ARRIVAL}_CTR', False) else 'REQUEST AERODROME INFORMATION',
                'TEXT_INFORMATION_RECEIVED': TEXT_INFORMATION_RECEIVED() if flight_data.get(f'{ARRIVAL}_CTR', False) else '',

                'ATC_TOWER_NAME': ATC_TOWER_NAME,
                'ATC_TOWER': ATC_TOWER_FREQ,
                'ATC_FREQUENCIES': ATC_FREQUENCIES,
                'GRID_COLUMNS': settings.get('atc_columns', 1),
            }

            # Prepare CSS content
            fontsizes = settings.get('fontsizes')
            css_content = {
                'FONT_SIZE_TOWER': fontsizes.get('TOWER'),
                'FONT_SIZE_PILOT': fontsizes.get('PILOT'),
                'FONT_SIZE_TITLE': fontsizes.get('TITLE'),
                'FONT_SIZE_SUBTITLE': fontsizes.get('TITLE') - 2,
                'BACKGROUND_COLOR_TITLE': '#258f45',
            }

            # Personalize the html based on the departure and aircraft
            html_string = await personalize_content(html_content, 'ATC_arrival_template.html.j2')
            css_string = await personalize_content(css_content, 'style_template.css.j2')

            # Embed CSS in the HTML content
            html_with_css = f"""
            <style>
            {css_string}
            </style>
            {html_string}
            """

            return html_with_css

        except Exception as e:
            return f"<p>Error generating HTML: {str(e)}</p>"


    async def generate_enroute_html(reverse_path=False):
        """Generate HTML content for enroute screen similar to ATC_ENROUTE."""

        flight_data = js.window.flight_plan_data
        settings = js.window.settings

        try:
            # Set departure and arrival
            if reverse_path:
                DEPARTURE, ARRIVAL = 'ARRIVAL', 'DEPARTURE'
            else:
                DEPARTURE, ARRIVAL = 'DEPARTURE', 'ARRIVAL'

            # Prepare HTML content data (adjust keys as needed)
            empty_field = '[ . . . . . . . . . ]'
            html_content = {
                'AIRCRAFT_TYPE': flight_data.get('AIRCRAFT_TYPE', '') or empty_field,
                'CALLSIGN': flight_data.get('CALLSIGN', '') or empty_field,
                'CALLSIGN_SHORT': flight_data.get('CALLSIGN_SHORT', '') or empty_field,

                'FIC_NAME': flight_data.get('FIC_NAME', '') or empty_field,
                'FIC_FREQUENCY': flight_data.get('FIC_FREQUENCY', ''),
                'FIC_SQUAWK': flight_data.get('SQUAWK', ''),
                'FIC_SQUAWK2': flight_data.get('SQUAWK2', ''),

                'OVERHEAD': flight_data.get('OVERHEAD', flight_data.get(f'{DEPARTURE}_ROUTE_NAME', '') or empty_field),
                'OVERHEAD2': flight_data.get('OVERHEAD2', '') or empty_field,
                'FLIGHT_RULES': flight_data.get('FLIGHT_RULES', ''),
                'POB': flight_data.get('POB', '') or empty_field,

                'DEPARTURE_ICAO': flight_data.get(f'{DEPARTURE}_ICAO', '') or empty_field,
                'DEPARTURE_NAME': flight_data.get(f'{DEPARTURE}_NAME', '') or empty_field,
                'DEPARTURE_ROUTE_ALTITUDE': flight_data.get(f'{DEPARTURE}_ROUTE_ALTITUDE', '') or empty_field,

                'ARRIVAL_ICAO': flight_data.get(f'{ARRIVAL}_ICAO', '') or empty_field,
                'ARRIVAL_NAME': flight_data.get(f'{ARRIVAL}_NAME', '') or empty_field,
                'ATC_FREQUENCIES': create_freq_list_combined([DEPARTURE, ARRIVAL]),
                'GRID_COLUMNS': settings.get('atc_columns', 1),
            }

            if reverse_path:
                html_content['FIC_NAME'] = flight_data.get('FIC_NAME2', '') or empty_field
                html_content['FIC_FREQUENCY'] = flight_data.get('FIC_FREQUENCY2', '')
                html_content['OVERHEAD'] = flight_data.get('OVERHEAD2', '')
                html_content['FIC_SQUAWK'] = flight_data.get('SQUAWK2', '')

            fontsizes = settings.get('fontsizes')
            css_content = {
                'FONT_SIZE_TOWER': fontsizes.get('TOWER'),
                'FONT_SIZE_PILOT': fontsizes.get('PILOT'),
                'FONT_SIZE_TITLE': fontsizes.get('TITLE'),
                'FONT_SIZE_SUBTITLE': fontsizes.get('TITLE') - 2,
                'BACKGROUND_COLOR_TITLE': '#ec7d15',
            }
            html_string = await personalize_content(html_content, 'ATC_enroute_template.html.j2')
            css_string = await personalize_content(css_content, 'style_template.css.j2')
            html_with_css = f"""
            <style>
            {css_string}
            </style>
            {html_string}
            """
            return html_with_css
        except Exception as e:
            return f"<p>Error generating HTML: {str(e)}</p>"


    def get_ATC_TOWER(fname):
        """Get ATC tower frequency and name for DEPARTURE or ARRIVAL from flight_plan_data."""
        data = js.window.flight_plan_data

        if fname=='DEPARTURE':
            ATC_TOWER_FREQ = data.get('DEPARTURE_ATC_TOWER', '')
            ATC_TOWER_FREQ = ATC_TOWER_FREQ if ATC_TOWER_FREQ not in (None, '') else '???.???'
            ATC_TOWER_NAME = 'TOWER' if data.get('DEPARTURE_CTR') else 'RADIO'
        elif fname=='ARRIVAL':
            ATC_TOWER_FREQ = data.get('ARRIVAL_ATC_TOWER', '')
            ATC_TOWER_FREQ = ATC_TOWER_FREQ if ATC_TOWER_FREQ not in (None, '') else '???.???'
            ATC_TOWER_NAME = 'TOWER' if data.get('ARRIVAL_CTR') else 'RADIO'

        return ATC_TOWER_FREQ, ATC_TOWER_NAME


    def set_fontsizes(atc_fontsize):
        # Change fontsize based on settings
        if 'small'==atc_fontsize.lower():
            fontsizes = {'TOWER': 12, 'PILOT': 14, 'TITLE': 14}
        elif 'medium'==atc_fontsize.lower():
            fontsizes = {'TOWER': 14, 'PILOT': 16, 'TITLE': 20}
        elif 'large'==atc_fontsize.lower():
            fontsizes = {'TOWER': 16, 'PILOT': 18, 'TITLE': 20}
        elif 'xl'==atc_fontsize.lower():
            fontsizes = {'TOWER': 18, 'PILOT': 20, 'TITLE': 22}
        elif 'xxl'==atc_fontsize.lower():
            fontsizes = {'TOWER': 20, 'PILOT': 22, 'TITLE': 24}

        return fontsizes


    async def load_template_from_url(template_name):
        """Fetch from URL, store in localStorage, and return text content."""
        template_key = f"template_{template_name}"
        base_url = js.window.settings['html_templates']
        url = os.path.join(base_url, template_name)

        #response =  await fetch_and_cache_template(url, template_key)
        # 1. Try cache
        cached = js.localStorage.getItem(template_key)
        if cached:
            print("‚úÖ Loaded from cache")
            return cached

        # 2. Fetch template using JS fetch
        print(f"üåê Fetching from URL: {url}")

        try:
            response = await js.fetch(url)
            if response.ok:
                content = await response.text()  # get the text content
                js.localStorage.setItem(template_key, content)  # store content
                print(f"‚úÖ Template cached under key '{template_key}'")
                return content
            else:
                print(f"‚ùå Fetch failed: {response.status}")
                return None
        except Exception as e:
            print(f"‚ùå Error fetching template: {e}")
            return None


    async def personalize_content(content, template_name):
        # Load template
        template_content = await load_template_from_url(template_name)

        # Use DictLoader to store template
        jinja_env = Environment(loader=DictLoader({template_name: template_content}))

        try:
            template = jinja_env.get_template(template_name)
            html_content = template.render(content)
            return html_content
        except Exception as e:
            return f"<p>Error generating HTML: {e}</p>"


    def open_html(html_content, pagename="_blank"):
        print('> func: open_html(html_content)')
        if html_content is None:
            return None

        # Inject viewport for mobile if not present
        if "<head>" in html_content and 'name="viewport"' not in html_content:
            html_content = html_content.replace(
                "<head>",
                '<head><meta name="viewport" content="width=device-width, initial-scale=1.0">'
            )
        elif "<head>" not in html_content:
            html_content = (
                '<meta name="viewport" content="width=device-width, initial-scale=1.0">'
                + html_content
            )

        # new_win = window.open("", "_blank")
        new_win = window.open("", pagename)
        if not new_win:
            # blocked
            window.alert("‚ö†Ô∏è Popup blocked. Please allow popups to view the ATC communication.")
            return
        new_win.document.write(html_content)
        new_win.document.close()

    # %%
    def create_freq_list_combined(fname):
        """Create ATC frequency list for both DEPARTURE and ARRIVAL using flight_plan_data."""
        if isinstance(fname, str): fname = [fname]

        data = js.window.flight_plan_data
        settings = js.window.settings
        html_string = ''

        def freq_block(freq, label, city):
            if freq:
                return f'''
                <div style="display: grid; grid-template-columns: 1.5fr 3.5fr;">
                    <p class="pilot_general"><strong>{freq}: </strong></p>
                    <p class="pilot_general">{city} {label}</p>
                </div>
                '''
            return ''

        # DEPARTURE frequencies
        if 'DEPARTURE' in fname:
            dep_city = data.get('DEPARTURE_NAME', '')
            html_string += freq_block(data.get('DEPARTURE_ATC_ATIS_FREQ', ''), 'ATIS', dep_city)
            html_string += freq_block(data.get('DEPARTURE_ATC_GROUND', ''), 'DELIVERY/GROUND', dep_city)
            html_string += freq_block(data.get('DEPARTURE_ATC_TOWER', ''), 'TOWER', dep_city)
            html_string += freq_block(data.get('DEPARTURE_ATC_APPROACH', ''), 'APPROACH', dep_city)
            html_string += freq_block(data.get('DEPARTURE_ATC_TELEPHONE', ''), 'TELEPHONE', dep_city)
            #html_string += freq_block(data.get('DELIVERY_OR_RADIO', ''), 'RADIO', dep_city)

        # Add a horizontal rule between departure and arrival
        if len(fname)>=2:
            html_string += '<hr>'

        # ARRIVAL frequencies
        if 'ARRIVAL' in fname:
            arr_city = data.get('ARRIVAL_NAME', '')
            html_string += freq_block(data.get('ARRIVAL_ATC_ATIS_FREQ', ''), 'ATIS', arr_city)
            html_string += freq_block(data.get('ARRIVAL_ATC_GROUND', ''), 'DELIVERY/GROUND', arr_city)
            html_string += freq_block(data.get('ARRIVAL_ATC_TOWER', ''), 'TOWER', arr_city)
            html_string += freq_block(data.get('ARRIVAL_ATC_APPROACH', ''), 'APPROACH', arr_city)
            html_string += freq_block(data.get('ARRIVAL_ATC_TELEPHONE', ''), 'TELEPHONE', arr_city)
            #html_string += freq_block(data.get('DELIVERY_OR_RADIO_ARR', ''), 'RADIO', arr_city)

        html_string += '<hr>'
        SQUAWK = f": {data.get('SQUAWK', '')}" if data.get('SQUAWK', '') else ''
        SQUAWK2 = f": {data.get('SQUAWK2', '')}" if data.get('SQUAWK2', '') else ''
        html_string += freq_block(data.get('FIC_FREQUENCY', '') , data.get('FIC_NAME', '') + SQUAWK, '')
        html_string += freq_block(data.get('FIC_FREQUENCY2', '') , data.get('FIC_NAME2', '') + SQUAWK2, '')

        return html_string

    # =================================================================
    # HELPERS FOR AIRSPACE PROCESSING
    # =================================================================

    def read_file_from_url(url, verbose=3):
        """Read a text file from a given URL and load it into memory.

        Parameters:
        url (str): URL to the zip file containing the text file.
        url = f'https://erdogant.github.io/datasets/skywalk/areas/Netherlands.zip'

        Returns:
        str: Content of the text file as a string.
        """
        if verbose>=3: print('>Function: read_file_from_url()')
        lines_in_file = []

        if url == '': return None

        try:
            # Get url
            response = requests.get(url)
            if response.status_code == 200 or response.status_code == 502:
                # Open content in memory
                zfs = zipfile.ZipFile(BytesIO(response.content))
                # Assuming there's only one text file in the zip archive
                with zfs.open(zfs.infolist()[0], mode='r') as file:
                    for line in file:
                        # Decode each line from bytes to string, strip whitespace
                        processed_line = line.decode('utf-8').strip()
                        # Process the line as needed (e.g., further parsing or validation)
                        lines_in_file.append(processed_line)

                    # Show succes message
                    logger.info(f'   > File read and processed successfully from URL.')
            else:
                lines_in_file = None
        except Exception as e:
            if verbose>=1: print(f'[Error]> Failed to read file from URL: {str(e)}')
            lines_in_file = None

        # Return
        return lines_in_file


    def import_airspaces(country):
        # URL
        url = f'https://erdogant.github.io/datasets/skywalk/airspaces/{country}.zip'
        #url = f'{js.window.settings['url_airspaces']}{country}.zip'

        # Read airspace file from URL
        lines_in_file = read_file_from_url(url, verbose=3)

        # Return if nothing is available
        if lines_in_file is None:
            return {}

        airspaces = {}
        current_airspace = None
        counter = 0

        for line in lines_in_file:
            line = line.strip()

            if ('Start of airspace' in line) or len(line) < 3:
                # Skip each line until start of airsprace is found
                if counter == 0: counter = counter + 1
                # print(line)

            elif line.startswith('*'):
                # This is a new area so create new key
                # line ='* Danger Area/DANGER//O/C'
                counter += 1
                airspaces[counter] = {'area_type': '', 'area_type_general': '', 'AC': '', 'AN': '', 'AL': '', 'AH': '', 'DP': '', 'coordinates': None}
                airspaces[counter]['area_type'] = line.split(maxsplit=1)[1]
                line = line[1:].split('/', maxsplit=1)
                airspaces[counter]['area_type_general'] = line[0].strip()
            elif line.startswith('AC'):
                airspaces[counter]['type'] = line.split()[1]
            elif line.startswith('AN'):
                airspaces[counter]['name'] = line.split(maxsplit=1)[1]
            elif line.startswith('AL'):
                airspaces[counter]['altitude_lower'] = line.split()[1]
            elif line.startswith('AH'):
                airspaces[counter]['altitude_higher'] = line.split()[1]
            elif line.startswith('DP'):
                # Get the coordinates
                if airspaces[counter].get('coordinates') is None:
                    airspaces[counter]['coordinates'] = []
                lat_lon = line.split(maxsplit=1)[1:]
                lat_lon = extract_lat_lon(lat_lon)
                # Remove None values from latlon
                if lat_lon['latlon'] is not None:
                    lat_lon = [item for item in lat_lon['latlon'] if item is not None]
                    # Store
                    if len(lat_lon) > 0:
                        airspaces[counter]['coordinates'].append(lat_lon)

            elif line.startswith('V'):
                if not airspaces[counter].get('coordinates'):
                    airspaces[counter]['coordinates'] = []

                lat_lon = line.split('X=')[1:]
                lat_lon = extract_lat_lon(lat_lon)

                # Remove None values from latlon
                if lat_lon['latlon'] is not None:
                    lat_lon = [item for item in lat_lon['latlon'] if item is not None]
                    # Store
                    if len(lat_lon) > 0:
                        airspaces[counter]['coordinates'].append(lat_lon)

        # Only keep airspaces with coordinates
        airspaces = {key: value for key, value in airspaces.items() if value['coordinates'] is not None}

        # Sort airspaces by number of latlon coordinates
        # airspaces = dict(sorted(airspaces.items(), key=lambda x: len(x[1]['coordinates']), reverse=True))

        # Combine multiple airspace entries that contain the given keyword in their name
        # if country == 'Netherlands':
        #    airspaces = combine_airspace_by_keyword(airspaces, 'schiphol ctr')

        # Convert the dictionary to a JSON string
        # airspaces_json = json.dumps(airspaces, indent=4)
        return airspaces


    def combine_airspace_by_keyword(airspaces, keyword):
        """Combine multiple airspace entries that contain the given keyword in their name.

        Args:
            airspaces (dict): Dictionary of airspace data
            keyword (str): Keyword to search for in airspace names (case insensitive)

        Returns:
            dict: Updated airspaces dictionary with combined entries
        """
        matching_keys = []
        combined_coords = []

        # Find all keys containing the keyword
        for key, value in airspaces.items():
            if 'name' in value and keyword.lower() in value['name'].lower():
                matching_keys.append(key)
                if value.get('coordinates'):
                    combined_coords.extend(value['coordinates'])

        # If we found multiple matching entries, combine them
        if len(matching_keys) > 1:
            # Keep the first key and update its coordinates
            main_key = matching_keys[0]
            airspaces[main_key]['coordinates'] = combined_coords

            # Remove other matching entries
            for key in matching_keys[1:]:
                airspaces.pop(key, None)

            print(f"‚úÖ Combined {len(matching_keys)} entries containing '{keyword}' into single entry")

        return airspaces


    # Function to extract latitude and longitude from the string
    def extract_lat_lon(string, method=None):
        # string = "52¬∞ 28' 12.00\" N"
        # string = '52:11:08 N 005:12:30 E'
        # string = 'n52 18.84 / e4 48.18'
        # latlon = extract_lat_lon('52:11:08 N 005:12:30 E')
        # latlon = extract_lat_lon('n52 18.84 / e4 48.18')

        if method == 4:
            if len(string.split('/')) > 1:
                s = string.split('/')
                if 'n' in s[0].strip().lower() or 's' in s[0].strip().lower():
                    lat = s[0].strip().replace(' ', ':').replace('.', ':')
                    lat = lat[1:] + ' ' + lat[0].upper()
                if 'e' in s[1].strip().lower() or 'w' in s[1].strip().lower():
                    lon = s[1].strip().replace(' ', ':').replace('.', ':')
                    lon = lon[1:] + ' ' + lon[0].upper()
                string = lat + ' ' + lon


        coord = {'name': None, 'latlon': None}

        if string is None or string == '' or string == []:
            return coord

        if isinstance(string, list): string = string[0]

        # Pattern 1: Extract the desired part of the string
        pattern1 = r"\d+¬∞\d+'\d+\.\d+\"[NS]\s+\d+¬∞\d+'\d+\.\d+\"[EW]"
        matches1 = re.findall(pattern1, string)

        if matches1:
            # Extract name
            start_index = string.index(matches1[0])
            # end_index = string.rindex(matches1[-1]) + len(matches1[-1])
            coord['name'] = string[0:start_index].replace('\xa0', ' ').strip()
            latlon = matches1

            lat_decimal, lon_decimal = [], []
            for lat_lon in latlon:
                # Extract degrees, minutes, and seconds for latitude
                lat_parts = re.findall(r'\d+', lat_lon.split()[0])
                lat_deg = float(lat_parts[0])
                lat_min = float(lat_parts[1])
                lat_sec = float(lat_parts[2] + '.' + lat_parts[3])

                # Extract degrees, minutes, and seconds for longitude
                lon_parts = re.findall(r'\d+', lat_lon.split()[1])
                lon_deg = float(lon_parts[0])
                lon_min = float(lon_parts[1])
                lon_sec = float(lon_parts[2] + '.' + lon_parts[3])

                # Convert DMS to decimal degrees
                lat_dec = dms_to_decimal(lat_deg, lat_min, lat_sec)
                lon_dec = dms_to_decimal(lon_deg, lon_min, lon_sec)

                lat_decimal.append(lat_dec)
                lon_decimal.append(lon_dec)

            coord['latlon'] = np.c_[lat_decimal, lon_decimal]
            if coord['latlon'].shape[0] > 1 and coord['name']=='':
                coord['name']='unknown'

            # Return
            return coord

        # latlon Pattern 2
        pattern2 = r'(\d{6}[NS])\s+(\d{7}[EW])'
        matches2 = re.findall(pattern2, string)

        if matches2:
            lat_decimal, lon_decimal = [], []
            for lat, lon in matches2:
                lat_deg, lat_min, lat_sec = lat[:2], lat[2:4], lat[4:-1]
                lon_deg, lon_min, lon_sec = lon[:3], lon[3:5], lon[5:-1]
                lat_dec = dms_to_decimal(lat_deg, lat_min, lat_sec)
                lon_dec = dms_to_decimal(lon_deg, lon_min, lon_sec)

                if lat[-1] == 'S':
                    lat_dec *= -1
                if lon[-1] == 'W':
                    lon_dec *= -1

                lat_decimal.append(lat_dec)
                lon_decimal.append(lon_dec)

            start_index = string.index(matches2[0][0])
            coord['name'] = string[0:start_index].replace('\xa0', ' ').strip()
            coord['latlon'] = np.c_[lat_decimal, lon_decimal]
            if coord['latlon'].shape[0] > 1 and coord['name']=='':
                coord['name']='unknown'

            # Return
            return coord

        # latlon Pattern 3
        # string = "52¬∞ 28' 12.00\" N"
        pattern3 = r'(\d+)¬∞ (\d+)\' (\d+\.\d+)" ([NSEW])'
        matches3 = re.search(pattern3, string)

        if matches3:
            ldeg = float(matches3.group(1))
            lmin = float(matches3.group(2))
            lsec = float(matches3.group(3))

            # Convert DMS to decimal degrees
            ldec = dms_to_decimal(ldeg, lmin, lsec)

            if matches3.group(4) == 'S':
                ldec *= -1
            if matches3.group(4) == 'W':
                ldec *= -1

            coord = {'name': string, 'latlon': ldec}
            # Return
            return coord

        # latlon Pattern 4
        # '52:11:08 N 005:12:30 E'
        pattern = r'(\d+:\d+:\d+) ([NS]) (\d+:\d+:\d+) ([EW])'
        matches = re.search(pattern, string)
        if matches:
            # Conert latitude to decimals
            degrees, minutes, seconds = matches.group(1).split(':')
            lat_decimal = dms_to_decimal(degrees, minutes, seconds, matches.group(2))
            # Conert longitude to decimals
            degrees, minutes, seconds = matches.group(3).split(':')
            lon_decimal = dms_to_decimal(degrees, minutes, seconds, matches.group(4))
            # Create coordinates
            coord = {'name': matches.group(1) + ' ' + matches.group(2) + ' ' + matches.group(3) + ' ' + matches.group(4) , 'latlon':  [lat_decimal, lon_decimal]}
            # Return
            return coord


        # latlon Pattern 5
        # string = "5342N00629E002"
        # string = '5255N00454E001'
        pattern = r'(\d{2})(\d{2})([NS])(\d{3})(\d{2})([EW])\d{3}'
        # 51.44161977603219, 3.5849333938063817
        match = re.search(pattern, string)
        if match:
            # Extract degrees, minutes, and seconds for latitude and longitude
            lat_degrees = int(match.group(1))
            lat_minutes = int(match.group(2))
            lat_direction = match.group(3)
            # lat_decimal = lat_degrees + (lat_minutes/100)
            # if lat_direction == 'S': lat_decimal *= -1

            lon_degrees = int(match.group(4))
            lon_minutes = int(match.group(5))
            lon_direction = match.group(6)
            # lon_decimal = lon_degrees + (lon_minutes/100)
            # if lon_direction == 'W': lon_decimal *= -1

            # Convert degrees and minutes to decimal
            lat_decimal = dms_to_decimal(lat_degrees, lat_minutes, 0, direction=lat_direction)
            lon_decimal = dms_to_decimal(lon_degrees, lon_minutes, 0, direction=lon_direction)

            # Create dict.
            coord = {'name': match.group(1) + ' ' + match.group(2) + ' ' + match.group(4) + ' ' + match.group(5) , 'latlon': [lat_decimal, lon_decimal]}

            # Return
            return coord


    def dms_to_decimal(degrees, minutes, seconds, direction=None):
        dec = float(degrees) + (float(minutes) / 60) + (float(seconds) / 3600)
        if direction == 'S':
            dec *= -1
        if direction == 'W':
            dec *= -1
        return dec


    def clean_altitude(altitude):
        # print(altitude)
        altitude = str(altitude).upper().replace("`",'').strip()
        altitude = altitude.split('/')[-1]

        if altitude is None or altitude=='' or altitude == 'NONE':
            pass
        elif 'AFL' in altitude:
            # likely stands for "500 feet Above Field Level.
            altitude = altitude.replace('AFL','')
        elif 'ALT' in altitude:
            altitude = altitude.replace('ALT','')
        elif 'AGL' in altitude:
            altitude = altitude.replace('AGL','')
        elif 'MSL' in altitude:
            altitude = altitude.replace('MSL','')
        elif 'UNL' in altitude:
            # unlimited, to the sky
            altitude = None
        elif 'SFC' in altitude:
            # surface is from the floor
            altitude = None
        elif 'FT' in altitude:
            altitude = altitude.replace('FT','')
        elif altitude[0:2] == 'FL':
            altitude = altitude.replace('FL','')
            if altitude == '': altitude = 0
            altitude = int(altitude) * 100
        elif 'FO' in altitude:
            altitude = altitude.replace('FO','')
            if altitude == '': altitude = 0
            altitude = int(altitude) * 100
        elif altitude[-1] == 'M':
            altitude = int(altitude[:-1]) * 3.28084
        elif altitude[-1] == 'A':
            # above ground level, it means an altitude of 500 feet above the terrain or surface beneath the aircraft.
            altitude = int(altitude[:-1])
        elif altitude[-1] == 'F':
            altitude = altitude.replace('F','')

        if altitude == '' or altitude is None or altitude == 'NONE':
            altitude = None
        else:
            altitude = int(altitude)

        return altitude


    def altitude_restriction(AL, AH, max_altitude):
        # If the altitude is 0. Always return True
        if max_altitude == 0:
            return True, None

        in_airspace = False
        loc_airspace = ''

        # Set the altitude
        if AH is None and AL is None:
            # print("Both upper and lower limits of the airspace are not defined.")
            loc_airspace = None

        if AH is not None and AL is not None:
            if AL <= max_altitude <= AH:
                in_airspace = True
                loc_airspace = 'in'
            elif max_altitude < AL:
                loc_airspace = 'below'
            elif max_altitude > AH:
                loc_airspace = 'above'
        elif AH is None and AL is not None:
            if max_altitude >= AL:
                loc_airspace = 'in'
                in_airspace = True
            else:
                loc_airspace = 'below'
        elif AH is not None and AL is None:
            if max_altitude <= AH:
                loc_airspace = 'in'
                in_airspace = True
            else:
                loc_airspace = 'above'

        # if loc_airspace == 'in':
        #     print('Flight is in airspace')
        return in_airspace, loc_airspace



    # =================================================================
    # PYTHON TO JAVASCRIPT PORTAL
    # =================================================================

    js.window.create_new_flightplan = create_new_flightplan
    js.window.load_flightplan = load_flightplan
    js.window.delete_flightplan = delete_flightplan
    js.window.save_flightplan = save_flightplan

    js.window.load_enroute_fic = load_enroute_fic
    js.window.delete_item_from_spinner = delete_item_from_spinner
    js.window.save_enroute_to_json = save_enroute_to_json

    js.window.save_aerodrome_to_json = save_aerodrome_to_json
    js.window.load_aerodrome_from_json = load_aerodrome_from_json

    js.window.clear_cache = clear_cache
    js.window.get_top_metar_stations = get_top_metar_stations

    js.window.update_dropdown = update_dropdown

    # CHECKLIST
    js.window.checklist_clean = checklist_clean
    js.window.save_checklist_to_json = save_checklist_to_json
    js.window.check_items_complete = check_items_complete
    js.window.checklist_print = checklist_print
    js.window.checklist_populate = checklist_populate
    js.window.get_default_checklist = get_default_checklist
    js.window.load_spinner_selection = load_spinner_selection
    js.window.checklist_update_catagories = checklist_update_catagories


    # FLAG
    # js.window.retrieve_flag = retrieve_flag
    # js.window.updateFlag = updateFlag;


    # ATC
    js.window.create_summary_atc = create_proxy(create_summary_atc)
    js.window.create_departure_atc = create_proxy(create_departure_atc)
    js.window.create_arrival_atc = create_proxy(create_arrival_atc)
    js.window.create_enroute_atc = create_proxy(create_enroute_atc)

    # HELPERS
    js.window.create_callsign_short = create_proxy(create_callsign_short)
    js.window.import_country_selected = create_proxy(import_country_selected)
    js.window.generate_summary_html = create_proxy(generate_summary_html)
    js.window.set_fontsizes = create_proxy(set_fontsizes)

    # GENERAL TAB
    js.window.clear_general_fields = clear_general_fields

    # DEPARTURE/ARRIVAL TAB
    js.window.populate_aerodrome_fields_from_icao = create_proxy(populate_aerodrome_fields_from_icao)
    js.window.update_aerodrome_gui_fields = update_aerodrome_gui_fields
    js.window.update_general_gui_fields = update_general_gui_fields
    js.window.update_enroute_gui_fields = update_enroute_gui_fields
    js.window.update_aerodrome_image = update_aerodrome_image

    # CLEAR FIELDS
    js.window.clear_aerodrome_fields = clear_aerodrome_fields
    js.window.clear_enroute_fields = clear_enroute_fields

    js.window.cache_and_display_image = cache_and_display_image

    # DATA FUNCTIONS
    js.window.get_default_data = get_default_data
    js.window.get_default_settings = get_default_settings

    # AIRSPACE
    js.window.import_airspaces = import_airspaces
    js.window.altitude_restriction = altitude_restriction
    js.window.clean_altitude = clean_altitude
    js.window.altitude_restriction = altitude_restriction

    # METAR HELPERS
    js.window.expected_runway_number = expected_runway_number
    # js.window.analyzeWind = analyzeWind
    # js.window.JsToPy = JsToPy
    js.window.headwind = headwind
    js.window.crosswind = crosswind
    js.window.correctRunwayNumber = correctRunwayNumber
    js.window.compute_wind_envelope = compute_wind_envelope

  </script>


  <!-- Vanilla JS for tabs and flightplan buttons -->
  <script>
    const tabButtons = document.querySelectorAll(".tablinks");
    const tabContents = document.querySelectorAll(".tabcontent");

    // Function to replace INFORMATION with INFO in input fields
    function updateEnrouteFields() {
        document.querySelectorAll('.REPLACE_INFO').forEach(input => {
            if (input.value) {
                input.value = input.value.toUpperCase().replace(/INFORMATION/g, 'INFO');
            }
        });
    }

    tabButtons.forEach(btn => {
      btn.addEventListener("click", async () => {
        // Get the tab we're switching TO
        const targetTab = btn.getAttribute("data-tab");

        // Get the CURRENT active tab (before switching)
        const currentActiveTab = document.querySelector(".tablinks.active");
        const currentTab = currentActiveTab ? currentActiveTab.getAttribute("data-tab") : null;

        // Save data when switching tabs
        // if (pyscriptReady && window.save_flightplan && currentTab && currentTab !== targetTab) {
        //   try {
        //     await window.save_flightplan();
        //   } catch (error) {
        //     console.error("Error saving data before tab switch:", error);
        //   }
        // }

        // Switch tabs
        tabButtons.forEach(b => b.classList.remove("active"));
        tabContents.forEach(c => c.style.display = "none");
        btn.classList.add("active");
        document.getElementById(btn.getAttribute("data-tab")).style.display = "block";

        // REPLACE INFORMATION with "INFO" in the ENROUTE TAB.
        updateEnrouteFields();
        // CHECK MISSING FIELDS AFTER TAB SWITCH AND HIGHLIGHT
        highlightMissingFields();

        // WHEN THE TAB MAP IS CLICKED
        if (targetTab === "MAP") {
          if (typeof initRouteMap === "function") initRouteMap();
          if (typeof updateRoute === "function") updateRoute();
        }

      });
    });

    // Flightplan elements
    const CALLSIGN = document.getElementById('CALLSIGN');
    const AIRCRAFT_TYPE = document.getElementById('AIRCRAFT_TYPE');
    const POB = document.getElementById('POB');
    const FLIGHTPLAN = document.getElementById('FLIGHTPLAN');
    const DATETIME = document.getElementById('DATETIME');
    const FLIGHT_RULES = document.getElementById('FLIGHT_RULES');

    // Create buttons at the START page
    const new_plan_btn = document.getElementById('new_plan_btn');
    const delete_btn = document.getElementById('delete_btn');
    const fic_delete_btn = document.getElementById('fic_delete_btn');
    const fic_save_btn = document.getElementById('fic_save_btn');
    const fic_save_btn2 = document.getElementById('fic_save_btn2');

    // Create buttons to generate ATC at the ATC page
    const BTN_HTML_SUMMARY = document.getElementById('BTN_HTML_SUMMARY');
    const BTN_HTML_SUMMARY_REV = document.getElementById('BTN_HTML_SUMMARY_REV');
    const BTN_HTML_DEPARTURE = document.getElementById('BTN_HTML_DEPARTURE');
    const BTN_HTML_DEPARTURE_REV = document.getElementById('BTN_HTML_DEPARTURE_REV');
    const BTN_HTML_ARRIVAL = document.getElementById('BTN_HTML_ARRIVAL');
    const BTN_HTML_ARRIVAL_REV = document.getElementById('BTN_HTML_ARRIVAL_REV');
    const BTN_HTML_ENROUTE = document.getElementById('BTN_HTML_ENROUTE');
    const BTN_HTML_ENROUTE_REV = document.getElementById('BTN_HTML_ENROUTE_REV');

    // Missing labels
    const missing_label = document.getElementById('missing_label');

    // Uppercase for all fields with class="UPPERCASE_input"
    document.querySelectorAll('.UPPERCASE_input').forEach(input => {
    input.addEventListener('input', () => {
        input.value = input.value.toUpperCase();
        });
    });

    // Make transparent for all fields with class="TRANSPARENT_input"
    // document.querySelectorAll('.TRANSPARENT_input').forEach(input => {
    //     input.addEventListener('input', () => {
    //         if (input.value === '') {
    //             input.style.backgroundColor = '';
    //         } else {
    //             input.style.backgroundColor = 'transparent';
    //         }
    //     });
    // });

    document.querySelectorAll('.REPLACE_INFO').forEach(input => {
        input.addEventListener('input', () => {
            input.value = input.value.toUpperCase().replace(/INFORMATION/g, 'INFO');
            highlightMissingFields();
        });
    });


    // Initial calls to handle any existing values
    updateEnrouteFields();
    highlightMissingFields();

    // Wait for PyScript to be ready
    let pyscriptReady = false;

    function restoreSettingsFromCache() {
      /**
       * Restores user interface settings from browser localStorage if they exist
       * and updates font sizes accordingly.
       *
       * Specifically:
       * - Restores atc_fontsize setting from localStorage
       * - Restores atc_columns setting from localStorage
       * - Updates corresponding UI elements with restored values
       * - Updates font sizes based on restored settings
       *
       * If settings don't exist in localStorage, default values will be used.
       * Any errors during restoration are caught and logged to console.
       */
        try {
            // Restore settings from localStorage if they exist
            const savedUsageType = localStorage.getItem('atc_fontsize');
            const savedColumns = localStorage.getItem('atc_columns');

            if (savedUsageType) {
                window.settings.atc_fontsize = savedUsageType;
                const usageTypeElement = document.getElementById('atc_fontsize');
                if (usageTypeElement) {
                    usageTypeElement.value = savedUsageType;
                }
            }
            if (savedColumns) {
                window.settings.atc_columns = savedColumns;
                const columnsElement = document.getElementById('atc_columns');
                if (columnsElement) {
                    columnsElement.value = savedColumns;
                }
            }

            // Update font sizes with possibly restored settings
            window.settings.fontsizes = window.set_fontsizes(window.settings.atc_fontsize);
        } catch (error) {
            console.error('Error restoring settings:', error);
        }
    }

    // INITIALIZATION WHEN PYSCRIPT IS READY
    function checkPyScriptReady() {
      /**
       * Checks if PyScript is finished loading by testing if key functions are available.
       * Also initializes default flight plan data and settings if PyScript is ready.
       *
       * Key initializations:
       * - Sets window.flight_plan_data with default values
       * - Sets window.settings with default settings
       * - Restores cached display settings
       * - Hides loading spinner once complete
       *
       */
      if (typeof window.create_new_flightplan === 'function') {
        pyscriptReady = true;
        console.log("> func: checkPyScriptReady()");
        console.log("   >Default data is initialized.");

        // Get default settings
        window.settings = window.get_default_settings();
        // Set default images
        cacheAndSetImage(window.settings['img_default_icao'], 'DEPARTURE_image_cache')
        cacheAndSetImage(window.settings['img_default_icao'], 'ARRIVAL_image_cache')
        cacheAndSetImage(window.settings['coffee_logo'], 'coffee_logo')
        cacheAndSetImage(window.settings['skywalk_logo'], 'skywalk_logo')
        console.log("   >Logos are loaded..");

        // Get default flight plan data
        window.flight_plan_data = window.get_default_data();
        // Populate the menus
        checklist_populate()
        console.log("   >Checklist is populated..");
        update_dropdown('checklist_spinner', cacheName='CHECKLIST', keepSelection=false, elementId2='checklist_field');
        console.log("   >Settings data is initialized.");
        // Restore settings from cache
        restoreSettingsFromCache();
        console.log("   >Custom User settings are restored from cache.");
        // Populate the plan_spinner with FLIGHTPLAN_ keys on startup
        update_dropdown('plan_spinner', cacheName='FLIGHTPLAN', keepSelection=false);
        // Add the catagories for the spinner in checklist
        populateChecklistCatagories();
        // Update dropdown for the enroute spinners
        update_dropdown('fic_spinner', cacheName='enroute', keepSelection=false);
        update_dropdown('fic_spinner2', cacheName='enroute', keepSelection=false);
        // Clear the Flags
        updateFlag('DEPARTURE', 'remove');
        updateFlag('ARRIVAL', 'remove');
        // Clear the VFR icon
        updateFlightCatagoryIcon('DEPARTURE', remove=true);
        updateFlightCatagoryIcon('ARRIVAL', remove=true);
        // METAR defaults
        window.METAR_DEPARTURE = '';
        window.METAR_ARRIVAL = '';
        // Hide loading spinner once everything is ready
        // document.getElementById('loading-spinner').style.display = 'none';
      }
    }

    // Check periodically for PyScript
    const checkInterval = setInterval(() => {
      checkPyScriptReady();
      if (pyscriptReady) {
        clearInterval(checkInterval);
      }
    }, 100);

    // Connect PyScript functions to button clicks
    new_plan_btn.onclick = async () => {
      try {
        // Check if PyScript is ready
        if (!pyscriptReady) return alert("‚ö†Ô∏è Please wait, SkyWalk is initializing...");

        // Uncheck the airspace toggle
        const airspaceToggle = document.getElementById('airspace-toggle');
        if (airspaceToggle) {
          airspaceToggle.checked = false;
          // Trigger the change event to ensure the map updates
          airspaceToggle.dispatchEvent(new Event('change'));
        }

        // Clear all input fields and departure fields
        await clear_general_fields();

        // Set datetime
        DATETIME.value = await window.create_new_flightplan();

        // Store default flight plan data
        window.flight_plan_data = await window.get_default_data();

        // Clear plan spinner selection
        document.getElementById('plan_spinner').value = "";
        document.getElementById('fic_spinner').value = "";
        document.getElementById('fic_spinner2').value = "";

        // Update missing fields
        highlightMissingFields();

        // Show success message to user
        alert("‚úÖ All fields have been cleared and reset to their default values!");

      } catch (error) {
        console.error("‚ö†Ô∏è Error creating new flightplan:", error);
        alert("‚ö†Ô∏è An error occurred while creating the flight plan. Please try again.");
      }
    };

    // Auto-load functionality moved to plan_spinner onChange event
    document.getElementById('plan_spinner').addEventListener('change', async (e) => {
      if (e.target.value && pyscriptReady && window.load_flightplan) {
        try {
          await window.load_flightplan();
          console.log("‚úÖ Flightplan loaded successfully");
          // Update missing fields after loading
          highlightMissingFields();
        } catch (error) {
          console.error("‚ö†Ô∏è Error loading flightplan:", error);
          alert("‚ö†Ô∏è Error loading flight plan: " + error);
        }
      }
    });

    delete_btn.onclick = async () => {
      if (pyscriptReady && window.delete_flightplan) {
        await window.delete_flightplan();
      }
    };

    document.getElementById('fic_delete_btn')?.addEventListener('click', async () => {
      if (pyscriptReady && window.delete_item_from_spinner) {
        await window.delete_item_from_spinner('fic_spinner', 'ENROUTE');
      }
    });

    document.getElementById('fic_delete_btn2')?.addEventListener('click', async () => {
      if (pyscriptReady && window.delete_item_from_spinner) {
        await window.delete_item_from_spinner('fic_spinner2', 'ENROUTE');
      }
    });

    // Add save button functionality
    document.getElementById('fic_save_btn')?.addEventListener('click', () => {
      try {
          // Save FIC data to JSON files
          window.save_enroute_to_json('ENROUTE1');
          window.alert("‚úÖ Flight Information Center (FIC) data saved successfully!");
      } catch (error) {
        console.error("‚ö†Ô∏è Error saving Flight Information Center (FIC) data:", error);
      }
    });

    // Add save button functionality
    document.getElementById('fic_save_btn2')?.addEventListener('click', () => {
        try {
            // Save FIC data to JSON files
            window.save_enroute_to_json('ENROUTE2');
            window.alert("‚úÖ Flight Information Center (FIC) data saved successfully!");
        } catch (error) {
          console.error("‚ö†Ô∏è Error saving Flight Information Center (FIC) data:", error);
        }
    });

    document.getElementById('BTN_HTML_SUMMARY')?.addEventListener('click', () => {
      if (window.create_summary_atc) {
        window.save_flightplan({to_cache: true})
        window.create_summary_atc();
      }
    });
    document.getElementById('BTN_HTML_SUMMARY_REV')?.addEventListener('click', () => {
      if (window.create_summary_atc) {
        window.save_flightplan({to_cache: true})
        window.create_summary_atc({ reverse_path: true });
      }
    });

    document.getElementById('BTN_HTML_DEPARTURE')?.addEventListener('click', () => {
      if (window.create_departure_atc) {
        window.save_flightplan({to_cache: true})
        window.create_departure_atc();
      }
    });
    document.getElementById('BTN_HTML_DEPARTURE_REV')?.addEventListener('click', () => {
      if (window.create_departure_atc) {
        window.save_flightplan({to_cache: true})
        window.create_departure_atc({ reverse_path: true });
      }
    });

    document.getElementById('BTN_HTML_ARRIVAL')?.addEventListener('click', () => {
      if (window.create_arrival_atc) {
        window.save_flightplan({to_cache: true})
        window.create_arrival_atc();
      }
    });
    document.getElementById('BTN_HTML_ARRIVAL_REV')?.addEventListener('click', () => {
      if (window.create_arrival_atc) {
        window.save_flightplan({to_cache: true})
        window.create_arrival_atc({ reverse_path: true });
      }
    });

    document.getElementById('BTN_HTML_ENROUTE')?.addEventListener('click', () => {
      if (window.create_enroute_atc) {
        window.save_flightplan({to_cache: true})
        window.create_enroute_atc();
      }
    });
    document.getElementById('BTN_HTML_EN_REV')?.addEventListener('click', () => {
      if (window.create_enroute_atc) {
        window.save_flightplan({to_cache: true})
        window.create_enroute_atc({ reverse_path: true });
      }
    });

    // Update the wind envelope directly after chaning the inputfields
    ['DEPARTURE_WIND_SPEED', 'DEPARTURE_WIND_DIRECTION', 'ARRIVAL_WIND_SPEED', 'ARRIVAL_WIND_DIRECTION'].forEach(id => {
      document.getElementById(id)?.addEventListener('change', e => {
        const num = Number(String(e?.target?.value ?? '').trim());
        if (!Number.isFinite(num)) return;

        let prefix = '';
        if (id.startsWith('DEPARTURE')) {
          prefix = 'DEPARTURE';
        } else if (id.startsWith('ARRIVAL')) {
          prefix = 'ARRIVAL';
        }
        // Run the windEnvelope
        window.windEnvelope_js(prefix);
      });
    });


    // Update the aerodrome directly after changing the inputfields
    ['DEPARTURE_ICAO', 'DEPARTURE_ICAO_2', 'ARRIVAL_ICAO', 'ARRIVAL_ICAO_2'].forEach(id => {
      document.getElementById(id)?.addEventListener('change', e => {
        // At least 4 chars is required
        const field = String(e?.target?.value ?? '').trim();
        if (field.length < 4) return;

        let prefix = '';
        if (id.startsWith('DEPARTURE')) {
          prefix = 'DEPARTURE';
        } else if (id.startsWith('ARRIVAL')) {
          prefix = 'ARRIVAL';
        }
        // Load the aerodrome from json
        window.load_aerodrome_from_json(prefix, elementId=id)
      });
    });

    // Add clear cache button handler
    document.getElementById('clear_cache_btn')?.addEventListener('click', async () => {
      /**
      * Clears the browser's cached data and reloads the page.
      * Shows a confirmation dialog before clearing.
      * Displays a loading spinner while clearing.
      *
      * Steps:
      * 1. Shows confirmation dialog
      * 2. If confirmed:
      *   - Shows loading spinner
      *   - Calls window.clear_cache()
      *   - On success: Shows success message and reloads page
      *   - On error: Shows error message
      * 3. Always hides spinner when complete
      *
      */
        if (!confirm('This will clear all saved (cached) data. Are you sure?')) return;

        // const spinner = document.getElementById('loading-spinner');
        // const spinnerText = spinner.querySelector('.spinner-text');
        // spinnerText.textContent = 'Clearing cache...';
        // spinner.style.display = 'flex';

        try {
            if (await window.clear_cache()) {
                alert('‚úÖ Cache cleared successfully! SkyWalk will now reload.');
                location.reload();
            } else { alert('‚ö†Ô∏è Error clearing the cache. Please try again.'); }
        } catch (error) {
            alert('‚ö†Ô∏è An error occurred while clearing the cache: ' + error);
        } finally {
            spinner.style.display = 'none';
        }
    });


    function getGUIfields() {
        GUIfields = {
          'FLIGHTPLAN': {
              element: document.getElementById('FLIGHTPLAN'),
              name: 'Flightplan Name',
              color_empty: '#ffeb3b',
              color_filled: '#fafafa',
              required_atc_departure: false,
              required_atc_arrival: false,
              required_atc_enroute: false,
          },
          'CALLSIGN': {
                element: document.getElementById('CALLSIGN'),
                name: 'Callsign',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: true,
                required_atc_enroute: true,
            },
            'AIRCRAFT_TYPE': {
                element: document.getElementById('AIRCRAFT_TYPE'),
                name: 'Aircraft Type',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: true,
                required_atc_enroute: true,
            },
            'POB': {
                element: document.getElementById('POB'),
                name: 'Persons on Board',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: true,
                required_atc_enroute: true,
            },
            'DEPARTURE_ATC_TOWER': {
                element: document.getElementById('DEPARTURE_ATC_TOWER'),
                name: 'Departure Tower Frequency',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_ATC_ATIS_FREQ': {
                element: document.getElementById('DEPARTURE_ATC_ATIS_FREQ'),
                name: 'Departure ATIS Frequency',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_ATC_GROUND': {
                element: document.getElementById('DEPARTURE_ATC_GROUND'),
                name: 'Departure Ground Frequency',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_ATC_APPROACH': {
                element: document.getElementById('DEPARTURE_ATC_APPROACH'),
                name: 'Departure Frequency Approach',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_ATC_TELEPHONE': {
                element: document.getElementById('DEPARTURE_ATC_TELEPHONE'),
                name: 'Departure Telephone Number',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_ROUTE_ALTITUDE': {
                element: document.getElementById('DEPARTURE_ROUTE_ALTITUDE'),
                name: 'Departure Route Altitude',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_ROUTE_NAME': {
                element: document.getElementById('DEPARTURE_ROUTE_NAME'),
                name: 'Departure Route Name',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_RUNWAY': {
                element: document.getElementById('DEPARTURE_RUNWAY'),
                name: 'Departure Runway',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_POSITION': {
                element: document.getElementById('DEPARTURE_POSITION'),
                name: 'Departure Position',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_NAME': {
                element: document.getElementById('DEPARTURE_NAME'),
                name: 'Departure Airport Name',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: false,
                required_atc_enroute: true,
            },
            'DEPARTURE_ICAO': {
                element: document.getElementById('DEPARTURE_ICAO'),
                name: 'Departure ICAO',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: false,
                required_atc_enroute: true,
            },
            'DEPARTURE_ICAO_2': {
                element: document.getElementById('DEPARTURE_ICAO_2'),
                name: 'Departure ICAO 2',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_POSITION': {
                element: document.getElementById('ARRIVAL_POSITION'),
                name: 'Arrival Position',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_NAME': {
                element: document.getElementById('ARRIVAL_NAME'),
                name: 'Arrival Airport Name',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: true,
                required_atc_enroute: true,
            },
            'ARRIVAL_ICAO': {
                element: document.getElementById('ARRIVAL_ICAO'),
                name: 'Arrival ICAO',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: true,
                required_atc_enroute: true,
            },
            'ARRIVAL_ICAO_2': {
                element: document.getElementById('ARRIVAL_ICAO_2'),
                name: 'Arrival ICAO 2',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_RUNWAY': {
                element: document.getElementById('ARRIVAL_RUNWAY'),
                name: 'Arrival Runway',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: true,
                required_atc_enroute: false,
            },
            'ARRIVAL_ROUTE_NAME': {
                element: document.getElementById('ARRIVAL_ROUTE_NAME'),
                name: 'Arrival Route Name',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: true,
                required_atc_enroute: false,
            },
            'ARRIVAL_ROUTE_ALTITUDE': {
                element: document.getElementById('ARRIVAL_ROUTE_ALTITUDE'),
                name: 'Arrival Route Altitude',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: true,
                required_atc_enroute: false,
            },
            'ARRIVAL_CIRCUIT_ALTITUDE': {
                element: document.getElementById('ARRIVAL_CIRCUIT_ALTITUDE'),
                name: 'Arrival Circuit Altitude',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: true,
                required_atc_enroute: false,
            },
            'ARRIVAL_ATC_TOWER': {
                element: document.getElementById('ARRIVAL_ATC_TOWER'),
                name: 'Arrival Tower Frequency',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: true,
                required_atc_enroute: false,
            },
            'ARRIVAL_ATC_ATIS_FREQ': {
                element: document.getElementById('ARRIVAL_ATC_ATIS_FREQ'),
                name: 'Arrival ATIS Frequency',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_ATC_GROUND': {
                element: document.getElementById('ARRIVAL_ATC_GROUND'),
                name: 'Arrival Ground Frequency',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_ATC_APPROACH': {
                element: document.getElementById('ARRIVAL_ATC_APPROACH'),
                name: 'Arrival Frequency Approach',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_ATC_TELEPHONE': {
                element: document.getElementById('ARRIVAL_ATC_TELEPHONE'),
                name: 'Arrival Telephone Number',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },

            'FIC_NAME': {
                element: document.getElementById('FIC_NAME'),
                name: 'FIC Name',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: true,
            },
            'FIC_FREQUENCY': {
                element: document.getElementById('FIC_FREQUENCY'),
                name: 'FIC Frequency',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: true,
            },
            'OVERHEAD': {
                element: document.getElementById('OVERHEAD'),
                name: 'Overhead',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: true,
            },
            'SQUAWK': {
                element: document.getElementById('SQUAWK'),
                name: 'Squawk',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: true,
            },

            // THE NOT-ATC FIELDS
            'DEPARTURE_ELEVATION': {
                element: document.getElementById('DEPARTURE_ELEVATION'),
                name: 'Departure Elevation',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },

            'DEPARTURE_CIRCUIT_ALTITUDE': {
                element: document.getElementById('DEPARTURE_CIRCUIT_ALTITUDE'),
                name: 'Departure Circuit Altitude',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },

            //ARRIVAL NOT ATC FIELDS
            'ARRIVAL_ELEVATION': {
                element: document.getElementById('ARRIVAL_ELEVATION'),
                name: 'Arrival Elevation',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_ATC_APPROACH': {
                element: document.getElementById('ARRIVAL_ATC_APPROACH'),
                name: 'Arrival Frequency Approach',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_ATC_TELEPHONE': {
                element: document.getElementById('ARRIVAL_ATC_TELEPHONE'),
                name: 'Arrival Telephone Number',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            // DEPARTURE WIND
            'DEPARTURE_WIND_DIRECTION': {
                element: document.getElementById('DEPARTURE_WIND_DIRECTION'),
                name: 'Departure Wind Direction',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_WIND_SPEED': {
                element: document.getElementById('DEPARTURE_WIND_SPEED'),
                name: 'Departure Wind Speed',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_WIND_GUST': {
                element: document.getElementById('DEPARTURE_WIND_GUST'),
                name: 'Departure Wind Gust',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_WIND_VARIATION': {
                element: document.getElementById('DEPARTURE_WIND_VARIATION'),
                name: 'Departure Wind Variation',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_WIND_HEADWIND': {
                element: document.getElementById('DEPARTURE_WIND_HEADWIND'),
                name: 'Departure Headwind',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'DEPARTURE_WIND_CROSSWIND': {
                element: document.getElementById('DEPARTURE_WIND_CROSSWIND'),
                name: 'Departure Crosswind',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            // ARRIVAL WIND
            'ARRIVAL_WIND_DIRECTION': {
                element: document.getElementById('ARRIVAL_WIND_DIRECTION'),
                name: 'Arrival Wind Direction',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_WIND_SPEED': {
                element: document.getElementById('ARRIVAL_WIND_SPEED'),
                name: 'Arrival Wind Speed',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_WIND_GUST': {
                element: document.getElementById('ARRIVAL_WIND_GUST'),
                name: 'Arrival Wind Gust',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_WIND_VARIATION': {
                element: document.getElementById('ARRIVAL_WIND_VARIATION'),
                name: 'Arrival Wind Variation',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_WIND_HEADWIND': {
                element: document.getElementById('ARRIVAL_WIND_HEADWIND'),
                name: 'Arrival Headwind',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'ARRIVAL_WIND_CROSSWIND': {
                element: document.getElementById('ARRIVAL_WIND_CROSSWIND'),
                name: 'Arrival Crosswind',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            //ENROUTE FIELDS
            'FIC_NAME2': {
                element: document.getElementById('FIC_NAME2'),
                name: 'FIC2 Name',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'FIC_FREQUENCY2': {
                element: document.getElementById('FIC_FREQUENCY2'),
                name: 'FIC2 Frequency',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'OVERHEAD2': {
                element: document.getElementById('OVERHEAD2'),
                name: 'Overhead (second)',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
            'SQUAWK2': {
                element: document.getElementById('SQUAWK2'),
                name: 'Squawk (second)',
                color_empty: '',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: false,
                required_atc_enroute: false,
            },
        };

        // UPDATE THE EXCEPTIONS WHEN CTR IS USED
        if (DEPARTURE_CTR.value === 'CTR') {
            GUIfields.DEPARTURE_ATC_ATIS_FREQ = {
                element: document.getElementById('DEPARTURE_ATC_ATIS_FREQ'),
                name: 'Departure ATIS Frequency',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: false,
                required_atc_enroute: false,
            };
            GUIfields.DEPARTURE_ATC_GROUND = {
                element: document.getElementById('DEPARTURE_ATC_GROUND'),
                name: 'Departure Ground Frequency',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: true,
                required_atc_arrival: false,
                required_atc_enroute: false,
            };
        }
        if (ARRIVAL_CTR.value === 'CTR') {
            GUIfields.ARRIVAL_ATC_ATIS_FREQ = {
                element: document.getElementById('ARRIVAL_ATC_ATIS_FREQ'),
                name: 'Arrival ATIS Frequency',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: true,
                required_atc_enroute: false,
            };
            GUIfields.ARRIVAL_ATC_GROUND = {
                element: document.getElementById('ARRIVAL_ATC_GROUND'),
                name: 'Arrival Ground Frequency',
                color_empty: '#ffeb3b',
                color_filled: 'transparent',
                required_atc_departure: false,
                required_atc_arrival: true,
                required_atc_enroute: false,
            };
        }

        return GUIfields
    }

    const inputs = getGUIfields();
    let missing = [];

    function addTextMissingFields(missing) {
        // Create one big string with all missing labels that is shown in TAB of ATC
        missing_label.textContent = missing.length ? 'Missing: ' + missing.join(', ') : 'All fields are OK! Create your ATC now.';
        if (!missing.length) {
          missing_label.style.fontSize = '12px';
          missing_label.style.color = 'green';
        } else {
          missing_label.style.fontSize = '';
          missing_label.style.color = '';
        }
    }

    function updateGUIField(item, missing) {
        // Update the GUI field with color and add missing label when required for ATC fields
        if (!item.element.value) {
            // If any of the required ATC fields are empty, add the label to the missing array
            if (item.required_atc_departure || item.required_atc_arrival || item.required_atc_enroute) {
                missing.push(item.name);
            }
            item.element.style.backgroundColor = item.color_empty;
        } else {
            item.element.style.backgroundColor = item.color_filled;
        }

        // Print the key of the item (use the element's id as the key) for debugging
        // console.log('GUI field key:', item.element.id ?? '(no id)', 'label name:', item.name ?? '(no name)');
        // if (item.element && item.element.id && item.element.id.includes('ARRIVAL')) {
        //     const req = item.element.required_atc_arrival;
        //     if (req === true) {
        //         collapseMenu = document.getElementById('COLLAPSIBLE_MENU');
        //         collapseMenu.style.backgroundColor = '#ffeb3b';
        //     }
        // }

    }

    // Catch each keystroke and analyze it
    Object.values(inputs).forEach(item => {
        item.element.addEventListener('input', () => {
            // Update the GUI field
            updateGUIField(item, missing);
            // Add missing label when required for ATC fields
            addTextMissingFields(missing)
        });
    });

    // Function to check for missing fields and update highlighting
    function highlightMissingFields() {
      console.log("> func: highlightMissingFields()");
        const inputs = getGUIfields();
        const missing = [];
        // Loop through and highlight empty fields
        Object.entries(inputs).forEach(([key, item]) => {
          // Update the GUI field
            updateGUIField(item, missing);
        });
        // Add missing label when required for ATC fields
        addTextMissingFields(missing);
    }

  </script>

</body>
</html>




<script>
const COUNTRIES_DATA = [
  // Europe
  'Albania', 'Austria', 'Belarus', 'Belgium',
  'Bulgaria', 'Croatia', 'Cyprus', 'Czech Republic', 'Denmark', 'Estonia',
  'Finland', 'France', 'Germany', 'Greece', 'Hungary', 'Iceland', 'Ireland',
  'Italy', 'Luxembourg', 'Malta',
  'Moldova  Republic Of', 'Montenegro', 'Netherlands',
  'Norway', 'Poland', 'Portugal', 'Romania',
  'Spain', 'Sweden', 'Switzerland', 'Turkey',
  'United Kingdom',

  // Other
  'Maldives',

  // Americas (North, Central, South, Caribbean)
  'Canada', 'Curacao', 'United States',

  // Oceania
  'Australia', 'New Zealand',
];

  function populateDropdown(selectId, dataArray) {
    const select = document.getElementById(selectId);
    if (!select) {
      console.warn(`Select element with ID '${selectId}' not found`);
      return;
    }
    dataArray.forEach(item => {
      const option = document.createElement('option');
      option.value = item;
      option.textContent = item;
      select.appendChild(option);
    });
  }
</script>


<script>
    function initializeAerodromeFields(fname) {
        // Populate ICAO dropdown on page load
        window.addEventListener('DOMContentLoaded', () => {
            populateDropdown(`${fname}_COUNTRY`, COUNTRIES_DATA);
        });

        // Download the aerodrome data when the country changes
        document.getElementById(`${fname}_COUNTRY`).addEventListener("change", async function() {
            const country = this.value;
            if (country && window.import_country_selected) {

                // const spinner = document.getElementById('loading-spinner');
                // const spinnerText = spinner.querySelector('.spinner-text');
                // spinnerText.textContent = `Loading aerodrome data for ${country}...`;
                // spinner.style.display = 'flex';

                document.body.style.cursor = 'wait';
                document.body.style.overflow = 'hidden';  // Prevent scrolling while loading
                try {
                    await window.import_country_selected(fname, country);
                } catch (error) {
                    console.error("‚ö†Ô∏è Error importing aerodrome data:", error);
                    alert("‚ö†Ô∏è Error loading aerodrome data. Please try again.");
                } finally {
                    // spinner.style.display = 'none';
                    document.body.style.cursor = '';
                    document.body.style.overflow = '';  // Restore scrolling
                }
            }
        });

        // Populate fields when ICAO city is selected
        document.getElementById(`${fname}_ICAO_CITY`).addEventListener("change", async function() {
            const city_icao = this.value;

            // Clear all aerodrome fields first to prevent data leakage
            if (window.clear_aerodrome_fields) {
                await window.clear_aerodrome_fields(fname);
            }
            // Clear all enroute fields first to prevent data leakage
            if (fname === 'DEPARTURE' && window.clear_enroute_fields) {
                await window.clear_enroute_fields();
            }

            if (city_icao && window.populate_aerodrome_fields_from_icao) {
                // Call PyScript function to populate fields
                await window.populate_aerodrome_fields_from_icao(fname, city_icao);
                // Update missing fields
                highlightMissingFields();
            }
        });

        // Auto-save aerodrome data when fields change
        const fields = [
            `${fname}_COUNTRY`,
            `${fname}_ICAO_CITY`,
            `${fname}_CTR`,
            `${fname}_NAME`,
            `${fname}_ICAO`,
            `${fname}_POSITION`,
            `${fname}_RUNWAY`,
            `${fname}_ELEVATION`,
            `${fname}_ROUTE_NAME`,
            `${fname}_ROUTE_ALTITUDE`,
            `${fname}_CIRCUIT_ALTITUDE`,
            `${fname}_ATC_TOWER`,
            `${fname}_ATC_APPROACH`,
            `${fname}_ATC_ATIS_FREQ`,
            `${fname}_ATC_GROUND`,
            `${fname}_ATC_TELEPHONE`
        ];

        fields.forEach(fieldId => {
            const element = document.getElementById(fieldId);
            if (element) {
                element.addEventListener('change', () => {
                    if (window.flight_plan_data) {
                        window.flight_plan_data[fieldId] = element.value;
                        console.log(`Updated ${fieldId}:`, element.value);
                    }
                });
            }
        });
    }

    // Initialize with DEPARTURE
    initializeAerodromeFields('DEPARTURE');
    initializeAerodromeFields('ARRIVAL');

</script>


<script>
    // import React, { useState, useEffect } from 'react';
    // import * as Plotly from 'plotly';
    // function crosswind(windDir, windSpeed, runwayDir) {
    //   if (windDir === null || windSpeed === null) return null;
    //   const angle = windDir - runwayDir;
    //   return windSpeed * Math.sin(angle * Math.PI / 180);
    // }

    // function headwind(windDir, windSpeed, runwayDir) {
    //   if (windDir === null || windSpeed === null) return null;
    //   const angle = windDir - runwayDir;
    //   return windSpeed * Math.cos(angle * Math.PI / 180);
    // }

    // function correctRunwayNumber(runwayNumber) {
    //   const num = parseInt(runwayNumber);
    //   return num * 10; // Convert runway number to degrees
    // }

    function lineIntersection(x1, y1, x2, y2) {
      const intersections = { x: [], y: [] };

      for (let i = 0; i < x1.length - 1; i++) {
        for (let j = 0; j < x2.length - 1; j++) {
          const det = (x1[i+1] - x1[i]) * (y2[j+1] - y2[j]) - (x2[j+1] - x2[j]) * (y1[i+1] - y1[i]);

          // if (Math.abs(det) > 0.0001) {
          if (det > 0.0001) {
            const t = ((x2[j] - x1[i]) * (y2[j+1] - y2[j]) - (y2[j] - y1[i]) * (x2[j+1] - x2[j])) / det;
            const u = ((x2[j] - x1[i]) * (y1[i+1] - y1[i]) - (y2[j] - y1[i]) * (x1[i+1] - x1[i])) / det;

            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
              intersections.x.push(x1[i] + t * (x1[i+1] - x1[i]));
              intersections.y.push(y1[i] + t * (y1[i+1] - y1[i]));
            }
          }
        }
      }

      return intersections;
    }

    function pointInPolygon(x, y, polyX, polyY) {
      let inside = false;
      for (let i = 0, j = polyX.length - 1; i < polyX.length; j = i++) {
        const xi = polyX[i], yi = polyY[i];
        const xj = polyX[j], yj = polyY[j];

        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function variableWindRange(variation) {
      if (!variation) return null;
      const parts = variation.split('/');
      if (parts.length !== 2) return null;

      const start = parseInt(parts[0]);
      const end = parseInt(parts[1]);

      const range = [];
      let current = start;
      while (current !== end) {
        range.push(current);
        current = (current + 10) % 360;
      }
      range.push(end);

      return range;
    }

    async function windEnvelope_js(prefix, maxHeadwind = 25, maxCrosswind = 15, update_gui_fields = true) {
      console.log(`>func: windEnvelope_js(${prefix})`);
      // Get the values from the input fields
      const runwayNumberField = document.getElementById(prefix + '_RUNWAY');
      const windDirectionField = document.getElementById(prefix + '_WIND_DIRECTION');
      const windSpeedField = document.getElementById(prefix + '_WIND_SPEED');
      const windGustField = document.getElementById(prefix + '_WIND_GUST');
      const windVariationField = document.getElementById(prefix + '_WIND_VARIATION');

      // The fields below are updated with the calculated headwind and crosswind values
      const windHeadwindField = document.getElementById(prefix + '_WIND_HEADWIND');
      const windCrosswindField = document.getElementById(prefix + '_WIND_CROSSWIND');
      const windEnvelopeField = document.getElementById(prefix + '_WIND_ENVELOPE_TEXT');
      // maxHeadwind = window.settings['MAX_HEADWIND_LIMIT']
      // maxCrosswind = window.settings['MAX_CROSSWIND_LIMIT']

      const results = {
        xy: [null, null],
        xy_outside_envelope: false,
        wind_vrb: false,
        wind_gust: false,
        line_intersection: null,
        message: ''
      };

      const evalStrValue = (value) => {
        if (value === '' || value === null || value === 'nan' || value === 'NA' ||
            value === 'N/A' || value === 'None' || value === 'none' || value === undefined) {
          return null;
        }
        try {
          return parseInt(value);
        } catch {
          return value;
        }
      };

      const runwayDirection = correctRunwayNumber(runwayNumberField.value);
      const windDirection = evalStrValue(windDirectionField.value);
      const windStrength = evalStrValue(windSpeedField.value);
      const windGust = evalStrValue(windGustField.value);
      const windVrb = (windVariationField.value) ? windVariationField.value.replace(/-/g, '/') : windVariationField.value;

      // Runway direction is required
      if (runwayDirection == '') {
          alert("‚ö†Ô∏è No valid runway information available. Set the runway number manually to compute the wind envelope.");
          return results;
      }

      if (windDirection === null || windStrength === null) {
        results.message = 'Wind Envelope cannot be computed with missing wind direction or strength.';
        return results;
      }

      if (String(windDirection).trim().toLowerCase() === 'vrb') {
        results.message = 'Wind Envelope cannot be computed with variable (VRB) winds.';
        return results;
      }

      results.wind_gust = windGust;

      // Generate wind direction range
      const windDirectionFull = [];
      for (let i = 0; i < 360; i += 10) {
        windDirectionFull.push(i);
      }

      // Compute crosswind and headwind components
      const crosswindComponents = windDirectionFull.map(dir =>
        // Math.abs(Math.sin((windDirection - dir) * Math.PI / 180) * maxCrosswind) // only show right part
        Math.sin((windDirection - dir) * Math.PI / 180) * maxCrosswind // show left and right half
      );
      const headwindComponents = windDirectionFull.map(dir =>
        Math.abs(Math.cos((windDirection - dir) * Math.PI / 180) * maxHeadwind) // only shown top half
        // Math.cos((windDirection - dir) * Math.PI / 180) * maxHeadwind // show top and down half
      );

      // Current wind envelope
      const crosswindRange = windDirectionFull.map(dir =>
        // Math.abs(Math.sin((windDirection - dir) * Math.PI / 180) * windStrength) // only show right part
        Math.sin((windDirection - dir) * Math.PI / 180) * windStrength // show left and right half
      );
      const headwindRange = windDirectionFull.map(dir =>
        Math.abs(Math.cos((windDirection - dir) * Math.PI / 180) * windStrength) // only shown top half
        // Math.cos((windDirection - dir) * Math.PI / 180) * windStrength // show top and down half
      );

      // Compute cross/headwind
      let crosswindX = crosswind(windDirection, windStrength, runwayDirection) || 0;
      let headwindY = headwind(windDirection, windStrength, runwayDirection) || 0;

      // Check intersection
      let intersection = lineIntersection(crosswindComponents, headwindComponents, crosswindRange, headwindRange);
      let x = null, y = null;

      if (intersection.x.length > 0) {
        results.line_intersection = 'intersection';
        x = intersection.x.reduce((a, b) => a + b, 0) / intersection.x.length;
        y = intersection.y.reduce((a, b) => a + b, 0) / intersection.y.length;
      }

      // Variable wind range
      const windVrbRange = variableWindRange(windVrb);

      if (windVrbRange !== null) {
        results.wind_vrb = true;
        const crosswindRange1 = windVrbRange.map(dir =>
          // Math.abs(Math.sin((windDirection - dir) * Math.PI / 180) * windStrength) // only show right part
          Math.sin((windDirection - dir) * Math.PI / 180) * windStrength // show left and right half
        );
        const headwindRange1 = windVrbRange.map(dir =>
          // Math.abs(Math.cos((windDirection - dir) * Math.PI / 180) * windStrength) // only show right part
          Math.cos((windDirection - dir) * Math.PI / 180) * windStrength // show left and right half
        );

        intersection = lineIntersection(crosswindComponents, headwindComponents, crosswindRange1, headwindRange1);
        if (intersection.x.length > 0) {
          results.line_intersection = 'vrb_range';
          x = intersection.x.reduce((a, b) => a + b, 0) / intersection.x.length;
          y = intersection.y.reduce((a, b) => a + b, 0) / intersection.y.length;
        }
      }

      // Check if outside envelope
      const p1Y = Math.abs(headwindY); // only shown top half
      // const p1Y = headwindY; // show top and down half
      // const p1X = Math.abs(crosswindX);
      const p1X = crosswindX;

      const sortedIndices = crosswindComponents
        .map((val, idx) => ({ val, idx }))
        .sort((a, b) => a.val - b.val)
        .map(item => item.idx);

      const polyX = sortedIndices.map(i => crosswindComponents[i]);
      const polyY = sortedIndices.map(i => headwindComponents[i]);
      polyX.push(0, polyX[0]);
      polyY.push(0, polyY[0]);

      if (!pointInPolygon(p1X, p1Y, polyX, polyY)) {
        results.line_intersection = 'outside envelope';
        results.xy_outside_envelope = true;
      }

      // Set message and xy
      if (headwindY < 0) {
        results.message = `Warning: Tail wind for runway ${runwayDirection}.`;
        results.xy = [x, y];
      } else if (results.line_intersection === 'outside envelope') {
        results.message = `Warning: Wind is outside the limit boundaries for runway ${runwayDirection}.`;
        results.xy = [crosswindX, headwindY];
      } else if (results.line_intersection === 'vrb_range') {
        results.message = `Warning: Variable wind directions may cause to stray beyond the limit boundaries for runway ${runwayDirection}.`;
        results.xy = [x, y];
      } else if (results.line_intersection === 'intersection') {
        results.message = `Warning: Wind angle and direction is within the limits for runway ${runwayDirection}. However, in case the wind directions changes, it strays beyond the limit boundaries for runway ${runwayDirection}.`;
        results.xy = [x, y];
      } else {
        results.message = `All variable winds are within the limits for runway ${runwayDirection}.`;
        results.xy = [null, null];
      }

      if (crosswindX < 0 && headwindY > 0) {
          results.message += ` Crosswind (${crosswindX}kt) is from the left.`;
      } else if (crosswindX > 0 && headwindY > 0) {
          results.message += ` Crosswind (${crosswindX}kt) is from the right.`;
      }

      if (windDirection === null ||  isNaN(windDirection)) {
        results.message = `Wind direction is ${windDirectionField.value} and therefore the wind envelope could not be determined. You can set the wind direction field manually to determine the effect on runway ${runwayDirection}.`;
        element = document.getElementById(`${prefix}_WIND_ENVELOPE_TEXT`)
        element.value = results.message
        element = document.getElementById(`${prefix}_WIND_ENVELOPE_PLOT`)
        element.innerHTML = ''
        return null
      }

      // Create plot data
      const traces = [
        {
          x: crosswindComponents,
          y: headwindComponents,
          mode: 'lines+markers',
          name: 'Wind Limit Envelope',
          line: { color: 'blue' }
        },
        {
          x: crosswindRange,
          y: headwindRange,
          mode: 'lines',
          name: 'Wind Angle [0-360]',
          line: { color: 'red', dash: 'dash' }
        },
        {
          // x: [Math.abs(crosswindX)], // only show right part
          // y: [Math.abs(headwindY)],  // only show right part
          x: [crosswindX], // show left and right half
          y: [headwindY], // show left and right half
          mode: 'markers',
          name: 'Current wind',
          marker: { color: '#8B0000', symbol: 'x', size: 15 }
        }
      ];

      if (windVrbRange !== null) {
        const vrbCrosswindRange = windVrbRange.map(dir =>
          // Math.abs(Math.sin((windDirection - dir) * Math.PI / 180) * windStrength) // only show right part
          Math.sin((windDirection - dir) * Math.PI / 180) * windStrength // show left and right half
        );
        const vrbHeadwindRange = windVrbRange.map(dir =>
          Math.abs(Math.cos((windDirection - dir) * Math.PI / 180) * windStrength) // show only top half
          // Math.cos((windDirection - dir) * Math.PI /  180) * windStrength // show top and down half
        );

        traces.push({
          x: vrbCrosswindRange,
          y: vrbHeadwindRange,
          mode: 'lines',
          name: 'Variable Wind',
          line: { color: '#FF8C00' }
        });
      }

      if (windGust !== null) {
        const crosswindGustX = crosswind(windDirection, windGust, runwayDirection);
        const headwindGustY = headwind(windDirection, windGust, runwayDirection);

        const crosswindGust = windDirectionFull.map(dir =>
          // Math.abs(Math.sin((windDirection - dir) * Math.PI / 180) * windGust) // show only right half
          Math.sin((windDirection - dir) * Math.PI / 180) * windGust // how left and right half
        );
        const headwindGust = windDirectionFull.map(dir =>
          Math.abs(Math.cos((windDirection - dir) * Math.PI / 180) * windGust) // show only top half
          // Math.cos((windDirection - dir) * Math.PI / 180) * windGust // show top and down half
        );

        traces.push({
          // x: [Math.abs(crosswindGustX)], // only show right part
          // y: [Math.abs(headwindGustY)], // only show right part
          x: [crosswindGustX], // show left and right half
          y: [headwindGustY], // show left and right half
          mode: 'markers',
          name: 'Wind gust',
          marker: { color: '#9678b6', symbol: 'x', size: 15 }
        });

        traces.push({
          x: crosswindGust,
          y: headwindGust,
          mode: 'lines',
          name: 'Gust Angle [0-360]',
          line: { color: '#9678b6', dash: 'dash' }
        });

        if (windVrbRange !== null) {
          const vrbCrosswindsGust = windVrbRange.map(dir =>
            // Math.abs(Math.sin((windDirection - dir) * Math.PI / 180) * windGust) // only show right part
            Math.sin((windDirection - dir) * Math.PI / 180) * windGust // show left and right half
          );
          const vrbHeadwindsGust = windVrbRange.map(dir =>
            // Math.abs(Math.cos((windDirection - dir) * Math.PI / 180) * windGust) // show only top half
            Math.cos((windDirection - dir) * Math.PI / 180) * windGust // show top and down half
          );

          traces.push({
            x: vrbCrosswindsGust,
            y: vrbHeadwindsGust,
            mode: 'lines',
            name: 'Variable Wind (Gust)',
            line: { color: '#e9692c' }
          });
        }
      }

      results.traces = traces;
      results.runwayDirection = runwayDirection;

      // MAKE PLOT
      if (results.traces) {
        // const title = `Wind Envelope for runway ${results.runwayDirection}<br>${results.message.replace(/\./g, '.<br>')}`;
        // const xlim = [-maxCrosswind-2, maxCrosswind+2];
        // const ylim = [-5, maxHeadwind * 1.3];

        // maxHeadwind = 25, maxCrosswind=15

        const layout = {
          // xaxis: { title: 'Crosswind Component (knots)', range: xlim },
          // yaxis: { title: 'Headwind Component (knots)', range: ylim },
          xaxis: { title: 'Crosswind Component (knots)' },
          yaxis: { title: 'Headwind Component (knots)' },
          showlegend: false,
          // height: 350,
          // width: 350,
          margin: { t: 20, l: 30, r: 10, b: 30 },
          font: { size: 8 }
        };

        console.log('   >Create plotly plot for wind envelope!');
        Plotly.newPlot(`${prefix}_WIND_ENVELOPE_PLOT`, results.traces, layout, {responsive: true});
      }

      // Update headwind and crosswind values
      if (update_gui_fields) {
        console.log('   >Update headwind and crosswind values')
        windHeadwindField.value = headwindY;
        windCrosswindField.value = crosswindX;
      }

      // Update the text field
      windEnvelopeField.value = results.message;

      // Animate the new clouds
      animateCloud(prefix)

      // Return
      return results;
    }



</script>
